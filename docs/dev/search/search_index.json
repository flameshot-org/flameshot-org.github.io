{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flameshot developer docs","text":"<p>Thank you for your interest in developing flameshot. This developer documentation (hopefully) has an intuitive structure. It tries to describe what code is run when a user performs an action in Flameshot.</p> <p>Important</p> <p>**Please read this entire page. It will make your life a whole lot easier when contributing to Flameshot. If you know exactly what you want to work on, you should look at FAQ **</p>"},{"location":"#project-structure","title":"Project structure","text":"<p>Flameshot is built on C++/Qt5 with CMake as its build system. The source code is located under <code>src/</code>. The entrypoint is <code>src/main.cpp</code>.</p>"},{"location":"#maincpp","title":"<code>main.cpp</code>","text":"<p>Flameshot provides both a GUI and a CLI (the latter currently works only on Linux and macOS).</p>"},{"location":"#build-system","title":"Build system","text":"<p>The main cmake file is <code>CMakeLists.txt</code> in the project root. It <code>include</code>s some files from the <code>cmake/</code> directory as well. These files together control some more general aspects of the build process, like project information, packaging, caching etc.</p> <p>There is also the file <code>src/CMakeLists.txt</code>. It mostly defines how the source files are compiled into targets and how the external libraries are linked. It does some other stuff too. Currently, there isn't a clear separation of concerns between <code>CMakeLists.txt</code> and <code>src/CMakeLists.txt</code>. In the future we should refactor these files to make it more clear why each of them exists.</p>"},{"location":"#what-happens-when-i-launch-flameshot","title":"What happens when I launch flameshot?","text":"<p>There are two ways to launch flameshot: daemon mode and single-action mode. In both modes, an instance of <code>Flameshot</code> is created via <code>Flameshot::start()</code>. <code>Flameshot</code> provides the high level API for interacting with flameshot; and its methods mimic the CLI subcommands a great deal. This object is a singleton, so it can only be created once. It is accessed as <code>Flameshot::instance()</code>.</p> <p>Note</p> <p>On Windows, only daemon mode is currently supported.</p>"},{"location":"#single-action-mode-via-command-line-interface","title":"Single-action mode (via command line interface)","text":"<p>Single-action mode (also called one-off mode) is triggered when flameshot is launched with a command line argument - for example as <code>flameshot gui</code>. As its name implies, it performs a single action, such as \"take a screenshot interactively by opening a GUI\" or \"take a screenshot of the entire screen\", etc. Afterwards, Flameshot quits.</p>"},{"location":"#daemon-mode","title":"Daemon mode","text":"<p>This mode is triggered when the <code>flameshot</code> command is launched. In this mode, a flameshot process is started in the background. A system tray is displayed if the user hasn't disabled it in the config. In addition to <code>Flameshot::start()</code>, if the current process is the daemon, it also calls <code>FlameshotDaemon::start()</code> during initialization.</p> <p>The daemon has the following purposes:</p> <ul> <li> <p>Run in the background, wait for the user to press a hotkey, and perform   corresponding action.</p> <p>This is true for Windows and macOS, but not for Linux. On Linux, hotkeys are meant to be handled by the desktop environment or equivalent.</p> </li> <li> <p>Provide a system tray that the user can click to initiate actions via context   menu</p> </li> <li> <p>Periodically check for updates and notify the user</p> </li> <li> <p>Act as a host for persistent phenomena. Example: On X11 (linux), when a program   inserts content into the clipboard, it must keep running so the content   persists in the clipboard.</p> </li> </ul> <p>Note</p> <p>All of the above are user-configurable.</p>"},{"location":"#flameshotdaemon","title":"<code>FlameshotDaemon</code>","text":"<p>The class <code>FlameshotDaemon</code> handles all communication with the daemon. The class provides public static methods that are designed so that the caller does not need to know if the current process is a flameshot daemon or a single-action invocation of Flameshot. If the current process is the daemon, then the static methods of <code>FlameshotDaemon</code> will call the corresponding instance methods of the singleton. If not, the current process will communicate with the daemon process via D-Bus. Then, within the daemon process, those D-Bus calls will be translated into <code>FlameshotDaemon</code> instance method calls.</p>"},{"location":"#configuration","title":"Configuration","text":"<p>The configuration is handled by <code>ConfigHandler</code>. It is decoupled from any user interface, so it serves the configuration for both the GUI and CLI. All configuration settings recognized by the config files are defined as getters in this class. There are also setters for each setting, named as per the usual convention. For example, the setting <code>savePath</code> has a getter named <code>savePath</code> and a setter named <code>setSavePath</code>. Before working on a new config setting for flameshot, please read this FAQ entry.</p>"},{"location":"#interesting-notes","title":"Interesting notes","text":"<ul> <li><code>ConfigHandler</code> is based on <code>QSettings</code></li> <li>The configuration uses the <code>ini</code> format</li> <li>The configuration is automatically reloaded when the config file changes</li> </ul>"},{"location":"#conventions","title":"Conventions","text":"<ul> <li>Always use <code>&amp;Class::signal</code> and <code>&amp;Class::slot</code> instead of <code>SIGNAL(signal())</code>   and <code>SLOT(slot())</code>. This usually provides better code introspection and makes   refactoring easier and less error-prone.</li> </ul>"},{"location":"debugging/","title":"Debugging","text":""},{"location":"debugging/#flameshot_debug_capture","title":"<code>FLAMESHOT_DEBUG_CAPTURE</code>","text":"<p>With this cmake variable set to <code>ON</code>, the flameshot capture GUI window won't bypass the window manager. This allows you to manipulate the capture GUI window like any other window while debugging.</p> <p>This can be useful if a debugging breakpoint is triggered while flameshot is in full screen mode. Without this variable, you might have trouble inspecting the code due to a frozen full-screen window.</p> <p>Usage:</p> <pre><code>cmake -DFLAMESHOT_DEBUG_CAPTURE=ON ...\n</code></pre>"},{"location":"docs/","title":"Maintaining the documentation","text":"<p>The narrative documentation is written in markdown and built into HTML using MkDocs, particularly the MkDocs material theme. The source code documentation is generated using Doxygen and adapted for MkDocs using MkDoxy (a tweaked custom fork of the original). The source code of this documentation can be found here.</p> <p>Tip</p> <p>In order to edit a page from the documentation, click the  button in the top right corner of the page. Please note that this button won't work within the API section of the documentation - the button is removed from there during post-processing, but it will still be visible when serving the website locally.</p>"},{"location":"docs/#serving-locally","title":"Serving locally","text":"<p>To serve the documentation locally, run the <code>make serve</code> target in the <code>docs/dev</code> directory. The server is available at the port designated in the output of the command.</p>"},{"location":"docs/#notes-and-conventions","title":"Notes and conventions","text":"<ul> <li>When you add new files or rename existing files or section names, be sure to   edit the <code>nav</code> property of mkdocs.yml.</li> <li>Always insert links as reference style   links. This will make the docs source code   more readable and make broken links more easily detectable and replaceable.</li> </ul>"},{"location":"docs/#post-processing","title":"Post-processing","text":"<p>There are some tweaks we make to the generated HTML documentation. We do that in the <code>make build</code> target, by running the post-process.sh script. To see what post-processing we do, see that file.</p> <p>For this reason, the version of the documentation served locally using <code>make serve</code> will not match the generated HTML documentation 100%. But those inconsistencies are few and minor.</p>"},{"location":"docs/#dependencies","title":"Dependencies","text":"<pre><code>pip install \\\n    mkdocs \\\n    mkdocs-material \\\n    git+https://github.com/veracioux/mkdoxy@v1.0.0\n</code></pre> <p>Note</p> <p>We use a forked version of mkdoxy that can be found here, that fixes some annoying things from the original.</p>"},{"location":"docs/#deployment","title":"Deployment","text":"<p>The developer documentation is served from the official Flameshot website flameshot.org. Here's how.</p> <p>The official website itself is served from this repo. That repo contains the user documentation. It's deployed using GitHub pages -- the served files can be found on the gh-pages branch of that repo. This branch is automatically created by the build workflow on master.</p> <p>To make the developer docs available on the official site, we use a custom GitHub action called deploy-dev-docs in the flameshot repo. This action will build and deploy this documentation into the <code>docs/dev</code> subdirectory of the gh-pages branch.</p>"},{"location":"docs/#the-deploy-dev-docs-github-workflow","title":"The deploy-dev-docs GitHub workflow","text":"<p>This workflow checks out the flameshot website repo and does the following:</p> <ul> <li>Creates a clean dev-docs-staging branch (we'll explain why, below).</li> <li>Generates the developer docs under <code>docs/dev</code> there and makes a commit</li> <li>Checks out the gh-pages branch and makes the same commit there</li> <li>Force-pushes the dev-docs-staging branch to the website repo</li> <li>Pushes the gh-pages branch to the website repo</li> </ul> <p>Since the gh-pages branch is re-created from scratch by the website deployment workflow, the commit that added the developer documentation will be lost. That's why we have to re-apply the commit during the website deployment workflow as well. That is the reason why we created the dev-docs-staging branch in the first place.</p> <p>Note</p> <p>The deploy-dev-docs workflow is set to run on the <code>docs</code> branch as well as <code>master</code>. This branch is used for debugging the developer docs and its associated workflows, without polluting the <code>master</code> branch with unnecessary commits.</p>"},{"location":"docs/#access-tokens","title":"Access tokens","text":"<p>In order to make changes to the website repo from within a workflow in the flameshot repo, the workflow needs to use an access token, which it obtains from the <code>TOKEN_PUSH_TO_WEBSITE_REPO</code> secret.</p> <p>The following process was used to set it up:</p> <ol> <li>A flameshot organization member with write access must create a personal    access token (PAT) here with write access to the website repo.</li> <li>A secret named <code>TOKEN_PUSH_TO_WEBSITE_REPO</code> must be added to the    flameshot repo and its value must be set to the PAT. This can be done    here.</li> </ol> <p>For best security practice, the token should be set to expire after some time (currently ~6 months). The token can be regenerated without the need to recreate it. After regeneration you will need to update the <code>TOKEN_PUSH_TO_WEBSITE_REPO</code> secret, which can be done here.</p> <p>Tip</p> <p>The currently active PAT is owned by veracioux and is set to expire on July 31 2024. If you notice the token has expired, ask him to re-generate it.</p>"},{"location":"faq/","title":"FAQ","text":"<p>Todo</p> <p>Incomplete page.</p>"},{"location":"faq/#how-do-i-create-a-new-subcommand","title":"How do I create a new subcommand?","text":""},{"location":"faq/#how-do-i-add-a-new-tool","title":"How do I add a new tool?","text":""},{"location":"faq/#how-do-i-add-a-new-config-setting","title":"How do I add a new config setting?","text":"<p>There are currently two groups of settings: <code>General</code> and <code>Shortcuts</code>. The necessary steps are usually the following:</p> <ul> <li>Determine a name for the setting - for a general setting, it must be a valid   C++ identifier, for a shortcut it must be the name of a tool type from TODO.</li> <li>Add a getter and a setter for the setting in <code>ConfigHandler</code>.   For most settings you should use the   <code>CONFIG_GETTER_SETTER</code> macro. If your setting is   unusual enough you may need to use <code>CONFIG_GETTER</code> or   <code>CONFIG_SETTER</code> individually, or even need to create the   methods manually.</li> <li>If you need custom validation or conversion for the value, you must create a   subclass of <code>ValueHandler</code>. Otherwise you can use one of the   existing ones in valuehandler.h.</li> <li>If you want to make your setting available in the configuration GUI (usually   you do), you should add the appropriate widgets into one of the tabs of   <code>ConfigWindow</code>. If your setting doesn't fit into any of the   existing tabs, you can add a new one, but please discuss it with us first.</li> </ul> <p>To get a deeper understanding of how the configuration works, please see Configuration.</p>"},{"location":"faq/#how-do-i-add-a-new-export-action-borgmanjeremy-mehrad-this-is-my-preferred-terminology-over-final-action-need-consensus","title":"How do I add a new export action? (@borgmanJeremy @mehrad This is my preferred terminology over final action, need consensus)","text":""},{"location":"flameshot/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace @103 </li> <li>namespace @2 </li> <li>namespace @57 </li> <li>namespace @61 </li> <li>namespace @67 </li> <li>namespace @85 </li> <li>namespace @91 </li> <li>class AbstractActionTool </li> <li>class AbstractLogger A class that allows you to log events to where they need to go. </li> <li>class AbstractPathTool </li> <li>class AbstractTwoPointTool </li> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class AppLauncherWidget </li> <li>class ArrowTool </li> <li>class Bool </li> <li>class BoundedInt </li> <li>class ButtonHandler </li> <li>class ButtonList </li> <li>class ButtonListView </li> <li>class CaptureButton </li> <li>struct CaptureContext </li> <li>class CaptureLauncher </li> <li>class CaptureRequest </li> <li>class CaptureToolButton </li> <li>class CaptureToolObjects </li> <li>class CaptureWidget </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class ClickableLabel </li> <li>class Color </li> <li>class ColorGrabWidget </li> <li>class ColorPicker </li> <li>class ColorPickerEditMode </li> <li>class ColorPickerEditor </li> <li>class ColorPickerWidget </li> <li>namespace ColorUtils </li> <li>class CommandArgument </li> <li>class CommandLineParser </li> <li>struct Node </li> <li>class CommandOption </li> <li>struct CompareAppByName </li> <li>class ConfigErrorDetails </li> <li>class ConfigHandler </li> <li>class ConfigResolver </li> <li>class ConfigWindow </li> <li>class CopyTool </li> <li>struct DesktopAppData </li> <li>struct DesktopFileParser </li> <li>class DesktopInfo </li> <li>class DraggableWidgetMaker </li> <li>class ExistingDir </li> <li>class ExitTool </li> <li>class ExtendedSlider </li> <li>class FileNameEditor </li> <li>class FileNameHandler </li> <li>class FilenamePattern </li> <li>class Flameshot </li> <li>class FlameshotDBusAdapter </li> <li>class FlameshotDaemon </li> <li>class GeneralConf </li> <li>class GlobalShortcutFilter </li> <li>namespace GlobalValues </li> <li>class History </li> <li>struct HistoryFileName </li> <li>class HoverEventFilter </li> <li>class ImageLabel </li> <li>class ImgUploadDialog </li> <li>class ImgUploaderBase </li> <li>class ImgUploaderManager </li> <li>class ImgUploaderTool </li> <li>class ImgurUploader </li> <li>class InfoWindow </li> <li>class InvertTool </li> <li>class KeySequence </li> <li>class LauncherItemDelegate </li> <li>class LineTool </li> <li>class LoadSpinner </li> <li>class LowerBoundedInt </li> <li>class MagnifierWidget </li> <li>class MarkerTool </li> <li>class ModificationCommand </li> <li>class MoveTool </li> <li>class NotificationWidget </li> <li>class NotifierBox </li> <li>class OrgFreedesktopPortalRequestInterface </li> <li>class OrientablePushButton </li> <li>class OverlayMessage Overlay a message in capture mode. </li> <li>namespace PathInfo </li> <li>class PencilTool </li> <li>class PinTool </li> <li>class PinWidget </li> <li>class PixelateTool </li> <li>class QGuiAppCurrentScreen </li> <li>class QSharedPointer </li> <li>class RectangleTool </li> <li>class RedoTool </li> <li>class Region </li> <li>class SaveFileExtension </li> <li>class SaveTool </li> <li>class ScreenGrabber </li> <li>class SelectionTool </li> <li>class SelectionWidget </li> <li>class SetShortcutDialog </li> <li>class ShortcutsWidget </li> <li>class SidePanelWidget </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class StrftimeChooserWidget </li> <li>class String </li> <li>class StyleOverride </li> <li>class SystemNotification </li> <li>struct TerminalApp </li> <li>class TerminalLauncher </li> <li>class TextConfig </li> <li>class TextTool </li> <li>class TextWidget </li> <li>class ToolFactory </li> <li>class TrayIcon </li> <li>class UIcolorEditor </li> <li>namespace Ui </li> <li>class UndoTool </li> <li>class UpdateNotificationWidget </li> <li>class UploadHistory </li> <li>class UploadLineItem </li> <li>class UserColors </li> <li>class UtilityPanel </li> <li>class ValueHandler Handles the value of a configuration option (abstract class). </li> <li>class VisualsEditor </li> <li>class WaylandUtils </li> <li>struct WinLnkFileParser </li> <li>namespace org </li> <li>namespace freedesktop <ul> <li>namespace portal </li> </ul> </li> <li>namespace strfparse </li> </ul>"},{"location":"flameshot/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src </li> <li>dir cli <ul> <li>file commandargument.cpp </li> <li>file commandargument.h </li> <li>file commandlineparser.cpp </li> <li>file commandlineparser.h </li> <li>file commandoption.cpp </li> <li>file commandoption.h </li> </ul> </li> <li>dir config <ul> <li>file buttonlistview.cpp </li> <li>file buttonlistview.h </li> <li>file cacheutils.cpp </li> <li>file cacheutils.h </li> <li>file clickablelabel.cpp </li> <li>file clickablelabel.h </li> <li>file colorpickereditmode.cpp </li> <li>file colorpickereditmode.h </li> <li>file colorpickereditor.cpp </li> <li>file colorpickereditor.h </li> <li>file configerrordetails.cpp </li> <li>file configerrordetails.h </li> <li>file configresolver.cpp </li> <li>file configresolver.h </li> <li>file configwindow.cpp </li> <li>file configwindow.h </li> <li>file extendedslider.cpp </li> <li>file extendedslider.h </li> <li>file filenameeditor.cpp </li> <li>file filenameeditor.h </li> <li>file generalconf.cpp </li> <li>file generalconf.h </li> <li>file setshortcutwidget.cpp </li> <li>file setshortcutwidget.h </li> <li>file shortcutswidget.cpp </li> <li>file shortcutswidget.h </li> <li>file strftimechooserwidget.cpp </li> <li>file strftimechooserwidget.h </li> <li>file styleoverride.cpp </li> <li>file styleoverride.h </li> <li>file uicoloreditor.cpp </li> <li>file uicoloreditor.h </li> <li>file visualseditor.cpp </li> <li>file visualseditor.h </li> </ul> </li> <li>dir core <ul> <li>file capturerequest.cpp </li> <li>file capturerequest.h </li> <li>file flameshot.cpp </li> <li>file flameshot.h </li> <li>file flameshotdaemon.cpp </li> <li>file flameshotdaemon.h </li> <li>file flameshotdbusadapter.cpp </li> <li>file flameshotdbusadapter.h </li> <li>file globalshortcutfilter.cpp </li> <li>file globalshortcutfilter.h </li> <li>file qguiappcurrentscreen.cpp </li> <li>file qguiappcurrentscreen.h </li> </ul> </li> <li>file main.cpp </li> <li>dir tools <ul> <li>file abstractactiontool.cpp </li> <li>file abstractactiontool.h </li> <li>file abstractpathtool.cpp </li> <li>file abstractpathtool.h </li> <li>file abstracttwopointtool.cpp </li> <li>file abstracttwopointtool.h </li> <li>dir accept </li> <li>file accepttool.cpp </li> <li>file accepttool.h </li> <li>dir arrow </li> <li>file arrowtool.cpp </li> <li>file arrowtool.h </li> <li>file capturecontext.cpp </li> <li>file capturecontext.h </li> <li>dir circle </li> <li>file circletool.cpp </li> <li>file circletool.h </li> <li>dir circlecount </li> <li>file circlecounttool.cpp </li> <li>file circlecounttool.h </li> <li>dir copy </li> <li>file copytool.cpp </li> <li>file copytool.h </li> <li>dir exit </li> <li>file exittool.cpp </li> <li>file exittool.h </li> <li>dir imgupload </li> <li>file imguploadermanager.cpp </li> <li>file imguploadermanager.h </li> <li>file imguploadertool.cpp </li> <li>file imguploadertool.h </li> <li>dir storages <ul> <li>file imguploaderbase.cpp </li> <li>file imguploaderbase.h </li> <li>dir imgur </li> <li>file imguruploader.cpp </li> <li>file imguruploader.h </li> </ul> </li> <li>dir invert </li> <li>file inverttool.cpp </li> <li>file inverttool.h </li> <li>dir launcher </li> <li>file applaunchertool.cpp </li> <li>file applaunchertool.h </li> <li>file applauncherwidget.cpp </li> <li>file applauncherwidget.h </li> <li>file launcheritemdelegate.cpp </li> <li>file launcheritemdelegate.h </li> <li>file openwithprogram.cpp </li> <li>file openwithprogram.h </li> <li>file terminallauncher.cpp </li> <li>file terminallauncher.h </li> <li>dir line </li> <li>file linetool.cpp </li> <li>file linetool.h </li> <li>dir marker </li> <li>file markertool.cpp </li> <li>file markertool.h </li> <li>dir move </li> <li>file movetool.cpp </li> <li>file movetool.h </li> <li>dir pencil </li> <li>file penciltool.cpp </li> <li>file penciltool.h </li> <li>dir pin </li> <li>file pintool.cpp </li> <li>file pintool.h </li> <li>file pinwidget.cpp </li> <li>file pinwidget.h </li> <li>dir pixelate </li> <li>file pixelatetool.cpp </li> <li>file pixelatetool.h </li> <li>dir rectangle </li> <li>file rectangletool.cpp </li> <li>file rectangletool.h </li> <li>dir redo </li> <li>file redotool.cpp </li> <li>file redotool.h </li> <li>dir save </li> <li>file savetool.cpp </li> <li>file savetool.h </li> <li>dir selection </li> <li>file selectiontool.cpp </li> <li>file selectiontool.h </li> <li>dir sizedecrease </li> <li>file sizedecreasetool.cpp </li> <li>file sizedecreasetool.h </li> <li>dir sizeincrease </li> <li>file sizeincreasetool.cpp </li> <li>file sizeincreasetool.h </li> <li>dir text </li> <li>file textconfig.cpp </li> <li>file textconfig.h </li> <li>file texttool.cpp </li> <li>file texttool.h </li> <li>file textwidget.cpp </li> <li>file textwidget.h </li> <li>file toolfactory.cpp </li> <li>file toolfactory.h </li> <li>dir undo </li> <li>file undotool.cpp </li> <li>file undotool.h </li> </ul> </li> <li>dir utils <ul> <li>file abstractlogger.cpp </li> <li>file abstractlogger.h </li> <li>file colorutils.cpp </li> <li>file colorutils.h </li> <li>file confighandler.cpp </li> <li>file confighandler.h </li> <li>file desktopfileparse.cpp </li> <li>file desktopfileparse.h </li> <li>file desktopinfo.cpp </li> <li>file desktopinfo.h </li> <li>file filenamehandler.cpp </li> <li>file filenamehandler.h </li> <li>file globalvalues.cpp </li> <li>file globalvalues.h </li> <li>file history.cpp </li> <li>file history.h </li> <li>file pathinfo.cpp </li> <li>file pathinfo.h </li> <li>file request.cpp </li> <li>file request.h </li> <li>file screengrabber.cpp </li> <li>file screengrabber.h </li> <li>file screenshotsaver.cpp </li> <li>file screenshotsaver.h </li> <li>file strfparse.cpp </li> <li>file strfparse.h </li> <li>file systemnotification.cpp </li> <li>file systemnotification.h </li> <li>file valuehandler.cpp </li> <li>file valuehandler.h </li> <li>file waylandutils.cpp </li> <li>file waylandutils.h </li> <li>file winlnkfileparse.cpp </li> <li>file winlnkfileparse.h </li> </ul> </li> <li>dir widgets <ul> <li>dir capture </li> <li>file buttonhandler.cpp </li> <li>file buttonhandler.h </li> <li>file capturebutton.cpp </li> <li>file capturebutton.h </li> <li>file capturetoolbutton.cpp </li> <li>file capturetoolbutton.h </li> <li>file capturetoolobjects.cpp </li> <li>file capturetoolobjects.h </li> <li>file capturewidget.cpp </li> <li>file capturewidget.h </li> <li>file colorpicker.cpp </li> <li>file colorpicker.h </li> <li>file hovereventfilter.cpp </li> <li>file hovereventfilter.h </li> <li>file magnifierwidget.cpp </li> <li>file magnifierwidget.h </li> <li>file modificationcommand.cpp </li> <li>file modificationcommand.h </li> <li>file notifierbox.cpp </li> <li>file notifierbox.h </li> <li>file overlaymessage.cpp </li> <li>file overlaymessage.h </li> <li>file selectionwidget.cpp </li> <li>file selectionwidget.h </li> <li>file capturelauncher.cpp </li> <li>file capturelauncher.h </li> <li>file colorpickerwidget.cpp </li> <li>file colorpickerwidget.h </li> <li>file draggablewidgetmaker.cpp </li> <li>file draggablewidgetmaker.h </li> <li>file imagelabel.cpp </li> <li>file imagelabel.h </li> <li>file imguploaddialog.cpp </li> <li>file imguploaddialog.h </li> <li>file infowindow.cpp </li> <li>file infowindow.h </li> <li>file loadspinner.cpp </li> <li>file loadspinner.h </li> <li>file notificationwidget.cpp </li> <li>file notificationwidget.h </li> <li>file orientablepushbutton.cpp </li> <li>file orientablepushbutton.h </li> <li>dir panel </li> <li>file colorgrabwidget.cpp </li> <li>file colorgrabwidget.h </li> <li>file sidepanelwidget.cpp </li> <li>file sidepanelwidget.h </li> <li>file utilitypanel.cpp </li> <li>file utilitypanel.h </li> <li>file trayicon.cpp </li> <li>file trayicon.h </li> <li>file updatenotificationwidget.cpp </li> <li>file updatenotificationwidget.h </li> <li>file uploadhistory.cpp </li> <li>file uploadhistory.h </li> <li>file uploadlineitem.cpp </li> <li>file uploadlineitem.h </li> </ul> </li> </ul>"},{"location":"flameshot/namespace_0d103/","title":"Namespace @103","text":"<p>Namespace List &gt; @103</p>"},{"location":"flameshot/namespace_0d2/","title":"Namespace @2","text":"<p>Namespace List &gt; @2</p>"},{"location":"flameshot/namespace_0d57/","title":"Namespace @57","text":"<p>Namespace List &gt; @57</p>"},{"location":"flameshot/namespace_0d57/#public-types","title":"Public Types","text":"Type Name enum DIAG_UNIT enum UNIT"},{"location":"flameshot/namespace_0d57/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/namespace_0d57/#enum-diag_unit","title":"enum DIAG_UNIT","text":"<pre><code>enum @57::DIAG_UNIT;\n</code></pre>"},{"location":"flameshot/namespace_0d57/#enum-unit","title":"enum UNIT","text":"<pre><code>enum @57::UNIT;\n</code></pre>"},{"location":"flameshot/namespace_0d61/","title":"Namespace @61","text":"<p>Namespace List &gt; @61</p>"},{"location":"flameshot/namespace_0d67/","title":"Namespace @67","text":"<p>Namespace List &gt; @67</p>"},{"location":"flameshot/namespace_0d85/","title":"Namespace @85","text":"<p>Namespace List &gt; @85</p>"},{"location":"flameshot/namespace_0d91/","title":"Namespace @91","text":"<p>Namespace List &gt; @91</p>"},{"location":"flameshot/classAbstractActionTool/","title":"Class AbstractActionTool","text":"<p>ClassList &gt; AbstractActionTool</p> <p>Inherits the following classes: CaptureTool</p> <p>Inherited by the following classes: AcceptTool,  AppLauncher,  CopyTool,  ExitTool,  ImgUploaderTool,  MoveTool,  PinTool,  RedoTool,  SaveTool,  SizeDecreaseTool,  SizeIncreaseTool,  UndoTool</p>"},{"location":"flameshot/classAbstractActionTool/#public-functions","title":"Public Functions","text":"Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classAbstractActionTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAbstractActionTool/#function-abstractactiontool","title":"function AbstractActionTool","text":"<pre><code>explicit AbstractActionTool::AbstractActionTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classAbstractActionTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect AbstractActionTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classAbstractActionTool/#function-isselectable","title":"function isSelectable","text":"<pre><code>bool AbstractActionTool::isSelectable () override const\n</code></pre>"},{"location":"flameshot/classAbstractActionTool/#function-isvalid","title":"function isValid","text":"<pre><code>bool AbstractActionTool::isValid () override const\n</code></pre>"},{"location":"flameshot/classAbstractActionTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void AbstractActionTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classAbstractActionTool/#function-process","title":"function process","text":"<pre><code>void AbstractActionTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classAbstractActionTool/#function-showmousepreview","title":"function showMousePreview","text":"<pre><code>bool AbstractActionTool::showMousePreview () override const\n</code></pre>"},{"location":"flameshot/classAbstractLogger/","title":"Class AbstractLogger","text":"<p>ClassList &gt; AbstractLogger</p> <p>A class that allows you to log events to where they need to go. </p> <ul> <li><code>#include &lt;abstractlogger.h&gt;</code></li> </ul>"},{"location":"flameshot/classAbstractLogger/#public-types","title":"Public Types","text":"Type Name enum Channel enum Target"},{"location":"flameshot/classAbstractLogger/#public-functions","title":"Public Functions","text":"Type Name AbstractLogger (Channel channel=Info, int targets=Default)  AbstractLogger (QString &amp; str, Channel channel, int additionalTargets=String) Construct an AbstractLogger with output to a string. AbstractLogger &amp; addOutputString (QString &amp; str)  AbstractLogger &amp; attachNotificationPath (const QString &amp; path) Attach a path to a notification so it can be dragged and dropped. AbstractLogger &amp; enableMessageHeader (bool enable) Enable/disable message header (e.g. \"flameshot: info:\"). AbstractLogger &amp; operator&lt;&lt; (const QString &amp; msg) Send a message to the default channel of this logger. AbstractLogger &amp; sendMessage (const QString &amp; msg, Channel channel)  ~AbstractLogger ()"},{"location":"flameshot/classAbstractLogger/#public-static-functions","title":"Public Static Functions","text":"Type Name AbstractLogger error (int targets=Default)  AbstractLogger info (int targets=Default)  AbstractLogger warning (int targets=Default)"},{"location":"flameshot/classAbstractLogger/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classAbstractLogger/#enum-channel","title":"enum Channel","text":"<pre><code>enum AbstractLogger::Channel {\n    Info,\n    Warning,\n    Error\n};\n</code></pre>"},{"location":"flameshot/classAbstractLogger/#enum-target","title":"enum Target","text":"<pre><code>enum AbstractLogger::Target {\n    Notification = 0x01,\n    Stderr = 0x02,\n    LogFile = 0x08,\n    String = 0x10,\n    Stdout = 0x20,\n    Default = Notification | LogFile | Stderr\n};\n</code></pre>"},{"location":"flameshot/classAbstractLogger/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAbstractLogger/#function-abstractlogger-12","title":"function AbstractLogger [1/2]","text":"<pre><code>AbstractLogger::AbstractLogger (\n    Channel channel=Info,\n    int targets=Default\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-abstractlogger-22","title":"function AbstractLogger [2/2]","text":"<p>Construct an AbstractLogger with output to a string.</p> <pre><code>AbstractLogger::AbstractLogger (\n    QString &amp; str,\n    Channel channel,\n    int additionalTargets=String\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>additionalChannels</code> Optional additional targets to output to. </li> </ul>"},{"location":"flameshot/classAbstractLogger/#function-addoutputstring","title":"function addOutputString","text":"<pre><code>AbstractLogger &amp; AbstractLogger::addOutputString (\n    QString &amp; str\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-attachnotificationpath","title":"function attachNotificationPath","text":"<pre><code>AbstractLogger &amp; AbstractLogger::attachNotificationPath (\n    const QString &amp; path\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-enablemessageheader","title":"function enableMessageHeader","text":"<pre><code>AbstractLogger &amp; AbstractLogger::enableMessageHeader (\n    bool enable\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-operator","title":"function operator&lt;&lt;","text":"<p>Send a message to the default channel of this logger. </p> <pre><code>AbstractLogger &amp; AbstractLogger::operator&lt;&lt; (\n    const QString &amp; msg\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>msg</code> </li> </ul> <p>Returns:</p>"},{"location":"flameshot/classAbstractLogger/#function-sendmessage","title":"function sendMessage","text":"<pre><code>AbstractLogger &amp; AbstractLogger::sendMessage (\n    const QString &amp; msg,\n    Channel channel\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-abstractlogger","title":"function ~AbstractLogger","text":"<pre><code>AbstractLogger::~AbstractLogger () \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classAbstractLogger/#function-error","title":"function error","text":"<pre><code>static AbstractLogger AbstractLogger::error (\n    int targets=Default\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-info","title":"function info","text":"<pre><code>static AbstractLogger AbstractLogger::info (\n    int targets=Default\n) \n</code></pre>"},{"location":"flameshot/classAbstractLogger/#function-warning","title":"function warning","text":"<pre><code>static AbstractLogger AbstractLogger::warning (\n    int targets=Default\n) \n</code></pre>"},{"location":"flameshot/classAbstractPathTool/","title":"Class AbstractPathTool","text":"<p>ClassList &gt; AbstractPathTool</p> <p>Inherits the following classes: CaptureTool</p> <p>Inherited by the following classes: PencilTool</p>"},{"location":"flameshot/classAbstractPathTool/#public-functions","title":"Public Functions","text":"Type Name AbstractPathTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; mousePos) override const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classAbstractPathTool/#protected-attributes","title":"Protected Attributes","text":"Type Name QColor m_color int m_padding QRect m_pathArea QVector&lt; QPoint &gt; m_points QPoint m_pos"},{"location":"flameshot/classAbstractPathTool/#protected-functions","title":"Protected Functions","text":"Type Name void addPoint (const QPoint &amp; point)  void copyParams (const AbstractPathTool * from, AbstractPathTool * to)"},{"location":"flameshot/classAbstractPathTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAbstractPathTool/#function-abstractpathtool","title":"function AbstractPathTool","text":"<pre><code>explicit AbstractPathTool::AbstractPathTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect AbstractPathTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool AbstractPathTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-isselectable","title":"function isSelectable","text":"<pre><code>bool AbstractPathTool::isSelectable () override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-isvalid","title":"function isValid","text":"<pre><code>bool AbstractPathTool::isValid () override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-mousepreviewrect","title":"function mousePreviewRect","text":"<pre><code>QRect AbstractPathTool::mousePreviewRect (\n    const CaptureContext &amp; context\n) override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-move","title":"function move","text":"<pre><code>void AbstractPathTool::move (\n    const QPoint &amp; mousePos\n) override\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-pos","title":"function pos","text":"<pre><code>const QPoint * AbstractPathTool::pos () override\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-showmousepreview","title":"function showMousePreview","text":"<pre><code>bool AbstractPathTool::showMousePreview () override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-size","title":"function size","text":"<pre><code>inline int AbstractPathTool::size () override const\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"flameshot/classAbstractPathTool/#variable-m_color","title":"variable m_color","text":"<pre><code>QColor AbstractPathTool::m_color;\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#variable-m_padding","title":"variable m_padding","text":"<pre><code>int AbstractPathTool::m_padding;\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#variable-m_patharea","title":"variable m_pathArea","text":"<pre><code>QRect AbstractPathTool::m_pathArea;\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#variable-m_points","title":"variable m_points","text":"<pre><code>QVector&lt;QPoint&gt; AbstractPathTool::m_points;\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#variable-m_pos","title":"variable m_pos","text":"<pre><code>QPoint AbstractPathTool::m_pos;\n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classAbstractPathTool/#function-addpoint","title":"function addPoint","text":"<pre><code>void AbstractPathTool::addPoint (\n    const QPoint &amp; point\n) \n</code></pre>"},{"location":"flameshot/classAbstractPathTool/#function-copyparams","title":"function copyParams","text":"<pre><code>void AbstractPathTool::copyParams (\n    const AbstractPathTool * from,\n    AbstractPathTool * to\n) \n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/","title":"Class AbstractTwoPointTool","text":"<p>ClassList &gt; AbstractTwoPointTool</p> <p>Inherits the following classes: CaptureTool</p> <p>Inherited by the following classes: ArrowTool,  CircleCountTool,  CircleTool,  InvertTool,  LineTool,  MarkerTool,  PixelateTool,  RectangleTool,  SelectionTool</p>"},{"location":"flameshot/classAbstractTwoPointTool/#public-functions","title":"Public Functions","text":"Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classAbstractTwoPointTool/#protected-attributes","title":"Protected Attributes","text":"Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classAbstractTwoPointTool/#protected-functions","title":"Protected Functions","text":"Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classAbstractTwoPointTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAbstractTwoPointTool/#function-abstracttwopointtool","title":"function AbstractTwoPointTool","text":"<pre><code>explicit AbstractTwoPointTool::AbstractTwoPointTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect AbstractTwoPointTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool AbstractTwoPointTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-color","title":"function color","text":"<pre><code>inline const QColor &amp; AbstractTwoPointTool::color () \n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-isselectable","title":"function isSelectable","text":"<pre><code>bool AbstractTwoPointTool::isSelectable () override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-isvalid","title":"function isValid","text":"<pre><code>bool AbstractTwoPointTool::isValid () override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-mousepreviewrect","title":"function mousePreviewRect","text":"<pre><code>QRect AbstractTwoPointTool::mousePreviewRect (\n    const CaptureContext &amp; context\n) override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-move","title":"function move","text":"<pre><code>void AbstractTwoPointTool::move (\n    const QPoint &amp; pos\n) override\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void AbstractTwoPointTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-points","title":"function points","text":"<pre><code>inline const QPair&lt; QPoint, QPoint &gt; AbstractTwoPointTool::points () const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-pos","title":"function pos","text":"<pre><code>const QPoint * AbstractTwoPointTool::pos () override\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-showmousepreview","title":"function showMousePreview","text":"<pre><code>bool AbstractTwoPointTool::showMousePreview () override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-size","title":"function size","text":"<pre><code>inline int AbstractTwoPointTool::size () override const\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"flameshot/classAbstractTwoPointTool/#variable-m_supportsdiagonaladj","title":"variable m_supportsDiagonalAdj","text":"<pre><code>bool AbstractTwoPointTool::m_supportsDiagonalAdj;\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#variable-m_supportsorthogonaladj","title":"variable m_supportsOrthogonalAdj","text":"<pre><code>bool AbstractTwoPointTool::m_supportsOrthogonalAdj;\n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classAbstractTwoPointTool/#function-copyparams","title":"function copyParams","text":"<pre><code>void AbstractTwoPointTool::copyParams (\n    const AbstractTwoPointTool * from,\n    AbstractTwoPointTool * to\n) \n</code></pre>"},{"location":"flameshot/classAbstractTwoPointTool/#function-setpadding","title":"function setPadding","text":"<pre><code>inline void AbstractTwoPointTool::setPadding (\n    int padding\n) \n</code></pre>"},{"location":"flameshot/classAcceptTool/","title":"Class AcceptTool","text":"<p>ClassList &gt; AcceptTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classAcceptTool/#public-functions","title":"Public Functions","text":"Type Name AcceptTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classAcceptTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classAcceptTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classAcceptTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAcceptTool/#function-accepttool","title":"function AcceptTool","text":"<pre><code>explicit AcceptTool::AcceptTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classAcceptTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool AcceptTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classAcceptTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * AcceptTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classAcceptTool/#function-description","title":"function description","text":"<pre><code>QString AcceptTool::description () override const\n</code></pre>"},{"location":"flameshot/classAcceptTool/#function-icon","title":"function icon","text":"<pre><code>QIcon AcceptTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classAcceptTool/#function-name","title":"function name","text":"<pre><code>QString AcceptTool::name () override const\n</code></pre>"},{"location":"flameshot/classAcceptTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classAcceptTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type AcceptTool::type () override const\n</code></pre>"},{"location":"flameshot/classAppLauncher/","title":"Class AppLauncher","text":"<p>ClassList &gt; AppLauncher</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classAppLauncher/#public-functions","title":"Public Functions","text":"Type Name AppLauncher (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const QWidget * widget () override"},{"location":"flameshot/classAppLauncher/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classAppLauncher/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classAppLauncher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAppLauncher/#function-applauncher","title":"function AppLauncher","text":"<pre><code>explicit AppLauncher::AppLauncher (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classAppLauncher/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool AppLauncher::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classAppLauncher/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * AppLauncher::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classAppLauncher/#function-description","title":"function description","text":"<pre><code>QString AppLauncher::description () override const\n</code></pre>"},{"location":"flameshot/classAppLauncher/#function-icon","title":"function icon","text":"<pre><code>QIcon AppLauncher::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classAppLauncher/#function-name","title":"function name","text":"<pre><code>QString AppLauncher::name () override const\n</code></pre>"},{"location":"flameshot/classAppLauncher/#function-widget","title":"function widget","text":"<pre><code>QWidget * AppLauncher::widget () override\n</code></pre>"},{"location":"flameshot/classAppLauncher/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classAppLauncher/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type AppLauncher::type () override const\n</code></pre>"},{"location":"flameshot/classAppLauncherWidget/","title":"Class AppLauncherWidget","text":"<p>ClassList &gt; AppLauncherWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classAppLauncherWidget/#public-functions","title":"Public Functions","text":"Type Name AppLauncherWidget (const QPixmap &amp; p, QWidget * parent=nullptr)"},{"location":"flameshot/classAppLauncherWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classAppLauncherWidget/#function-applauncherwidget","title":"function AppLauncherWidget","text":"<pre><code>explicit AppLauncherWidget::AppLauncherWidget (\n    const QPixmap &amp; p,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classArrowTool/","title":"Class ArrowTool","text":"<p>ClassList &gt; ArrowTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classArrowTool/#public-functions","title":"Public Functions","text":"Type Name ArrowTool (QObject * parent=nullptr)  QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classArrowTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classArrowTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classArrowTool/#protected-functions","title":"Protected Functions","text":"Type Name void copyParams (const ArrowTool * from, ArrowTool * to)  CaptureTool::Type type () override const"},{"location":"flameshot/classArrowTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classArrowTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classArrowTool/#function-arrowtool","title":"function ArrowTool","text":"<pre><code>explicit ArrowTool::ArrowTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classArrowTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect ArrowTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classArrowTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * ArrowTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classArrowTool/#function-description","title":"function description","text":"<pre><code>QString ArrowTool::description () override const\n</code></pre>"},{"location":"flameshot/classArrowTool/#function-icon","title":"function icon","text":"<pre><code>QIcon ArrowTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classArrowTool/#function-name","title":"function name","text":"<pre><code>QString ArrowTool::name () override const\n</code></pre>"},{"location":"flameshot/classArrowTool/#function-process","title":"function process","text":"<pre><code>void ArrowTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classArrowTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classArrowTool/#function-copyparams","title":"function copyParams","text":"<pre><code>void ArrowTool::copyParams (\n    const ArrowTool * from,\n    ArrowTool * to\n) \n</code></pre>"},{"location":"flameshot/classArrowTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type ArrowTool::type () override const\n</code></pre>"},{"location":"flameshot/classBool/","title":"Class Bool","text":"<p>ClassList &gt; Bool</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classBool/#public-functions","title":"Public Functions","text":"Type Name Bool (bool def)  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value)."},{"location":"flameshot/classBool/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classBool/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classBool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classBool/#function-bool","title":"function Bool","text":"<pre><code>Bool::Bool (\n    bool def\n) \n</code></pre>"},{"location":"flameshot/classBool/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool Bool::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classBool/#function-expected","title":"function expected","text":"<pre><code>virtual QString Bool::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classBool/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant Bool::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classBoundedInt/","title":"Class BoundedInt","text":"<p>ClassList &gt; BoundedInt</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classBoundedInt/#public-functions","title":"Public Functions","text":"Type Name BoundedInt (int min, int max, int def)  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value)."},{"location":"flameshot/classBoundedInt/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classBoundedInt/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classBoundedInt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classBoundedInt/#function-boundedint","title":"function BoundedInt","text":"<pre><code>BoundedInt::BoundedInt (\n    int min,\n    int max,\n    int def\n) \n</code></pre>"},{"location":"flameshot/classBoundedInt/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool BoundedInt::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classBoundedInt/#function-expected","title":"function expected","text":"<pre><code>virtual QString BoundedInt::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classBoundedInt/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant BoundedInt::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classButtonHandler/","title":"Class ButtonHandler","text":"<p>ClassList &gt; ButtonHandler</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classButtonHandler/#public-functions","title":"Public Functions","text":"Type Name ButtonHandler (const QVector&lt; CaptureToolButton * &gt; &amp; v, QObject * parent=nullptr)  ButtonHandler (QObject * parent=nullptr)  bool buttonsAreInside () const bool contains (const QPoint &amp; p) const void hideSectionUnderMouse (const QPoint &amp; p)  bool isVisible () const void setButtons (const QVector&lt; CaptureToolButton * &gt; &amp; v)  size_t size () const void updateScreenRegions (const QVector&lt; QRect &gt; &amp; rects)  void updateScreenRegions (const QRect &amp; rect)"},{"location":"flameshot/classButtonHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classButtonHandler/#function-buttonhandler-12","title":"function ButtonHandler [1/2]","text":"<pre><code>ButtonHandler::ButtonHandler (\n    const QVector&lt; CaptureToolButton * &gt; &amp; v,\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-buttonhandler-22","title":"function ButtonHandler [2/2]","text":"<pre><code>explicit ButtonHandler::ButtonHandler (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-buttonsareinside","title":"function buttonsAreInside","text":"<pre><code>bool ButtonHandler::buttonsAreInside () const\n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-contains","title":"function contains","text":"<pre><code>bool ButtonHandler::contains (\n    const QPoint &amp; p\n) const\n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-hidesectionundermouse","title":"function hideSectionUnderMouse","text":"<pre><code>void ButtonHandler::hideSectionUnderMouse (\n    const QPoint &amp; p\n) \n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-isvisible","title":"function isVisible","text":"<pre><code>bool ButtonHandler::isVisible () const\n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-setbuttons","title":"function setButtons","text":"<pre><code>void ButtonHandler::setButtons (\n    const QVector&lt; CaptureToolButton * &gt; &amp; v\n) \n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-size","title":"function size","text":"<pre><code>size_t ButtonHandler::size () const\n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-updatescreenregions-12","title":"function updateScreenRegions [1/2]","text":"<pre><code>void ButtonHandler::updateScreenRegions (\n    const QVector&lt; QRect &gt; &amp; rects\n) \n</code></pre>"},{"location":"flameshot/classButtonHandler/#function-updatescreenregions-22","title":"function updateScreenRegions [2/2]","text":"<pre><code>void ButtonHandler::updateScreenRegions (\n    const QRect &amp; rect\n) \n</code></pre>"},{"location":"flameshot/classButtonList/","title":"Class ButtonList","text":"<p>ClassList &gt; ButtonList</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classButtonList/#public-functions","title":"Public Functions","text":"Type Name virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value). virtual QVariant process (const QVariant &amp; val) overrideProcess a value, presuming it is a valid <code>QVariant</code> . virtual QVariant representation (const QVariant &amp; val) overrideReturn the representation of the value in the config file."},{"location":"flameshot/classButtonList/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classButtonList/#public-static-functions","title":"Public Static Functions","text":"Type Name QList&lt; CaptureTool::Type &gt; fromIntList (const QList&lt; int &gt; &amp; l)  bool normalizeButtons (QList&lt; int &gt; &amp; buttons)  QList&lt; int &gt; toIntList (const QList&lt; CaptureTool::Type &gt; &amp; l)"},{"location":"flameshot/classButtonList/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classButtonList/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classButtonList/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool ButtonList::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classButtonList/#function-expected","title":"function expected","text":"<pre><code>virtual QString ButtonList::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classButtonList/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant ButtonList::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classButtonList/#function-process","title":"function process","text":"<p>Process a value, presuming it is a valid <code>QVariant</code> .</p> <pre><code>virtual QVariant ButtonList::process (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>The processed value </p> <p>Note:</p> <p>You will usually want to override this. In rare cases, you may want to override <code>value</code>. </p> <p>Implements ValueHandler::process</p>"},{"location":"flameshot/classButtonList/#function-representation","title":"function representation","text":"<p>Return the representation of the value in the config file. </p> <pre><code>virtual QVariant ButtonList::representation (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Override this if you want to write the value in a different format than the one provided by <code>QVariant</code>. </p> <p>Implements ValueHandler::representation</p>"},{"location":"flameshot/classButtonList/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classButtonList/#function-fromintlist","title":"function fromIntList","text":"<pre><code>static QList&lt; CaptureTool::Type &gt; ButtonList::fromIntList (\n    const QList&lt; int &gt; &amp; l\n) \n</code></pre>"},{"location":"flameshot/classButtonList/#function-normalizebuttons","title":"function normalizeButtons","text":"<pre><code>static bool ButtonList::normalizeButtons (\n    QList&lt; int &gt; &amp; buttons\n) \n</code></pre>"},{"location":"flameshot/classButtonList/#function-tointlist","title":"function toIntList","text":"<pre><code>static QList&lt; int &gt; ButtonList::toIntList (\n    const QList&lt; CaptureTool::Type &gt; &amp; l\n) \n</code></pre>"},{"location":"flameshot/classButtonListView/","title":"Class ButtonListView","text":"<p>ClassList &gt; ButtonListView</p> <p>Inherits the following classes: QListWidget</p>"},{"location":"flameshot/classButtonListView/#public-functions","title":"Public Functions","text":"Type Name ButtonListView (QWidget * parent=nullptr)"},{"location":"flameshot/classButtonListView/#protected-functions","title":"Protected Functions","text":"Type Name void initButtonList ()"},{"location":"flameshot/classButtonListView/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classButtonListView/#function-buttonlistview","title":"function ButtonListView","text":"<pre><code>explicit ButtonListView::ButtonListView (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classButtonListView/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classButtonListView/#function-initbuttonlist","title":"function initButtonList","text":"<pre><code>void ButtonListView::initButtonList () \n</code></pre>"},{"location":"flameshot/classCaptureButton/","title":"Class CaptureButton","text":"<p>ClassList &gt; CaptureButton</p> <p>Inherits the following classes: QPushButton</p> <p>Inherited by the following classes: CaptureToolButton,  OrientablePushButton</p>"},{"location":"flameshot/classCaptureButton/#public-functions","title":"Public Functions","text":"Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr)  CaptureButton (const QString &amp; text, QWidget * parent=nullptr)  CaptureButton (const QIcon &amp; icon, const QString &amp; text, QWidget * parent=nullptr)  void setColor (const QColor &amp; c)  QString styleSheet () const"},{"location":"flameshot/classCaptureButton/#public-static-functions","title":"Public Static Functions","text":"Type Name QString globalStyleSheet ()"},{"location":"flameshot/classCaptureButton/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCaptureButton/#function-capturebutton-14","title":"function CaptureButton [1/4]","text":"<pre><code>CaptureButton::CaptureButton () = delete\n</code></pre>"},{"location":"flameshot/classCaptureButton/#function-capturebutton-24","title":"function CaptureButton [2/4]","text":"<pre><code>CaptureButton::CaptureButton (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureButton/#function-capturebutton-34","title":"function CaptureButton [3/4]","text":"<pre><code>CaptureButton::CaptureButton (\n    const QString &amp; text,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureButton/#function-capturebutton-44","title":"function CaptureButton [4/4]","text":"<pre><code>CaptureButton::CaptureButton (\n    const QIcon &amp; icon,\n    const QString &amp; text,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureButton/#function-setcolor","title":"function setColor","text":"<pre><code>void CaptureButton::setColor (\n    const QColor &amp; c\n) \n</code></pre>"},{"location":"flameshot/classCaptureButton/#function-stylesheet","title":"function styleSheet","text":"<pre><code>QString CaptureButton::styleSheet () const\n</code></pre>"},{"location":"flameshot/classCaptureButton/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classCaptureButton/#function-globalstylesheet","title":"function globalStyleSheet","text":"<pre><code>static QString CaptureButton::globalStyleSheet () \n</code></pre>"},{"location":"flameshot/structCaptureContext/","title":"Struct CaptureContext","text":"<p>ClassList &gt; CaptureContext</p>"},{"location":"flameshot/structCaptureContext/#public-attributes","title":"Public Attributes","text":"Type Name int circleCount QColor color bool fullscreen QPoint mousePos QPixmap origScreenshot CaptureRequest request   = = CaptureRequest::GRAPHICAL_MODE QString savePath QPixmap screenshot QRect selection int toolSize QPoint widgetOffset"},{"location":"flameshot/structCaptureContext/#public-functions","title":"Public Functions","text":"Type Name QPixmap selectedScreenshotArea () const"},{"location":"flameshot/structCaptureContext/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/structCaptureContext/#variable-circlecount","title":"variable circleCount","text":"<pre><code>int CaptureContext::circleCount;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-color","title":"variable color","text":"<pre><code>QColor CaptureContext::color;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-fullscreen","title":"variable fullscreen","text":"<pre><code>bool CaptureContext::fullscreen;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-mousepos","title":"variable mousePos","text":"<pre><code>QPoint CaptureContext::mousePos;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-origscreenshot","title":"variable origScreenshot","text":"<pre><code>QPixmap CaptureContext::origScreenshot;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-request","title":"variable request","text":"<pre><code>CaptureRequest CaptureContext::request;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-savepath","title":"variable savePath","text":"<pre><code>QString CaptureContext::savePath;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-screenshot","title":"variable screenshot","text":"<pre><code>QPixmap CaptureContext::screenshot;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-selection","title":"variable selection","text":"<pre><code>QRect CaptureContext::selection;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-toolsize","title":"variable toolSize","text":"<pre><code>int CaptureContext::toolSize;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#variable-widgetoffset","title":"variable widgetOffset","text":"<pre><code>QPoint CaptureContext::widgetOffset;\n</code></pre>"},{"location":"flameshot/structCaptureContext/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/structCaptureContext/#function-selectedscreenshotarea","title":"function selectedScreenshotArea","text":"<pre><code>QPixmap CaptureContext::selectedScreenshotArea () const\n</code></pre>"},{"location":"flameshot/classCaptureLauncher/","title":"Class CaptureLauncher","text":"<p>ClassList &gt; CaptureLauncher</p> <p>Inherits the following classes: QDialog</p>"},{"location":"flameshot/classCaptureLauncher/#public-functions","title":"Public Functions","text":"Type Name CaptureLauncher (QDialog * parent=nullptr)  ~CaptureLauncher ()"},{"location":"flameshot/classCaptureLauncher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCaptureLauncher/#function-capturelauncher","title":"function CaptureLauncher","text":"<pre><code>explicit CaptureLauncher::CaptureLauncher (\n    QDialog * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureLauncher/#function-capturelauncher_1","title":"function ~CaptureLauncher","text":"<pre><code>CaptureLauncher::~CaptureLauncher () \n</code></pre>"},{"location":"flameshot/classCaptureRequest/","title":"Class CaptureRequest","text":"<p>ClassList &gt; CaptureRequest</p>"},{"location":"flameshot/classCaptureRequest/#public-types","title":"Public Types","text":"Type Name enum CaptureMode enum ExportTask"},{"location":"flameshot/classCaptureRequest/#public-functions","title":"Public Functions","text":"Type Name CaptureRequest (CaptureMode mode, const uint delay=0, QVariant data=QVariant(), ExportTask tasks=NO_TASK)  void addPinTask (const QRect &amp; pinWindowGeometry)  void addSaveTask (const QString &amp; path=QString())  void addTask (ExportTask task)  CaptureMode captureMode () const QVariant data () const uint delay () const uint id () const QRect initialSelection () const QString path () const void removeTask (ExportTask task)  void setInitialSelection (const QRect &amp; selection)  void setStaticID (uint id)  ExportTask tasks () const"},{"location":"flameshot/classCaptureRequest/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classCaptureRequest/#enum-capturemode","title":"enum CaptureMode","text":"<pre><code>enum CaptureRequest::CaptureMode {\n    FULLSCREEN_MODE,\n    GRAPHICAL_MODE,\n    SCREEN_MODE\n};\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#enum-exporttask","title":"enum ExportTask","text":"<pre><code>enum CaptureRequest::ExportTask {\n    NO_TASK = 0,\n    COPY = 1,\n    SAVE = 2,\n    PRINT_RAW = 4,\n    PRINT_GEOMETRY = 8,\n    PIN = 16,\n    UPLOAD = 32,\n    ACCEPT_ON_SELECT = 64\n};\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCaptureRequest/#function-capturerequest-12","title":"function CaptureRequest [1/2]","text":"<pre><code>CaptureRequest::CaptureRequest (\n    CaptureMode mode,\n    const uint delay=0,\n    QVariant data=QVariant(),\n    ExportTask tasks=NO_TASK\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-addpintask","title":"function addPinTask","text":"<pre><code>void CaptureRequest::addPinTask (\n    const QRect &amp; pinWindowGeometry\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-addsavetask","title":"function addSaveTask","text":"<pre><code>void CaptureRequest::addSaveTask (\n    const QString &amp; path=QString()\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-addtask","title":"function addTask","text":"<pre><code>void CaptureRequest::addTask (\n    ExportTask task\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-capturemode","title":"function captureMode","text":"<pre><code>CaptureMode CaptureRequest::captureMode () const\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-data","title":"function data","text":"<pre><code>QVariant CaptureRequest::data () const\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-delay","title":"function delay","text":"<pre><code>uint CaptureRequest::delay () const\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-id","title":"function id","text":"<pre><code>uint CaptureRequest::id () const\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-initialselection","title":"function initialSelection","text":"<pre><code>QRect CaptureRequest::initialSelection () const\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-path","title":"function path","text":"<pre><code>QString CaptureRequest::path () const\n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-removetask","title":"function removeTask","text":"<pre><code>void CaptureRequest::removeTask (\n    ExportTask task\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-setinitialselection","title":"function setInitialSelection","text":"<pre><code>void CaptureRequest::setInitialSelection (\n    const QRect &amp; selection\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-setstaticid","title":"function setStaticID","text":"<pre><code>void CaptureRequest::setStaticID (\n    uint id\n) \n</code></pre>"},{"location":"flameshot/classCaptureRequest/#function-tasks","title":"function tasks","text":"<pre><code>ExportTask CaptureRequest::tasks () const\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/","title":"Class CaptureToolButton","text":"<p>ClassList &gt; CaptureToolButton</p> <p>Inherits the following classes: CaptureButton</p>"},{"location":"flameshot/classCaptureToolButton/#public-functions","title":"Public Functions","text":"Type Name CaptureToolButton (const CaptureTool::Type t, QWidget * parent=nullptr)  void animatedShow ()  QString description () const QIcon icon () const QString name () const void setColor (const QColor &amp; c)  CaptureTool * tool () const ~CaptureToolButton ()"},{"location":"flameshot/classCaptureToolButton/#public-functions-inherited-from-capturebutton","title":"Public Functions inherited from CaptureButton","text":"<p>See CaptureButton</p> Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr)  CaptureButton (const QString &amp; text, QWidget * parent=nullptr)  CaptureButton (const QIcon &amp; icon, const QString &amp; text, QWidget * parent=nullptr)  void setColor (const QColor &amp; c)  QString styleSheet () const"},{"location":"flameshot/classCaptureToolButton/#public-static-functions","title":"Public Static Functions","text":"Type Name const QList&lt; CaptureTool::Type &gt; &amp; getIterableButtonTypes ()  int getPriorityByButton (CaptureTool::Type b)"},{"location":"flameshot/classCaptureToolButton/#public-static-functions-inherited-from-capturebutton","title":"Public Static Functions inherited from CaptureButton","text":"<p>See CaptureButton</p> Type Name QString globalStyleSheet ()"},{"location":"flameshot/classCaptureToolButton/#protected-attributes","title":"Protected Attributes","text":"Type Name CaptureTool * m_tool"},{"location":"flameshot/classCaptureToolButton/#protected-static-attributes","title":"Protected Static Attributes","text":"Type Name QList&lt; CaptureTool::Type &gt; iterableButtonTypes   = = { CaptureTool::TYPE_PENCIL,        CaptureTool::TYPE_DRAWER, CaptureTool::TYPE_ARROW,         CaptureTool::TYPE_SELECTION, CaptureTool::TYPE_RECTANGLE,     CaptureTool::TYPE_CIRCLE, CaptureTool::TYPE_MARKER,        CaptureTool::TYPE_TEXT, CaptureTool::TYPE_CIRCLECOUNT,   CaptureTool::TYPE_PIXELATE, CaptureTool::TYPE_MOVESELECTION, CaptureTool::TYPE_UNDO, CaptureTool::TYPE_REDO,          CaptureTool::TYPE_COPY, CaptureTool::TYPE_SAVE,          CaptureTool::TYPE_EXIT, CaptureTool::TYPE_IMAGEUPLOADER, <pre><code>CaptureTool::TYPE\\_OPEN\\_APP,\n\nCaptureTool::TYPE\\_PIN,           CaptureTool::TYPE\\_SIZEINCREASE,\nCaptureTool::TYPE\\_SIZEDECREASE,  CaptureTool::TYPE\\_ACCEPT,\n</code></pre> <p>} |</p>"},{"location":"flameshot/classCaptureToolButton/#protected-functions","title":"Protected Functions","text":"Type Name void mousePressEvent (QMouseEvent * e) override"},{"location":"flameshot/classCaptureToolButton/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCaptureToolButton/#function-capturetoolbutton-12","title":"function CaptureToolButton [1/2]","text":"<pre><code>explicit CaptureToolButton::CaptureToolButton (\n    const CaptureTool::Type t,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-animatedshow","title":"function animatedShow","text":"<pre><code>void CaptureToolButton::animatedShow () \n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-description","title":"function description","text":"<pre><code>QString CaptureToolButton::description () const\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-icon","title":"function icon","text":"<pre><code>QIcon CaptureToolButton::icon () const\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-name","title":"function name","text":"<pre><code>QString CaptureToolButton::name () const\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-setcolor","title":"function setColor","text":"<pre><code>void CaptureToolButton::setColor (\n    const QColor &amp; c\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-tool","title":"function tool","text":"<pre><code>CaptureTool * CaptureToolButton::tool () const\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-capturetoolbutton","title":"function ~CaptureToolButton","text":"<pre><code>CaptureToolButton::~CaptureToolButton () \n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classCaptureToolButton/#function-getiterablebuttontypes","title":"function getIterableButtonTypes","text":"<pre><code>static const QList&lt; CaptureTool::Type &gt; &amp; CaptureToolButton::getIterableButtonTypes () \n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#function-getprioritybybutton","title":"function getPriorityByButton","text":"<pre><code>static int CaptureToolButton::getPriorityByButton (\n    CaptureTool::Type b\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"flameshot/classCaptureToolButton/#variable-m_tool","title":"variable m_tool","text":"<pre><code>CaptureTool* CaptureToolButton::m_tool;\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#protected-static-attributes-documentation","title":"Protected Static Attributes Documentation","text":""},{"location":"flameshot/classCaptureToolButton/#variable-iterablebuttontypes","title":"variable iterableButtonTypes","text":"<pre><code>QList&lt; CaptureTool::Type &gt; CaptureToolButton::iterableButtonTypes;\n</code></pre>"},{"location":"flameshot/classCaptureToolButton/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classCaptureToolButton/#function-mousepressevent","title":"function mousePressEvent","text":"<pre><code>void CaptureToolButton::mousePressEvent (\n    QMouseEvent * e\n) override\n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/","title":"Class CaptureToolObjects","text":"<p>ClassList &gt; CaptureToolObjects</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classCaptureToolObjects/#public-functions","title":"Public Functions","text":"Type Name CaptureToolObjects (QObject * parent=nullptr)  void append (const QPointer&lt; CaptureTool &gt; &amp; captureTool)  QPointer&lt; CaptureTool &gt; at (int index)  QList&lt; QPointer&lt; CaptureTool &gt; &gt; captureToolObjects ()  void clear ()  int find (const QPoint &amp; pos, QSize captureSize)  void insert (int index, const QPointer&lt; CaptureTool &gt; &amp; captureTool)  CaptureToolObjects &amp; operator= (const CaptureToolObjects &amp; other)  void removeAt (int index)  int size ()"},{"location":"flameshot/classCaptureToolObjects/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCaptureToolObjects/#function-capturetoolobjects","title":"function CaptureToolObjects","text":"<pre><code>explicit CaptureToolObjects::CaptureToolObjects (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-append","title":"function append","text":"<pre><code>void CaptureToolObjects::append (\n    const QPointer&lt; CaptureTool &gt; &amp; captureTool\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-at","title":"function at","text":"<pre><code>QPointer&lt; CaptureTool &gt; CaptureToolObjects::at (\n    int index\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-capturetoolobjects_1","title":"function captureToolObjects","text":"<pre><code>QList&lt; QPointer&lt; CaptureTool &gt; &gt; CaptureToolObjects::captureToolObjects () \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-clear","title":"function clear","text":"<pre><code>void CaptureToolObjects::clear () \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-find","title":"function find","text":"<pre><code>int CaptureToolObjects::find (\n    const QPoint &amp; pos,\n    QSize captureSize\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-insert","title":"function insert","text":"<pre><code>void CaptureToolObjects::insert (\n    int index,\n    const QPointer&lt; CaptureTool &gt; &amp; captureTool\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-operator","title":"function operator=","text":"<pre><code>CaptureToolObjects &amp; CaptureToolObjects::operator= (\n    const CaptureToolObjects &amp; other\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-removeat","title":"function removeAt","text":"<pre><code>void CaptureToolObjects::removeAt (\n    int index\n) \n</code></pre>"},{"location":"flameshot/classCaptureToolObjects/#function-size","title":"function size","text":"<pre><code>int CaptureToolObjects::size () \n</code></pre>"},{"location":"flameshot/classCaptureWidget/","title":"Class CaptureWidget","text":"<p>ClassList &gt; CaptureWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classCaptureWidget/#public-functions","title":"Public Functions","text":"Type Name CaptureWidget (const CaptureRequest &amp; req, bool fullScreen=true, QWidget * parent=nullptr)  QPixmap pixmap ()  void removeToolObject (int index=-1)  void setCaptureToolObjects (const CaptureToolObjects &amp; captureToolObjects)  void showAppUpdateNotification (const QString &amp; appLatestVersion, const QString &amp; appLatestUrl)  void showxywh ()  ~CaptureWidget ()"},{"location":"flameshot/classCaptureWidget/#protected-functions","title":"Protected Functions","text":"Type Name void changeEvent (QEvent * changeEvent) override void keyPressEvent (QKeyEvent * keyEvent) override void keyReleaseEvent (QKeyEvent * keyEvent) override void mouseDoubleClickEvent (QMouseEvent * event) override void mouseMoveEvent (QMouseEvent * mouseEvent) override void mousePressEvent (QMouseEvent * mouseEvent) override void mouseReleaseEvent (QMouseEvent * mouseEvent) override void moveEvent (QMoveEvent * moveEvent) override void paintEvent (QPaintEvent * paintEvent) override void resizeEvent (QResizeEvent * resizeEvent) override void wheelEvent (QWheelEvent * wheelEvent) override"},{"location":"flameshot/classCaptureWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCaptureWidget/#function-capturewidget","title":"function CaptureWidget","text":"<pre><code>explicit CaptureWidget::CaptureWidget (\n    const CaptureRequest &amp; req,\n    bool fullScreen=true,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-pixmap","title":"function pixmap","text":"<pre><code>QPixmap CaptureWidget::pixmap () \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-removetoolobject","title":"function removeToolObject","text":"<pre><code>void CaptureWidget::removeToolObject (\n    int index=-1\n) \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-setcapturetoolobjects","title":"function setCaptureToolObjects","text":"<pre><code>void CaptureWidget::setCaptureToolObjects (\n    const CaptureToolObjects &amp; captureToolObjects\n) \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-showappupdatenotification","title":"function showAppUpdateNotification","text":"<pre><code>void CaptureWidget::showAppUpdateNotification (\n    const QString &amp; appLatestVersion,\n    const QString &amp; appLatestUrl\n) \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-showxywh","title":"function showxywh","text":"<pre><code>void CaptureWidget::showxywh () \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-capturewidget_1","title":"function ~CaptureWidget","text":"<pre><code>CaptureWidget::~CaptureWidget () \n</code></pre>"},{"location":"flameshot/classCaptureWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classCaptureWidget/#function-changeevent","title":"function changeEvent","text":"<pre><code>void CaptureWidget::changeEvent (\n    QEvent * changeEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-keypressevent","title":"function keyPressEvent","text":"<pre><code>void CaptureWidget::keyPressEvent (\n    QKeyEvent * keyEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-keyreleaseevent","title":"function keyReleaseEvent","text":"<pre><code>void CaptureWidget::keyReleaseEvent (\n    QKeyEvent * keyEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-mousedoubleclickevent","title":"function mouseDoubleClickEvent","text":"<pre><code>void CaptureWidget::mouseDoubleClickEvent (\n    QMouseEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-mousemoveevent","title":"function mouseMoveEvent","text":"<pre><code>void CaptureWidget::mouseMoveEvent (\n    QMouseEvent * mouseEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-mousepressevent","title":"function mousePressEvent","text":"<pre><code>void CaptureWidget::mousePressEvent (\n    QMouseEvent * mouseEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-mousereleaseevent","title":"function mouseReleaseEvent","text":"<pre><code>void CaptureWidget::mouseReleaseEvent (\n    QMouseEvent * mouseEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-moveevent","title":"function moveEvent","text":"<pre><code>void CaptureWidget::moveEvent (\n    QMoveEvent * moveEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-paintevent","title":"function paintEvent","text":"<pre><code>void CaptureWidget::paintEvent (\n    QPaintEvent * paintEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void CaptureWidget::resizeEvent (\n    QResizeEvent * resizeEvent\n) override\n</code></pre>"},{"location":"flameshot/classCaptureWidget/#function-wheelevent","title":"function wheelEvent","text":"<pre><code>void CaptureWidget::wheelEvent (\n    QWheelEvent * wheelEvent\n) override\n</code></pre>"},{"location":"flameshot/classCircleCountTool/","title":"Class CircleCountTool","text":"<p>ClassList &gt; CircleCountTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classCircleCountTool/#public-functions","title":"Public Functions","text":"Type Name CircleCountTool (QObject * parent=nullptr)  QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString info () override bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const QString name () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classCircleCountTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classCircleCountTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classCircleCountTool/#protected-functions","title":"Protected Functions","text":"Type Name void copyParams (const CircleCountTool * from, CircleCountTool * to)  CaptureTool::Type type () override const"},{"location":"flameshot/classCircleCountTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classCircleCountTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCircleCountTool/#function-circlecounttool","title":"function CircleCountTool","text":"<pre><code>explicit CircleCountTool::CircleCountTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect CircleCountTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * CircleCountTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-description","title":"function description","text":"<pre><code>QString CircleCountTool::description () override const\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-icon","title":"function icon","text":"<pre><code>QIcon CircleCountTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-info","title":"function info","text":"<pre><code>QString CircleCountTool::info () override\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-isvalid","title":"function isValid","text":"<pre><code>bool CircleCountTool::isValid () override const\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-mousepreviewrect","title":"function mousePreviewRect","text":"<pre><code>QRect CircleCountTool::mousePreviewRect (\n    const CaptureContext &amp; context\n) override const\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-name","title":"function name","text":"<pre><code>QString CircleCountTool::name () override const\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void CircleCountTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-process","title":"function process","text":"<pre><code>void CircleCountTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classCircleCountTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classCircleCountTool/#function-copyparams","title":"function copyParams","text":"<pre><code>void CircleCountTool::copyParams (\n    const CircleCountTool * from,\n    CircleCountTool * to\n) \n</code></pre>"},{"location":"flameshot/classCircleCountTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type CircleCountTool::type () override const\n</code></pre>"},{"location":"flameshot/classCircleTool/","title":"Class CircleTool","text":"<p>ClassList &gt; CircleTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classCircleTool/#public-functions","title":"Public Functions","text":"Type Name CircleTool (QObject * parent=nullptr)  CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classCircleTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classCircleTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classCircleTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classCircleTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classCircleTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCircleTool/#function-circletool","title":"function CircleTool","text":"<pre><code>explicit CircleTool::CircleTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCircleTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * CircleTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classCircleTool/#function-description","title":"function description","text":"<pre><code>QString CircleTool::description () override const\n</code></pre>"},{"location":"flameshot/classCircleTool/#function-icon","title":"function icon","text":"<pre><code>QIcon CircleTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classCircleTool/#function-name","title":"function name","text":"<pre><code>QString CircleTool::name () override const\n</code></pre>"},{"location":"flameshot/classCircleTool/#function-process","title":"function process","text":"<pre><code>void CircleTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classCircleTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classCircleTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type CircleTool::type () override const\n</code></pre>"},{"location":"flameshot/classClickableLabel/","title":"Class ClickableLabel","text":"<p>ClassList &gt; ClickableLabel</p> <p>Inherits the following classes: QLabel</p>"},{"location":"flameshot/classClickableLabel/#public-functions","title":"Public Functions","text":"Type Name ClickableLabel (QWidget * parent=nullptr)  ClickableLabel (const QString &amp; s, QWidget * parent=nullptr)"},{"location":"flameshot/classClickableLabel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classClickableLabel/#function-clickablelabel-12","title":"function ClickableLabel [1/2]","text":"<pre><code>explicit ClickableLabel::ClickableLabel (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classClickableLabel/#function-clickablelabel-22","title":"function ClickableLabel [2/2]","text":"<pre><code>ClickableLabel::ClickableLabel (\n    const QString &amp; s,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classColor/","title":"Class Color","text":"<p>ClassList &gt; Color</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classColor/#public-functions","title":"Public Functions","text":"Type Name Color (QColor def)  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value). virtual QVariant process (const QVariant &amp; val) overrideProcess a value, presuming it is a valid <code>QVariant</code> . virtual QVariant representation (const QVariant &amp; val) overrideReturn the representation of the value in the config file."},{"location":"flameshot/classColor/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classColor/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classColor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classColor/#function-color","title":"function Color","text":"<pre><code>Color::Color (\n    QColor def\n) \n</code></pre>"},{"location":"flameshot/classColor/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool Color::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classColor/#function-expected","title":"function expected","text":"<pre><code>virtual QString Color::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classColor/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant Color::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classColor/#function-process","title":"function process","text":"<p>Process a value, presuming it is a valid <code>QVariant</code> .</p> <pre><code>virtual QVariant Color::process (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>The processed value </p> <p>Note:</p> <p>You will usually want to override this. In rare cases, you may want to override <code>value</code>. </p> <p>Implements ValueHandler::process</p>"},{"location":"flameshot/classColor/#function-representation","title":"function representation","text":"<p>Return the representation of the value in the config file. </p> <pre><code>virtual QVariant Color::representation (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Override this if you want to write the value in a different format than the one provided by <code>QVariant</code>. </p> <p>Implements ValueHandler::representation</p>"},{"location":"flameshot/classColorGrabWidget/","title":"Class ColorGrabWidget","text":"<p>ClassList &gt; ColorGrabWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classColorGrabWidget/#public-functions","title":"Public Functions","text":"Type Name ColorGrabWidget (QPixmap * p, QWidget * parent=nullptr)  QColor color ()  void startGrabbing ()"},{"location":"flameshot/classColorGrabWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classColorGrabWidget/#function-colorgrabwidget","title":"function ColorGrabWidget","text":"<pre><code>ColorGrabWidget::ColorGrabWidget (\n    QPixmap * p,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classColorGrabWidget/#function-color","title":"function color","text":"<pre><code>QColor ColorGrabWidget::color () \n</code></pre>"},{"location":"flameshot/classColorGrabWidget/#function-startgrabbing","title":"function startGrabbing","text":"<pre><code>void ColorGrabWidget::startGrabbing () \n</code></pre>"},{"location":"flameshot/classColorPicker/","title":"Class ColorPicker","text":"<p>ClassList &gt; ColorPicker</p> <p>Inherits the following classes: ColorPickerWidget</p>"},{"location":"flameshot/classColorPicker/#public-functions","title":"Public Functions","text":"Type Name ColorPicker (QWidget * parent=nullptr)"},{"location":"flameshot/classColorPicker/#public-functions-inherited-from-colorpickerwidget","title":"Public Functions inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name ColorPickerWidget (QWidget * parent=nullptr)  void updateSelection (int index)  void updateWidget ()"},{"location":"flameshot/classColorPicker/#public-static-functions-inherited-from-colorpickerwidget","title":"Public Static Functions inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name const QVector&lt; QColor &gt; &amp; getDefaultLargeColorPalette ()  const QVector&lt; QColor &gt; &amp; getDefaultSmallColorPalette ()"},{"location":"flameshot/classColorPicker/#protected-attributes-inherited-from-colorpickerwidget","title":"Protected Attributes inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name QVector&lt; QRect &gt; m_colorAreaList int m_colorAreaSize QVector&lt; QColor &gt; m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor"},{"location":"flameshot/classColorPicker/#protected-functions","title":"Protected Functions","text":"Type Name void hideEvent (QHideEvent * event) override void mouseMoveEvent (QMouseEvent * e) override void showEvent (QShowEvent * event) override"},{"location":"flameshot/classColorPicker/#protected-functions-inherited-from-colorpickerwidget","title":"Protected Functions inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter &amp; painter)"},{"location":"flameshot/classColorPicker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classColorPicker/#function-colorpicker","title":"function ColorPicker","text":"<pre><code>explicit ColorPicker::ColorPicker (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classColorPicker/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classColorPicker/#function-hideevent","title":"function hideEvent","text":"<pre><code>void ColorPicker::hideEvent (\n    QHideEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classColorPicker/#function-mousemoveevent","title":"function mouseMoveEvent","text":"<pre><code>void ColorPicker::mouseMoveEvent (\n    QMouseEvent * e\n) override\n</code></pre>"},{"location":"flameshot/classColorPicker/#function-showevent","title":"function showEvent","text":"<pre><code>void ColorPicker::showEvent (\n    QShowEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classColorPickerEditMode/","title":"Class ColorPickerEditMode","text":"<p>ClassList &gt; ColorPickerEditMode</p> <p>Inherits the following classes: ColorPickerWidget</p>"},{"location":"flameshot/classColorPickerEditMode/#public-functions","title":"Public Functions","text":"Type Name ColorPickerEditMode (QWidget * parent=nullptr)"},{"location":"flameshot/classColorPickerEditMode/#public-functions-inherited-from-colorpickerwidget","title":"Public Functions inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name ColorPickerWidget (QWidget * parent=nullptr)  void updateSelection (int index)  void updateWidget ()"},{"location":"flameshot/classColorPickerEditMode/#public-static-functions-inherited-from-colorpickerwidget","title":"Public Static Functions inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name const QVector&lt; QColor &gt; &amp; getDefaultLargeColorPalette ()  const QVector&lt; QColor &gt; &amp; getDefaultSmallColorPalette ()"},{"location":"flameshot/classColorPickerEditMode/#protected-attributes-inherited-from-colorpickerwidget","title":"Protected Attributes inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name QVector&lt; QRect &gt; m_colorAreaList int m_colorAreaSize QVector&lt; QColor &gt; m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor"},{"location":"flameshot/classColorPickerEditMode/#protected-functions-inherited-from-colorpickerwidget","title":"Protected Functions inherited from ColorPickerWidget","text":"<p>See ColorPickerWidget</p> Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter &amp; painter)"},{"location":"flameshot/classColorPickerEditMode/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classColorPickerEditMode/#function-colorpickereditmode","title":"function ColorPickerEditMode","text":"<pre><code>explicit ColorPickerEditMode::ColorPickerEditMode (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classColorPickerEditor/","title":"Class ColorPickerEditor","text":"<p>ClassList &gt; ColorPickerEditor</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classColorPickerEditor/#public-functions","title":"Public Functions","text":"Type Name ColorPickerEditor (QWidget * parent=nullptr)"},{"location":"flameshot/classColorPickerEditor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classColorPickerEditor/#function-colorpickereditor","title":"function ColorPickerEditor","text":"<pre><code>explicit ColorPickerEditor::ColorPickerEditor (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classColorPickerWidget/","title":"Class ColorPickerWidget","text":"<p>ClassList &gt; ColorPickerWidget</p> <p>Inherits the following classes: QWidget</p> <p>Inherited by the following classes: ColorPicker,  ColorPickerEditMode</p>"},{"location":"flameshot/classColorPickerWidget/#public-functions","title":"Public Functions","text":"Type Name ColorPickerWidget (QWidget * parent=nullptr)  void updateSelection (int index)  void updateWidget ()"},{"location":"flameshot/classColorPickerWidget/#public-static-functions","title":"Public Static Functions","text":"Type Name const QVector&lt; QColor &gt; &amp; getDefaultLargeColorPalette ()  const QVector&lt; QColor &gt; &amp; getDefaultSmallColorPalette ()"},{"location":"flameshot/classColorPickerWidget/#protected-attributes","title":"Protected Attributes","text":"Type Name QVector&lt; QRect &gt; m_colorAreaList int m_colorAreaSize QVector&lt; QColor &gt; m_colorList int m_lastIndex int m_selectedIndex QColor m_uiColor"},{"location":"flameshot/classColorPickerWidget/#protected-functions","title":"Protected Functions","text":"Type Name void paintEvent (QPaintEvent * event) override void repaint (int i, QPainter &amp; painter)"},{"location":"flameshot/classColorPickerWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classColorPickerWidget/#function-colorpickerwidget","title":"function ColorPickerWidget","text":"<pre><code>explicit ColorPickerWidget::ColorPickerWidget (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#function-updateselection","title":"function updateSelection","text":"<pre><code>void ColorPickerWidget::updateSelection (\n    int index\n) \n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#function-updatewidget","title":"function updateWidget","text":"<pre><code>void ColorPickerWidget::updateWidget () \n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classColorPickerWidget/#function-getdefaultlargecolorpalette","title":"function getDefaultLargeColorPalette","text":"<pre><code>static const QVector&lt; QColor &gt; &amp; ColorPickerWidget::getDefaultLargeColorPalette () \n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#function-getdefaultsmallcolorpalette","title":"function getDefaultSmallColorPalette","text":"<pre><code>static const QVector&lt; QColor &gt; &amp; ColorPickerWidget::getDefaultSmallColorPalette () \n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"flameshot/classColorPickerWidget/#variable-m_colorarealist","title":"variable m_colorAreaList","text":"<pre><code>QVector&lt;QRect&gt; ColorPickerWidget::m_colorAreaList;\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#variable-m_colorareasize","title":"variable m_colorAreaSize","text":"<pre><code>int ColorPickerWidget::m_colorAreaSize;\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#variable-m_colorlist","title":"variable m_colorList","text":"<pre><code>QVector&lt;QColor&gt; ColorPickerWidget::m_colorList;\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#variable-m_lastindex","title":"variable m_lastIndex","text":"<pre><code>int ColorPickerWidget::m_lastIndex;\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#variable-m_selectedindex","title":"variable m_selectedIndex","text":"<pre><code>int ColorPickerWidget::m_selectedIndex;\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#variable-m_uicolor","title":"variable m_uiColor","text":"<pre><code>QColor ColorPickerWidget::m_uiColor;\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classColorPickerWidget/#function-paintevent","title":"function paintEvent","text":"<pre><code>void ColorPickerWidget::paintEvent (\n    QPaintEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classColorPickerWidget/#function-repaint","title":"function repaint","text":"<pre><code>void ColorPickerWidget::repaint (\n    int i,\n    QPainter &amp; painter\n) \n</code></pre>"},{"location":"flameshot/namespaceColorUtils/","title":"Namespace ColorUtils","text":"<p>Namespace List &gt; ColorUtils</p>"},{"location":"flameshot/namespaceColorUtils/#public-functions","title":"Public Functions","text":"Type Name bool colorIsDark (const QColor &amp; c)  QColor contrastColor (const QColor &amp; c)"},{"location":"flameshot/namespaceColorUtils/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/namespaceColorUtils/#function-colorisdark","title":"function colorIsDark","text":"<pre><code>bool ColorUtils::colorIsDark (\n    const QColor &amp; c\n) \n</code></pre>"},{"location":"flameshot/namespaceColorUtils/#function-contrastcolor","title":"function contrastColor","text":"<pre><code>QColor ColorUtils::contrastColor (\n    const QColor &amp; c\n) \n</code></pre>"},{"location":"flameshot/classCommandArgument/","title":"Class CommandArgument","text":"<p>ClassList &gt; CommandArgument</p>"},{"location":"flameshot/classCommandArgument/#public-functions","title":"Public Functions","text":"Type Name CommandArgument ()  CommandArgument (QString name, QString description)  QString description () const bool isRoot () const QString name () const bool operator== (const CommandArgument &amp; arg) const void setDescription (const QString &amp; description)  void setName (const QString &amp; name)"},{"location":"flameshot/classCommandArgument/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCommandArgument/#function-commandargument-12","title":"function CommandArgument [1/2]","text":"<pre><code>CommandArgument::CommandArgument () \n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-commandargument-22","title":"function CommandArgument [2/2]","text":"<pre><code>explicit CommandArgument::CommandArgument (\n    QString name,\n    QString description\n) \n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-description","title":"function description","text":"<pre><code>QString CommandArgument::description () const\n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-isroot","title":"function isRoot","text":"<pre><code>bool CommandArgument::isRoot () const\n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-name","title":"function name","text":"<pre><code>QString CommandArgument::name () const\n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-operator","title":"function operator==","text":"<pre><code>bool CommandArgument::operator== (\n    const CommandArgument &amp; arg\n) const\n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-setdescription","title":"function setDescription","text":"<pre><code>void CommandArgument::setDescription (\n    const QString &amp; description\n) \n</code></pre>"},{"location":"flameshot/classCommandArgument/#function-setname","title":"function setName","text":"<pre><code>void CommandArgument::setName (\n    const QString &amp; name\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/","title":"Class CommandLineParser","text":"<p>ClassList &gt; CommandLineParser</p>"},{"location":"flameshot/classCommandLineParser/#public-functions","title":"Public Functions","text":"Type Name bool AddArgument (const CommandArgument &amp; arg, const CommandArgument &amp; parent=CommandArgument())  bool AddOption (const CommandOption &amp; option, const CommandArgument &amp; parent=CommandArgument())  bool AddOptions (const QList&lt; CommandOption &gt; &amp; options, const CommandArgument &amp; parent=CommandArgument())  CommandLineParser ()  CommandOption addHelpOption ()  CommandOption addVersionOption ()  bool isSet (const CommandArgument &amp; arg) const bool isSet (const CommandOption &amp; option) const bool parse (const QStringList &amp; args)  CommandArgument rootArgument () const void setDescription (const QString &amp; description)  void setGeneralErrorMessage (const QString &amp; msg)  QString value (const CommandOption &amp; option) const"},{"location":"flameshot/classCommandLineParser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCommandLineParser/#function-addargument","title":"function AddArgument","text":"<pre><code>bool CommandLineParser::AddArgument (\n    const CommandArgument &amp; arg,\n    const CommandArgument &amp; parent=CommandArgument ()\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-addoption","title":"function AddOption","text":"<pre><code>bool CommandLineParser::AddOption (\n    const CommandOption &amp; option,\n    const CommandArgument &amp; parent=CommandArgument ()\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-addoptions","title":"function AddOptions","text":"<pre><code>bool CommandLineParser::AddOptions (\n    const QList&lt; CommandOption &gt; &amp; options,\n    const CommandArgument &amp; parent=CommandArgument ()\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-commandlineparser","title":"function CommandLineParser","text":"<pre><code>CommandLineParser::CommandLineParser () \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-addhelpoption","title":"function addHelpOption","text":"<pre><code>CommandOption CommandLineParser::addHelpOption () \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-addversionoption","title":"function addVersionOption","text":"<pre><code>CommandOption CommandLineParser::addVersionOption () \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-isset-12","title":"function isSet [1/2]","text":"<pre><code>bool CommandLineParser::isSet (\n    const CommandArgument &amp; arg\n) const\n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-isset-22","title":"function isSet [2/2]","text":"<pre><code>bool CommandLineParser::isSet (\n    const CommandOption &amp; option\n) const\n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-parse","title":"function parse","text":"<pre><code>bool CommandLineParser::parse (\n    const QStringList &amp; args\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-rootargument","title":"function rootArgument","text":"<pre><code>inline CommandArgument CommandLineParser::rootArgument () const\n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-setdescription","title":"function setDescription","text":"<pre><code>void CommandLineParser::setDescription (\n    const QString &amp; description\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-setgeneralerrormessage","title":"function setGeneralErrorMessage","text":"<pre><code>void CommandLineParser::setGeneralErrorMessage (\n    const QString &amp; msg\n) \n</code></pre>"},{"location":"flameshot/classCommandLineParser/#function-value","title":"function value","text":"<pre><code>QString CommandLineParser::value (\n    const CommandOption &amp; option\n) const\n</code></pre>"},{"location":"flameshot/structCommandLineParser_1_1Node/","title":"Struct CommandLineParser::Node","text":"<p>ClassList &gt; Node</p>"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-attributes","title":"Public Attributes","text":"Type Name CommandArgument argument QList&lt; CommandOption &gt; options QList&lt; Node &gt; subNodes"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-functions","title":"Public Functions","text":"Type Name Node (const CommandArgument &amp; arg)  Node ()  bool operator== (const Node &amp; n) const"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/structCommandLineParser_1_1Node/#variable-argument","title":"variable argument","text":"<pre><code>CommandArgument CommandLineParser::Node::argument;\n</code></pre>"},{"location":"flameshot/structCommandLineParser_1_1Node/#variable-options","title":"variable options","text":"<pre><code>QList&lt;CommandOption&gt; CommandLineParser::Node::options;\n</code></pre>"},{"location":"flameshot/structCommandLineParser_1_1Node/#variable-subnodes","title":"variable subNodes","text":"<pre><code>QList&lt;Node&gt; CommandLineParser::Node::subNodes;\n</code></pre>"},{"location":"flameshot/structCommandLineParser_1_1Node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/structCommandLineParser_1_1Node/#function-node-12","title":"function Node [1/2]","text":"<pre><code>inline explicit Node::Node (\n    const CommandArgument &amp; arg\n) \n</code></pre>"},{"location":"flameshot/structCommandLineParser_1_1Node/#function-node-22","title":"function Node [2/2]","text":"<pre><code>inline Node::Node () \n</code></pre>"},{"location":"flameshot/structCommandLineParser_1_1Node/#function-operator","title":"function operator==","text":"<pre><code>inline bool Node::operator== (\n    const Node &amp; n\n) const\n</code></pre>"},{"location":"flameshot/classCommandOption/","title":"Class CommandOption","text":"<p>ClassList &gt; CommandOption</p>"},{"location":"flameshot/classCommandOption/#public-functions","title":"Public Functions","text":"Type Name CommandOption (const QString &amp; name, QString description, QString valueName=QString(), QString defaultValue=QString())  CommandOption (QStringList names, QString description, QString valueName=QString(), QString defaultValue=QString())  void addChecker (const function&lt; bool(QString const &amp;)&gt; checker, const QString &amp; errMsg)  bool checkValue (const QString &amp; value) const QStringList dashedNames () const QString description () const QString errorMsg () const QStringList names () const bool operator== (const CommandOption &amp; option) const void setDescription (const QString &amp; description)  void setName (const QString &amp; name)  void setNames (const QStringList &amp; names)  void setValue (const QString &amp; value)  void setValueName (const QString &amp; name)  QString value () const QString valueName () const"},{"location":"flameshot/classCommandOption/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCommandOption/#function-commandoption-12","title":"function CommandOption [1/2]","text":"<pre><code>CommandOption::CommandOption (\n    const QString &amp; name,\n    QString description,\n    QString valueName=QString(),\n    QString defaultValue=QString()\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-commandoption-22","title":"function CommandOption [2/2]","text":"<pre><code>CommandOption::CommandOption (\n    QStringList names,\n    QString description,\n    QString valueName=QString(),\n    QString defaultValue=QString()\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-addchecker","title":"function addChecker","text":"<pre><code>void CommandOption::addChecker (\n    const function&lt; bool(QString const &amp;)&gt; checker,\n    const QString &amp; errMsg\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-checkvalue","title":"function checkValue","text":"<pre><code>bool CommandOption::checkValue (\n    const QString &amp; value\n) const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-dashednames","title":"function dashedNames","text":"<pre><code>QStringList CommandOption::dashedNames () const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-description","title":"function description","text":"<pre><code>QString CommandOption::description () const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-errormsg","title":"function errorMsg","text":"<pre><code>QString CommandOption::errorMsg () const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-names","title":"function names","text":"<pre><code>QStringList CommandOption::names () const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-operator","title":"function operator==","text":"<pre><code>bool CommandOption::operator== (\n    const CommandOption &amp; option\n) const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-setdescription","title":"function setDescription","text":"<pre><code>void CommandOption::setDescription (\n    const QString &amp; description\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-setname","title":"function setName","text":"<pre><code>void CommandOption::setName (\n    const QString &amp; name\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-setnames","title":"function setNames","text":"<pre><code>void CommandOption::setNames (\n    const QStringList &amp; names\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-setvalue","title":"function setValue","text":"<pre><code>void CommandOption::setValue (\n    const QString &amp; value\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-setvaluename","title":"function setValueName","text":"<pre><code>void CommandOption::setValueName (\n    const QString &amp; name\n) \n</code></pre>"},{"location":"flameshot/classCommandOption/#function-value","title":"function value","text":"<pre><code>QString CommandOption::value () const\n</code></pre>"},{"location":"flameshot/classCommandOption/#function-valuename","title":"function valueName","text":"<pre><code>QString CommandOption::valueName () const\n</code></pre>"},{"location":"flameshot/structCompareAppByName/","title":"Struct CompareAppByName","text":"<p>ClassList &gt; CompareAppByName</p>"},{"location":"flameshot/structCompareAppByName/#public-functions","title":"Public Functions","text":"Type Name bool operator() (const DesktopAppData a, const DesktopAppData b)"},{"location":"flameshot/structCompareAppByName/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/structCompareAppByName/#function-operator","title":"function operator()","text":"<pre><code>inline bool CompareAppByName::operator() (\n    const DesktopAppData a,\n    const DesktopAppData b\n) \n</code></pre>"},{"location":"flameshot/classConfigErrorDetails/","title":"Class ConfigErrorDetails","text":"<p>ClassList &gt; ConfigErrorDetails</p> <p>Inherits the following classes: QDialog</p>"},{"location":"flameshot/classConfigErrorDetails/#public-functions","title":"Public Functions","text":"Type Name ConfigErrorDetails (QWidget * parent=nullptr)"},{"location":"flameshot/classConfigErrorDetails/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classConfigErrorDetails/#function-configerrordetails","title":"function ConfigErrorDetails","text":"<pre><code>ConfigErrorDetails::ConfigErrorDetails (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/","title":"Class ConfigHandler","text":"<p>ClassList &gt; ConfigHandler</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classConfigHandler/#public-attributes","title":"Public Attributes","text":"Type Name setShowDesktopNotification bool setShowStartupLaunchMessage bool bool setUploadWithoutConfirmation bool bool bool showSelectionGeometryHideTime"},{"location":"flameshot/classConfigHandler/#public-functions","title":"Public Functions","text":"Type Name CONFIG_GETTER_SETTER (userColors, setUserColors, QVector&lt; QColor &gt;)  CONFIG_GETTER_SETTER (predefinedColorPaletteLarge, setPredefinedColorPaletteLarge, bool)  bool CONFIG_GETTER_SETTER (allowMultipleGuiInstances, setAllowMultipleGuiInstances, bool)  bool bool CONFIG_GETTER_SETTER (historyConfirmationToDelete, setHistoryConfirmationToDelete, bool)  bool bool bool CONFIG_GETTER_SETTER (ignoreUpdateToVersion, setIgnoreUpdateToVersion, QString)  ConfigHandler ()  void checkAndHandleError () constParse the configuration to find any errors in it. bool checkForErrors (AbstractLogger * log=nullptr) const bool checkSemantics (AbstractLogger * log=nullptr, QList&lt; QString &gt; * offenders=nullptr) constCheck each config value semantically. bool checkShortcutConflicts (AbstractLogger * log=nullptr) constCheck if there are multiple actions with the same shortcut. bool checkUnrecognizedSettings (AbstractLogger * log=nullptr, QList&lt; QString &gt; * offenders=nullptr) constParse the config to find settings with unrecognized names. QString configFilePath () const QString errorMessage () constError message that can be used by other classes as well. QString filenamePatternDefault ()  bool hasError () constReturn if the config contains an error. QSet&lt; QString &gt; keysFromGroup (const QString &amp; group) constReturn keys from group <code>group</code> . Use CONFIG_GROUP_GENERAL (General) for general settings. void remove (const QString &amp; key)  void resetValue (const QString &amp; key)  void setAllTheButtons ()  void setDefaultSettings ()  void setErrorState (bool error) constUpdate the tracked error state of the config. bool setShortcut (const QString &amp; actionName, const QString &amp; shortcut)  void setStartupLaunch (const bool start)  void setToolSize (CaptureTool::Type toolType, int size)  void setValue (const QString &amp; key, const QVariant &amp; value)  QString shortcut (const QString &amp; actionName)  bool bool bool int bool startupLaunch ()  int toolSize (CaptureTool::Type toolType)  QVariant value (const QString &amp; key) const"},{"location":"flameshot/classConfigHandler/#public-static-functions","title":"Public Static Functions","text":"Type Name ConfigHandler * getInstance () Serves as an object to which slots can be connected. QSet&lt; QString &gt; &amp; recognizedGeneralOptions ()  QSet&lt; QString &gt; &amp; recognizedShortcutNames ()"},{"location":"flameshot/classConfigHandler/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/classConfigHandler/#variable-setshowdesktopnotification","title":"variable setShowDesktopNotification","text":"<pre><code>ConfigHandler::setShowDesktopNotification;\n</code></pre>"},{"location":"flameshot/classConfigHandler/#variable-setshowstartuplaunchmessage","title":"variable setShowStartupLaunchMessage","text":"<pre><code>bool ConfigHandler::setShowStartupLaunchMessage;\n</code></pre>"},{"location":"flameshot/classConfigHandler/#variable-setuploadwithoutconfirmation","title":"variable setUploadWithoutConfirmation","text":"<pre><code>bool bool ConfigHandler::setUploadWithoutConfirmation;\n</code></pre>"},{"location":"flameshot/classConfigHandler/#variable-showselectiongeometryhidetime","title":"variable showSelectionGeometryHideTime","text":"<pre><code>bool bool bool ConfigHandler::showSelectionGeometryHideTime;\n</code></pre>"},{"location":"flameshot/classConfigHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-15","title":"function CONFIG_GETTER_SETTER [1/5]","text":"<pre><code>ConfigHandler::CONFIG_GETTER_SETTER (\n    userColors,\n    setUserColors,\n    QVector&lt; QColor &gt;\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-25","title":"function CONFIG_GETTER_SETTER [2/5]","text":"<pre><code>ConfigHandler::CONFIG_GETTER_SETTER (\n    predefinedColorPaletteLarge,\n    setPredefinedColorPaletteLarge,\n    bool\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-35","title":"function CONFIG_GETTER_SETTER [3/5]","text":"<pre><code>bool ConfigHandler::CONFIG_GETTER_SETTER (\n    allowMultipleGuiInstances,\n    setAllowMultipleGuiInstances,\n    bool\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-45","title":"function CONFIG_GETTER_SETTER [4/5]","text":"<pre><code>bool bool ConfigHandler::CONFIG_GETTER_SETTER (\n    historyConfirmationToDelete,\n    setHistoryConfirmationToDelete,\n    bool\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-config_getter_setter-55","title":"function CONFIG_GETTER_SETTER [5/5]","text":"<pre><code>bool bool bool ConfigHandler::CONFIG_GETTER_SETTER (\n    ignoreUpdateToVersion,\n    setIgnoreUpdateToVersion,\n    QString\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-confighandler","title":"function ConfigHandler","text":"<pre><code>explicit ConfigHandler::ConfigHandler () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-checkandhandleerror","title":"function checkAndHandleError","text":"<p>Parse the configuration to find any errors in it. </p> <pre><code>void ConfigHandler::checkAndHandleError () const\n</code></pre> <p>If the error state changes as a result of the check, it will perform the appropriate action, e.g. notify the user.</p> <p>See also: ConfigHandler::setErrorState for all the actions. </p>"},{"location":"flameshot/classConfigHandler/#function-checkforerrors","title":"function checkForErrors","text":"<pre><code>bool ConfigHandler::checkForErrors (\n    AbstractLogger * log=nullptr\n) const\n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-checksemantics","title":"function checkSemantics","text":"<p>Check each config value semantically. </p> <pre><code>bool ConfigHandler::checkSemantics (\n    AbstractLogger * log=nullptr,\n    QList&lt; QString &gt; * offenders=nullptr\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>log</code> Destination for error log output. </li> <li><code>offenders</code> Destination for the semantically invalid keys. </li> </ul> <p>Returns:</p> <p>Whether the config passes this check. </p>"},{"location":"flameshot/classConfigHandler/#function-checkshortcutconflicts","title":"function checkShortcutConflicts","text":"<p>Check if there are multiple actions with the same shortcut. </p> <pre><code>bool ConfigHandler::checkShortcutConflicts (\n    AbstractLogger * log=nullptr\n) const\n</code></pre> <p>Returns:</p> <p>Whether the config passes this check.</p> <p>Note:</p> <p>It is not considered a conflict if action A uses shortcut S because it is the flameshot default (not because the user explicitly configured it), and action B uses the same shortcut. </p>"},{"location":"flameshot/classConfigHandler/#function-checkunrecognizedsettings","title":"function checkUnrecognizedSettings","text":"<p>Parse the config to find settings with unrecognized names. </p> <pre><code>bool ConfigHandler::checkUnrecognizedSettings (\n    AbstractLogger * log=nullptr,\n    QList&lt; QString &gt; * offenders=nullptr\n) const\n</code></pre> <p>Returns:</p> <p>Whether the config passes this check.</p> <p>Note:</p> <p>An unrecognized option is one that is not included in <code>recognizedGeneralOptions</code> or <code>recognizedShortcutNames</code> depending on the group the option belongs to. </p>"},{"location":"flameshot/classConfigHandler/#function-configfilepath","title":"function configFilePath","text":"<pre><code>QString ConfigHandler::configFilePath () const\n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-errormessage","title":"function errorMessage","text":"<pre><code>QString ConfigHandler::errorMessage () const\n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-filenamepatterndefault","title":"function filenamePatternDefault","text":"<pre><code>QString ConfigHandler::filenamePatternDefault () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-haserror","title":"function hasError","text":"<p>Return if the config contains an error. </p> <pre><code>bool ConfigHandler::hasError () const\n</code></pre> <p>If an error check is due, it will be performed. </p>"},{"location":"flameshot/classConfigHandler/#function-keysfromgroup","title":"function keysFromGroup","text":"<pre><code>QSet&lt; QString &gt; ConfigHandler::keysFromGroup (\n    const QString &amp; group\n) const\n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-remove","title":"function remove","text":"<pre><code>void ConfigHandler::remove (\n    const QString &amp; key\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-resetvalue","title":"function resetValue","text":"<pre><code>void ConfigHandler::resetValue (\n    const QString &amp; key\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-setallthebuttons","title":"function setAllTheButtons","text":"<pre><code>void ConfigHandler::setAllTheButtons () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-setdefaultsettings","title":"function setDefaultSettings","text":"<pre><code>void ConfigHandler::setDefaultSettings () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-seterrorstate","title":"function setErrorState","text":"<p>Update the tracked error state of the config. </p> <pre><code>void ConfigHandler::setErrorState (\n    bool error\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>error</code> The new error state.</li> </ul> <p>The error state is tracked so that signals are not emitted and the user is not spammed every time the config file changes. Instead, only changes in error state get reported. </p>"},{"location":"flameshot/classConfigHandler/#function-setshortcut","title":"function setShortcut","text":"<pre><code>bool ConfigHandler::setShortcut (\n    const QString &amp; actionName,\n    const QString &amp; shortcut\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-setstartuplaunch","title":"function setStartupLaunch","text":"<pre><code>void ConfigHandler::setStartupLaunch (\n    const bool start\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-settoolsize","title":"function setToolSize","text":"<pre><code>void ConfigHandler::setToolSize (\n    CaptureTool::Type toolType,\n    int size\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-setvalue","title":"function setValue","text":"<pre><code>void ConfigHandler::setValue (\n    const QString &amp; key,\n    const QVariant &amp; value\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-shortcut","title":"function shortcut","text":"<pre><code>QString ConfigHandler::shortcut (\n    const QString &amp; actionName\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-startuplaunch","title":"function startupLaunch","text":"<pre><code>bool bool bool int bool ConfigHandler::startupLaunch () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-toolsize","title":"function toolSize","text":"<pre><code>int ConfigHandler::toolSize (\n    CaptureTool::Type toolType\n) \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-value","title":"function value","text":"<pre><code>QVariant ConfigHandler::value (\n    const QString &amp; key\n) const\n</code></pre>"},{"location":"flameshot/classConfigHandler/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classConfigHandler/#function-getinstance","title":"function getInstance","text":"<pre><code>static ConfigHandler * ConfigHandler::getInstance () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-recognizedgeneraloptions","title":"function recognizedGeneralOptions","text":"<pre><code>static QSet&lt; QString &gt; &amp; ConfigHandler::recognizedGeneralOptions () \n</code></pre>"},{"location":"flameshot/classConfigHandler/#function-recognizedshortcutnames","title":"function recognizedShortcutNames","text":"<pre><code>static QSet&lt; QString &gt; &amp; ConfigHandler::recognizedShortcutNames () \n</code></pre>"},{"location":"flameshot/classConfigResolver/","title":"Class ConfigResolver","text":"<p>ClassList &gt; ConfigResolver</p> <p>Inherits the following classes: QDialog</p>"},{"location":"flameshot/classConfigResolver/#public-functions","title":"Public Functions","text":"Type Name ConfigResolver (QWidget * parent=nullptr)  QGridLayout * layout ()"},{"location":"flameshot/classConfigResolver/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classConfigResolver/#function-configresolver","title":"function ConfigResolver","text":"<pre><code>ConfigResolver::ConfigResolver (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classConfigResolver/#function-layout","title":"function layout","text":"<pre><code>QGridLayout * ConfigResolver::layout () \n</code></pre>"},{"location":"flameshot/classConfigWindow/","title":"Class ConfigWindow","text":"<p>ClassList &gt; ConfigWindow</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classConfigWindow/#public-functions","title":"Public Functions","text":"Type Name ConfigWindow (QWidget * parent=nullptr)"},{"location":"flameshot/classConfigWindow/#protected-functions","title":"Protected Functions","text":"Type Name void keyPressEvent (QKeyEvent * e)"},{"location":"flameshot/classConfigWindow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classConfigWindow/#function-configwindow","title":"function ConfigWindow","text":"<pre><code>explicit ConfigWindow::ConfigWindow (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classConfigWindow/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classConfigWindow/#function-keypressevent","title":"function keyPressEvent","text":"<pre><code>void ConfigWindow::keyPressEvent (\n    QKeyEvent * e\n) \n</code></pre>"},{"location":"flameshot/classCopyTool/","title":"Class CopyTool","text":"<p>ClassList &gt; CopyTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classCopyTool/#public-functions","title":"Public Functions","text":"Type Name CopyTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classCopyTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classCopyTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classCopyTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classCopyTool/#function-copytool","title":"function CopyTool","text":"<pre><code>explicit CopyTool::CopyTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classCopyTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool CopyTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classCopyTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * CopyTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classCopyTool/#function-description","title":"function description","text":"<pre><code>QString CopyTool::description () override const\n</code></pre>"},{"location":"flameshot/classCopyTool/#function-icon","title":"function icon","text":"<pre><code>QIcon CopyTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classCopyTool/#function-name","title":"function name","text":"<pre><code>QString CopyTool::name () override const\n</code></pre>"},{"location":"flameshot/classCopyTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classCopyTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type CopyTool::type () override const\n</code></pre>"},{"location":"flameshot/structDesktopAppData/","title":"Struct DesktopAppData","text":"<p>ClassList &gt; DesktopAppData</p>"},{"location":"flameshot/structDesktopAppData/#public-attributes","title":"Public Attributes","text":"Type Name QStringList categories QString description QString exec QIcon icon QString name bool showInTerminal"},{"location":"flameshot/structDesktopAppData/#public-functions","title":"Public Functions","text":"Type Name DesktopAppData ()  DesktopAppData (const QString &amp; name, const QString &amp; description, const QString &amp; exec, QIcon icon)  bool operator== (const DesktopAppData &amp; other) const"},{"location":"flameshot/structDesktopAppData/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/structDesktopAppData/#variable-categories","title":"variable categories","text":"<pre><code>QStringList DesktopAppData::categories;\n</code></pre>"},{"location":"flameshot/structDesktopAppData/#variable-description","title":"variable description","text":"<pre><code>QString DesktopAppData::description;\n</code></pre>"},{"location":"flameshot/structDesktopAppData/#variable-exec","title":"variable exec","text":"<pre><code>QString DesktopAppData::exec;\n</code></pre>"},{"location":"flameshot/structDesktopAppData/#variable-icon","title":"variable icon","text":"<pre><code>QIcon DesktopAppData::icon;\n</code></pre>"},{"location":"flameshot/structDesktopAppData/#variable-name","title":"variable name","text":"<pre><code>QString DesktopAppData::name;\n</code></pre>"},{"location":"flameshot/structDesktopAppData/#variable-showinterminal","title":"variable showInTerminal","text":"<pre><code>bool DesktopAppData::showInTerminal;\n</code></pre>"},{"location":"flameshot/structDesktopAppData/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/structDesktopAppData/#function-desktopappdata-12","title":"function DesktopAppData [1/2]","text":"<pre><code>inline DesktopAppData::DesktopAppData () \n</code></pre>"},{"location":"flameshot/structDesktopAppData/#function-desktopappdata-22","title":"function DesktopAppData [2/2]","text":"<pre><code>inline DesktopAppData::DesktopAppData (\n    const QString &amp; name,\n    const QString &amp; description,\n    const QString &amp; exec,\n    QIcon icon\n) \n</code></pre>"},{"location":"flameshot/structDesktopAppData/#function-operator","title":"function operator==","text":"<pre><code>inline bool DesktopAppData::operator== (\n    const DesktopAppData &amp; other\n) const\n</code></pre>"},{"location":"flameshot/structDesktopFileParser/","title":"Struct DesktopFileParser","text":"<p>ClassList &gt; DesktopFileParser</p>"},{"location":"flameshot/structDesktopFileParser/#public-functions","title":"Public Functions","text":"Type Name DesktopFileParser ()  QVector&lt; DesktopAppData &gt; getAppsByCategory (const QString &amp; category)  QMap&lt; QString, QVector&lt; DesktopAppData &gt; &gt; getAppsByCategory (const QStringList &amp; categories)  DesktopAppData parseDesktopFile (const QString &amp; fileName, bool &amp; ok) const int processDirectory (const QDir &amp; dir)"},{"location":"flameshot/structDesktopFileParser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/structDesktopFileParser/#function-desktopfileparser","title":"function DesktopFileParser","text":"<pre><code>DesktopFileParser::DesktopFileParser () \n</code></pre>"},{"location":"flameshot/structDesktopFileParser/#function-getappsbycategory-12","title":"function getAppsByCategory [1/2]","text":"<pre><code>QVector&lt; DesktopAppData &gt; DesktopFileParser::getAppsByCategory (\n    const QString &amp; category\n) \n</code></pre>"},{"location":"flameshot/structDesktopFileParser/#function-getappsbycategory-22","title":"function getAppsByCategory [2/2]","text":"<pre><code>QMap&lt; QString, QVector&lt; DesktopAppData &gt; &gt; DesktopFileParser::getAppsByCategory (\n    const QStringList &amp; categories\n) \n</code></pre>"},{"location":"flameshot/structDesktopFileParser/#function-parsedesktopfile","title":"function parseDesktopFile","text":"<pre><code>DesktopAppData DesktopFileParser::parseDesktopFile (\n    const QString &amp; fileName,\n    bool &amp; ok\n) const\n</code></pre>"},{"location":"flameshot/structDesktopFileParser/#function-processdirectory","title":"function processDirectory","text":"<pre><code>int DesktopFileParser::processDirectory (\n    const QDir &amp; dir\n) \n</code></pre>"},{"location":"flameshot/classDesktopInfo/","title":"Class DesktopInfo","text":"<p>ClassList &gt; DesktopInfo</p>"},{"location":"flameshot/classDesktopInfo/#public-types","title":"Public Types","text":"Type Name enum WM"},{"location":"flameshot/classDesktopInfo/#public-functions","title":"Public Functions","text":"Type Name DesktopInfo ()  bool waylandDetected ()  WM windowManager ()"},{"location":"flameshot/classDesktopInfo/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classDesktopInfo/#enum-wm","title":"enum WM","text":"<pre><code>enum DesktopInfo::WM {\n    GNOME,\n    KDE,\n    OTHER,\n    QTILE,\n    SWAY,\n    HYPRLAND\n};\n</code></pre>"},{"location":"flameshot/classDesktopInfo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classDesktopInfo/#function-desktopinfo","title":"function DesktopInfo","text":"<pre><code>DesktopInfo::DesktopInfo () \n</code></pre>"},{"location":"flameshot/classDesktopInfo/#function-waylanddetected","title":"function waylandDetected","text":"<pre><code>bool DesktopInfo::waylandDetected () \n</code></pre>"},{"location":"flameshot/classDesktopInfo/#function-windowmanager","title":"function windowManager","text":"<pre><code>WM DesktopInfo::windowManager () \n</code></pre>"},{"location":"flameshot/classDraggableWidgetMaker/","title":"Class DraggableWidgetMaker","text":"<p>ClassList &gt; DraggableWidgetMaker</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classDraggableWidgetMaker/#public-functions","title":"Public Functions","text":"Type Name DraggableWidgetMaker (QObject * parent=nullptr)  void makeDraggable (QWidget * widget)"},{"location":"flameshot/classDraggableWidgetMaker/#protected-functions","title":"Protected Functions","text":"Type Name bool eventFilter (QObject * obj, QEvent * event) override"},{"location":"flameshot/classDraggableWidgetMaker/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classDraggableWidgetMaker/#function-draggablewidgetmaker","title":"function DraggableWidgetMaker","text":"<pre><code>DraggableWidgetMaker::DraggableWidgetMaker (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classDraggableWidgetMaker/#function-makedraggable","title":"function makeDraggable","text":"<pre><code>void DraggableWidgetMaker::makeDraggable (\n    QWidget * widget\n) \n</code></pre>"},{"location":"flameshot/classDraggableWidgetMaker/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classDraggableWidgetMaker/#function-eventfilter","title":"function eventFilter","text":"<pre><code>bool DraggableWidgetMaker::eventFilter (\n    QObject * obj,\n    QEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classExistingDir/","title":"Class ExistingDir","text":"<p>ClassList &gt; ExistingDir</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classExistingDir/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classExistingDir/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classExitTool/","title":"Class ExitTool","text":"<p>ClassList &gt; ExitTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classExitTool/#public-functions","title":"Public Functions","text":"Type Name ExitTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classExitTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classExitTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classExitTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classExitTool/#function-exittool","title":"function ExitTool","text":"<pre><code>explicit ExitTool::ExitTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classExitTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool ExitTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classExitTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * ExitTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classExitTool/#function-description","title":"function description","text":"<pre><code>QString ExitTool::description () override const\n</code></pre>"},{"location":"flameshot/classExitTool/#function-icon","title":"function icon","text":"<pre><code>QIcon ExitTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classExitTool/#function-name","title":"function name","text":"<pre><code>QString ExitTool::name () override const\n</code></pre>"},{"location":"flameshot/classExitTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classExitTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type ExitTool::type () override const\n</code></pre>"},{"location":"flameshot/classExtendedSlider/","title":"Class ExtendedSlider","text":"<p>ClassList &gt; ExtendedSlider</p> <p>Inherits the following classes: QSlider</p>"},{"location":"flameshot/classExtendedSlider/#public-functions","title":"Public Functions","text":"Type Name ExtendedSlider (QWidget * parent=nullptr)  int mappedValue (int min, int max)  void setMapedValue (int min, int val, int max)"},{"location":"flameshot/classExtendedSlider/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classExtendedSlider/#function-extendedslider","title":"function ExtendedSlider","text":"<pre><code>explicit ExtendedSlider::ExtendedSlider (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classExtendedSlider/#function-mappedvalue","title":"function mappedValue","text":"<pre><code>int ExtendedSlider::mappedValue (\n    int min,\n    int max\n) \n</code></pre>"},{"location":"flameshot/classExtendedSlider/#function-setmapedvalue","title":"function setMapedValue","text":"<pre><code>void ExtendedSlider::setMapedValue (\n    int min,\n    int val,\n    int max\n) \n</code></pre>"},{"location":"flameshot/classFileNameEditor/","title":"Class FileNameEditor","text":"<p>ClassList &gt; FileNameEditor</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classFileNameEditor/#public-functions","title":"Public Functions","text":"Type Name FileNameEditor (QWidget * parent=nullptr)"},{"location":"flameshot/classFileNameEditor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classFileNameEditor/#function-filenameeditor","title":"function FileNameEditor","text":"<pre><code>explicit FileNameEditor::FileNameEditor (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classFileNameHandler/","title":"Class FileNameHandler","text":"<p>ClassList &gt; FileNameHandler</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classFileNameHandler/#public-static-attributes","title":"Public Static Attributes","text":"Type Name const int MAX_CHARACTERS   = = 70"},{"location":"flameshot/classFileNameHandler/#public-functions","title":"Public Functions","text":"Type Name FileNameHandler (QObject * parent=nullptr)  QString parseFilename (const QString &amp; name)  QString parsedPattern ()  QString properScreenshotPath (QString filename, const QString &amp; format=QString()) Generate a valid destination path from the possibly incomplete <code>path</code> . The input<code>path</code> can be one of:"},{"location":"flameshot/classFileNameHandler/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"flameshot/classFileNameHandler/#variable-max_characters","title":"variable MAX_CHARACTERS","text":"<pre><code>const int FileNameHandler::MAX_CHARACTERS;\n</code></pre>"},{"location":"flameshot/classFileNameHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classFileNameHandler/#function-filenamehandler","title":"function FileNameHandler","text":"<pre><code>explicit FileNameHandler::FileNameHandler (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classFileNameHandler/#function-parsefilename","title":"function parseFilename","text":"<pre><code>QString FileNameHandler::parseFilename (\n    const QString &amp; name\n) \n</code></pre>"},{"location":"flameshot/classFileNameHandler/#function-parsedpattern","title":"function parsedPattern","text":"<pre><code>QString FileNameHandler::parsedPattern () \n</code></pre>"},{"location":"flameshot/classFileNameHandler/#function-properscreenshotpath","title":"function properScreenshotPath","text":"<p>Generate a valid destination path from the possibly incomplete <code>path</code> . The input<code>path</code> can be one of:</p> <pre><code>QString FileNameHandler::properScreenshotPath (\n    QString filename,\n    const QString &amp; format=QString()\n) \n</code></pre> <ul> <li>empty string</li> <li>an existing directory</li> <li>a file in an existing directory In each case, the output path will be an absolute path to a file with a suffix matching the specified <code>format</code>. </li> </ul> <p>Note:</p> <ul> <li>If <code>path</code> points to a directory, the file name will be generated from the formatted file name from the user configuration</li> <li>If <code>path</code> points to a file, its suffix will be changed to match <code>format</code></li> <li>If <code>format</code> is not given, the suffix will remain untouched, unless <code>path</code> has no suffix, in which case it will be given the \"png\" suffix</li> <li>If the path generated by the previous steps points to an existing file, \"_NUM\" will be appended to its base name, where NUM is the first available number that produces a non-existent path (starting from 1). </li> </ul> <p>Parameters:</p> <ul> <li><code>path</code> Possibly incomplete file name to transform </li> <li><code>format</code> Desired output file suffix (excluding an initial '.' character) </li> </ul>"},{"location":"flameshot/classFilenamePattern/","title":"Class FilenamePattern","text":"<p>ClassList &gt; FilenamePattern</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classFilenamePattern/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classFilenamePattern/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classFlameshot/","title":"Class Flameshot","text":"<p>ClassList &gt; Flameshot</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classFlameshot/#public-types","title":"Public Types","text":"Type Name enum Origin"},{"location":"flameshot/classFlameshot/#public-functions","title":"Public Functions","text":"Type Name bool haveExternalWidget ()  void setExternalWidget (bool b)"},{"location":"flameshot/classFlameshot/#public-static-functions","title":"Public Static Functions","text":"Type Name Flameshot * instance ()  Origin origin ()  void setOrigin (Origin origin)"},{"location":"flameshot/classFlameshot/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classFlameshot/#enum-origin","title":"enum Origin","text":"<pre><code>enum Flameshot::Origin {\n    CLI,\n    DAEMON\n};\n</code></pre>"},{"location":"flameshot/classFlameshot/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classFlameshot/#function-haveexternalwidget","title":"function haveExternalWidget","text":"<pre><code>bool Flameshot::haveExternalWidget () \n</code></pre>"},{"location":"flameshot/classFlameshot/#function-setexternalwidget","title":"function setExternalWidget","text":"<pre><code>void Flameshot::setExternalWidget (\n    bool b\n) \n</code></pre>"},{"location":"flameshot/classFlameshot/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classFlameshot/#function-instance","title":"function instance","text":"<pre><code>static Flameshot * Flameshot::instance () \n</code></pre>"},{"location":"flameshot/classFlameshot/#function-origin","title":"function origin","text":"<pre><code>static Origin Flameshot::origin () \n</code></pre>"},{"location":"flameshot/classFlameshot/#function-setorigin","title":"function setOrigin","text":"<pre><code>static void Flameshot::setOrigin (\n    Origin origin\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDBusAdapter/","title":"Class FlameshotDBusAdapter","text":"<p>ClassList &gt; FlameshotDBusAdapter</p> <p>Inherits the following classes: QDBusAbstractAdaptor</p>"},{"location":"flameshot/classFlameshotDBusAdapter/#public-functions","title":"Public Functions","text":"Type Name FlameshotDBusAdapter (QObject * parent=nullptr)  virtual ~FlameshotDBusAdapter ()"},{"location":"flameshot/classFlameshotDBusAdapter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classFlameshotDBusAdapter/#function-flameshotdbusadapter","title":"function FlameshotDBusAdapter","text":"<pre><code>explicit FlameshotDBusAdapter::FlameshotDBusAdapter (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDBusAdapter/#function-flameshotdbusadapter_1","title":"function ~FlameshotDBusAdapter","text":"<pre><code>virtual FlameshotDBusAdapter::~FlameshotDBusAdapter () \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/","title":"Class FlameshotDaemon","text":"<p>ClassList &gt; FlameshotDaemon</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classFlameshotDaemon/#public-functions","title":"Public Functions","text":"Type Name void sendTrayNotification (const QString &amp; text, const QString &amp; title=QStringLiteral(\"Flameshot Info\"), const int timeout=5000)  void showUpdateNotificationIfAvailable (CaptureWidget * widget)"},{"location":"flameshot/classFlameshotDaemon/#public-static-functions","title":"Public Static Functions","text":"Type Name void copyToClipboard (const QPixmap &amp; capture)  void copyToClipboard (const QString &amp; text, const QString &amp; notification=\"\")  void createPin (const QPixmap &amp; capture, QRect geometry)  FlameshotDaemon * instance () Return the daemon instance. bool isThisInstanceHostingWidgets () Is this instance of flameshot hosting any windows as a daemon? void start ()"},{"location":"flameshot/classFlameshotDaemon/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classFlameshotDaemon/#function-sendtraynotification","title":"function sendTrayNotification","text":"<pre><code>void FlameshotDaemon::sendTrayNotification (\n    const QString &amp; text,\n    const QString &amp; title=QStringLiteral(\"Flameshot Info\"),\n    const int timeout=5000\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/#function-showupdatenotificationifavailable","title":"function showUpdateNotificationIfAvailable","text":"<pre><code>void FlameshotDaemon::showUpdateNotificationIfAvailable (\n    CaptureWidget * widget\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classFlameshotDaemon/#function-copytoclipboard-12","title":"function copyToClipboard [1/2]","text":"<pre><code>static void FlameshotDaemon::copyToClipboard (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/#function-copytoclipboard-22","title":"function copyToClipboard [2/2]","text":"<pre><code>static void FlameshotDaemon::copyToClipboard (\n    const QString &amp; text,\n    const QString &amp; notification=\"\"\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/#function-createpin","title":"function createPin","text":"<pre><code>static void FlameshotDaemon::createPin (\n    const QPixmap &amp; capture,\n    QRect geometry\n) \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/#function-instance","title":"function instance","text":"<p>Return the daemon instance. </p> <pre><code>static FlameshotDaemon * FlameshotDaemon::instance () \n</code></pre> <p>If this instance of flameshot is the daemon, a singleton instance of <code>FlameshotDaemon</code> is returned. As a side effect<code>start</code> will called if it wasn't called earlier. If this instance of flameshot is not the daemon, <code>nullptr</code> is returned.</p> <p>This strategy is used because the daemon needs to receive signals from D-Bus, for which an instance of a <code>QObject</code> is required. The singleton serves as that object. </p>"},{"location":"flameshot/classFlameshotDaemon/#function-isthisinstancehostingwidgets","title":"function isThisInstanceHostingWidgets","text":"<pre><code>static bool FlameshotDaemon::isThisInstanceHostingWidgets () \n</code></pre>"},{"location":"flameshot/classFlameshotDaemon/#function-start","title":"function start","text":"<pre><code>static void FlameshotDaemon::start () \n</code></pre>"},{"location":"flameshot/classGeneralConf/","title":"Class GeneralConf","text":"<p>ClassList &gt; GeneralConf</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classGeneralConf/#public-types","title":"Public Types","text":"Type Name enum xywh_position"},{"location":"flameshot/classGeneralConf/#public-functions","title":"Public Functions","text":"Type Name GeneralConf (QWidget * parent=nullptr)"},{"location":"flameshot/classGeneralConf/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classGeneralConf/#enum-xywh_position","title":"enum xywh_position","text":"<pre><code>enum GeneralConf::xywh_position {\n    xywh_none = 0,\n    xywh_top_left = 1,\n    xywh_bottom_left = 2,\n    xywh_top_right = 3,\n    xywh_bottom_right = 4,\n    xywh_center = 5\n};\n</code></pre>"},{"location":"flameshot/classGeneralConf/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classGeneralConf/#function-generalconf","title":"function GeneralConf","text":"<pre><code>explicit GeneralConf::GeneralConf (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classGlobalShortcutFilter/","title":"Class GlobalShortcutFilter","text":"<p>ClassList &gt; GlobalShortcutFilter</p> <p>Inherits the following classes: QObject,  QAbstractNativeEventFilter</p>"},{"location":"flameshot/classGlobalShortcutFilter/#public-functions","title":"Public Functions","text":"Type Name GlobalShortcutFilter (QObject * parent=nullptr)  bool nativeEventFilter (const QByteArray &amp; eventType, void * message, long * result)"},{"location":"flameshot/classGlobalShortcutFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classGlobalShortcutFilter/#function-globalshortcutfilter","title":"function GlobalShortcutFilter","text":"<pre><code>explicit GlobalShortcutFilter::GlobalShortcutFilter (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classGlobalShortcutFilter/#function-nativeeventfilter","title":"function nativeEventFilter","text":"<pre><code>bool GlobalShortcutFilter::nativeEventFilter (\n    const QByteArray &amp; eventType,\n    void * message,\n    long * result\n) \n</code></pre>"},{"location":"flameshot/namespaceGlobalValues/","title":"Namespace GlobalValues","text":"<p>Namespace List &gt; GlobalValues</p>"},{"location":"flameshot/namespaceGlobalValues/#public-functions","title":"Public Functions","text":"Type Name int buttonBaseSize ()  QString iconPath ()  QString iconPathPNG ()  QString versionInfo ()"},{"location":"flameshot/namespaceGlobalValues/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/namespaceGlobalValues/#function-buttonbasesize","title":"function buttonBaseSize","text":"<pre><code>int GlobalValues::buttonBaseSize () \n</code></pre>"},{"location":"flameshot/namespaceGlobalValues/#function-iconpath","title":"function iconPath","text":"<pre><code>QString GlobalValues::iconPath () \n</code></pre>"},{"location":"flameshot/namespaceGlobalValues/#function-iconpathpng","title":"function iconPathPNG","text":"<pre><code>QString GlobalValues::iconPathPNG () \n</code></pre>"},{"location":"flameshot/namespaceGlobalValues/#function-versioninfo","title":"function versionInfo","text":"<pre><code>QString GlobalValues::versionInfo () \n</code></pre>"},{"location":"flameshot/classHistory/","title":"Class History","text":"<p>ClassList &gt; History</p>"},{"location":"flameshot/classHistory/#public-functions","title":"Public Functions","text":"Type Name History ()  const QList&lt; QString &gt; &amp; history ()  const QString &amp; packFileName (const QString &amp; storageType, const QString &amp; deleteToken, const QString &amp; fileName)  const QString &amp; path ()  void save (const QPixmap &amp; pixmap, const QString &amp; fileName)  const HistoryFileName &amp; unpackFileName (const QString &amp; fileNamePacked)"},{"location":"flameshot/classHistory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classHistory/#function-history","title":"function History","text":"<pre><code>History::History () \n</code></pre>"},{"location":"flameshot/classHistory/#function-history_1","title":"function history","text":"<pre><code>const QList&lt; QString &gt; &amp; History::history () \n</code></pre>"},{"location":"flameshot/classHistory/#function-packfilename","title":"function packFileName","text":"<pre><code>const QString &amp; History::packFileName (\n    const QString &amp; storageType,\n    const QString &amp; deleteToken,\n    const QString &amp; fileName\n) \n</code></pre>"},{"location":"flameshot/classHistory/#function-path","title":"function path","text":"<pre><code>const QString &amp; History::path () \n</code></pre>"},{"location":"flameshot/classHistory/#function-save","title":"function save","text":"<pre><code>void History::save (\n    const QPixmap &amp; pixmap,\n    const QString &amp; fileName\n) \n</code></pre>"},{"location":"flameshot/classHistory/#function-unpackfilename","title":"function unpackFileName","text":"<pre><code>const HistoryFileName &amp; History::unpackFileName (\n    const QString &amp; fileNamePacked\n) \n</code></pre>"},{"location":"flameshot/structHistoryFileName/","title":"Struct HistoryFileName","text":"<p>ClassList &gt; HistoryFileName</p>"},{"location":"flameshot/structHistoryFileName/#public-attributes","title":"Public Attributes","text":"Type Name QString file QString token QString type"},{"location":"flameshot/structHistoryFileName/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/structHistoryFileName/#variable-file","title":"variable file","text":"<pre><code>QString HistoryFileName::file;\n</code></pre>"},{"location":"flameshot/structHistoryFileName/#variable-token","title":"variable token","text":"<pre><code>QString HistoryFileName::token;\n</code></pre>"},{"location":"flameshot/structHistoryFileName/#variable-type","title":"variable type","text":"<pre><code>QString HistoryFileName::type;\n</code></pre>"},{"location":"flameshot/classHoverEventFilter/","title":"Class HoverEventFilter","text":"<p>ClassList &gt; HoverEventFilter</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classHoverEventFilter/#public-functions","title":"Public Functions","text":"Type Name HoverEventFilter (QObject * parent=nullptr)"},{"location":"flameshot/classHoverEventFilter/#protected-functions","title":"Protected Functions","text":"Type Name bool eventFilter (QObject * watched, QEvent * event)"},{"location":"flameshot/classHoverEventFilter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classHoverEventFilter/#function-hovereventfilter","title":"function HoverEventFilter","text":"<pre><code>explicit HoverEventFilter::HoverEventFilter (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classHoverEventFilter/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classHoverEventFilter/#function-eventfilter","title":"function eventFilter","text":"<pre><code>bool HoverEventFilter::eventFilter (\n    QObject * watched,\n    QEvent * event\n) \n</code></pre>"},{"location":"flameshot/classImageLabel/","title":"Class ImageLabel","text":"<p>ClassList &gt; ImageLabel</p> <p>Inherits the following classes: QLabel</p>"},{"location":"flameshot/classImageLabel/#public-functions","title":"Public Functions","text":"Type Name ImageLabel (QWidget * parent=nullptr)  void setScreenshot (const QPixmap &amp; pixmap)"},{"location":"flameshot/classImageLabel/#protected-functions","title":"Protected Functions","text":"Type Name void mouseMoveEvent (QMouseEvent * event)  void mousePressEvent (QMouseEvent * event)  void mouseReleaseEvent (QMouseEvent * event)  void resizeEvent (QResizeEvent * event)"},{"location":"flameshot/classImageLabel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classImageLabel/#function-imagelabel","title":"function ImageLabel","text":"<pre><code>explicit ImageLabel::ImageLabel (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImageLabel/#function-setscreenshot","title":"function setScreenshot","text":"<pre><code>void ImageLabel::setScreenshot (\n    const QPixmap &amp; pixmap\n) \n</code></pre>"},{"location":"flameshot/classImageLabel/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classImageLabel/#function-mousemoveevent","title":"function mouseMoveEvent","text":"<pre><code>void ImageLabel::mouseMoveEvent (\n    QMouseEvent * event\n) \n</code></pre>"},{"location":"flameshot/classImageLabel/#function-mousepressevent","title":"function mousePressEvent","text":"<pre><code>void ImageLabel::mousePressEvent (\n    QMouseEvent * event\n) \n</code></pre>"},{"location":"flameshot/classImageLabel/#function-mousereleaseevent","title":"function mouseReleaseEvent","text":"<pre><code>void ImageLabel::mouseReleaseEvent (\n    QMouseEvent * event\n) \n</code></pre>"},{"location":"flameshot/classImageLabel/#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void ImageLabel::resizeEvent (\n    QResizeEvent * event\n) \n</code></pre>"},{"location":"flameshot/classImgUploadDialog/","title":"Class ImgUploadDialog","text":"<p>ClassList &gt; ImgUploadDialog</p> <p>Inherits the following classes: QDialog</p>"},{"location":"flameshot/classImgUploadDialog/#public-functions","title":"Public Functions","text":"Type Name ImgUploadDialog (QDialog * parent=nullptr)"},{"location":"flameshot/classImgUploadDialog/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classImgUploadDialog/#function-imguploaddialog","title":"function ImgUploadDialog","text":"<pre><code>explicit ImgUploadDialog::ImgUploadDialog (\n    QDialog * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/","title":"Class ImgUploaderBase","text":"<p>ClassList &gt; ImgUploaderBase</p> <p>Inherits the following classes: QWidget</p> <p>Inherited by the following classes: ImgurUploader</p>"},{"location":"flameshot/classImgUploaderBase/#public-attributes","title":"Public Attributes","text":"Type Name QString m_currentImageName"},{"location":"flameshot/classImgUploaderBase/#public-functions","title":"Public Functions","text":"Type Name ImgUploaderBase (const QPixmap &amp; capture, QWidget * parent=nullptr)  virtual void deleteImage (const QString &amp; fileName, const QString &amp; deleteToken) = 0 const QUrl &amp; imageURL ()  NotificationWidget * notification ()  const QPixmap &amp; pixmap ()  void setImageURL (const QUrl &amp; imageURL)  void setInfoLabelText (const QString &amp; text)  void setPixmap (const QPixmap &amp; pixmap)  LoadSpinner * spinner ()  virtual void upload () = 0"},{"location":"flameshot/classImgUploaderBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/classImgUploaderBase/#variable-m_currentimagename","title":"variable m_currentImageName","text":"<pre><code>QString ImgUploaderBase::m_currentImageName;\n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classImgUploaderBase/#function-imguploaderbase","title":"function ImgUploaderBase","text":"<pre><code>explicit ImgUploaderBase::ImgUploaderBase (\n    const QPixmap &amp; capture,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-deleteimage","title":"function deleteImage","text":"<pre><code>virtual void ImgUploaderBase::deleteImage (\n    const QString &amp; fileName,\n    const QString &amp; deleteToken\n) = 0\n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-imageurl","title":"function imageURL","text":"<pre><code>const QUrl &amp; ImgUploaderBase::imageURL () \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-notification","title":"function notification","text":"<pre><code>NotificationWidget * ImgUploaderBase::notification () \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-pixmap","title":"function pixmap","text":"<pre><code>const QPixmap &amp; ImgUploaderBase::pixmap () \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-setimageurl","title":"function setImageURL","text":"<pre><code>void ImgUploaderBase::setImageURL (\n    const QUrl &amp; imageURL\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-setinfolabeltext","title":"function setInfoLabelText","text":"<pre><code>void ImgUploaderBase::setInfoLabelText (\n    const QString &amp; text\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-setpixmap","title":"function setPixmap","text":"<pre><code>void ImgUploaderBase::setPixmap (\n    const QPixmap &amp; pixmap\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-spinner","title":"function spinner","text":"<pre><code>LoadSpinner * ImgUploaderBase::spinner () \n</code></pre>"},{"location":"flameshot/classImgUploaderBase/#function-upload","title":"function upload","text":"<pre><code>virtual void ImgUploaderBase::upload () = 0\n</code></pre>"},{"location":"flameshot/classImgUploaderManager/","title":"Class ImgUploaderManager","text":"<p>ClassList &gt; ImgUploaderManager</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classImgUploaderManager/#public-functions","title":"Public Functions","text":"Type Name ImgUploaderManager (QObject * parent=nullptr)  ImgUploaderBase * uploader (const QPixmap &amp; capture, QWidget * parent=nullptr)  ImgUploaderBase * uploader (const QString &amp; imgUploaderPlugin)  const QString &amp; uploaderPlugin ()  const QString &amp; url ()"},{"location":"flameshot/classImgUploaderManager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classImgUploaderManager/#function-imguploadermanager","title":"function ImgUploaderManager","text":"<pre><code>explicit ImgUploaderManager::ImgUploaderManager (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderManager/#function-uploader-12","title":"function uploader [1/2]","text":"<pre><code>ImgUploaderBase * ImgUploaderManager::uploader (\n    const QPixmap &amp; capture,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderManager/#function-uploader-22","title":"function uploader [2/2]","text":"<pre><code>ImgUploaderBase * ImgUploaderManager::uploader (\n    const QString &amp; imgUploaderPlugin\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderManager/#function-uploaderplugin","title":"function uploaderPlugin","text":"<pre><code>const QString &amp; ImgUploaderManager::uploaderPlugin () \n</code></pre>"},{"location":"flameshot/classImgUploaderManager/#function-url","title":"function url","text":"<pre><code>const QString &amp; ImgUploaderManager::url () \n</code></pre>"},{"location":"flameshot/classImgUploaderTool/","title":"Class ImgUploaderTool","text":"<p>ClassList &gt; ImgUploaderTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classImgUploaderTool/#public-functions","title":"Public Functions","text":"Type Name ImgUploaderTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classImgUploaderTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classImgUploaderTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classImgUploaderTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classImgUploaderTool/#function-imguploadertool","title":"function ImgUploaderTool","text":"<pre><code>explicit ImgUploaderTool::ImgUploaderTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImgUploaderTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool ImgUploaderTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classImgUploaderTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * ImgUploaderTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classImgUploaderTool/#function-description","title":"function description","text":"<pre><code>QString ImgUploaderTool::description () override const\n</code></pre>"},{"location":"flameshot/classImgUploaderTool/#function-icon","title":"function icon","text":"<pre><code>QIcon ImgUploaderTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classImgUploaderTool/#function-name","title":"function name","text":"<pre><code>QString ImgUploaderTool::name () override const\n</code></pre>"},{"location":"flameshot/classImgUploaderTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classImgUploaderTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type ImgUploaderTool::type () override const\n</code></pre>"},{"location":"flameshot/classImgurUploader/","title":"Class ImgurUploader","text":"<p>ClassList &gt; ImgurUploader</p> <p>Inherits the following classes: ImgUploaderBase</p>"},{"location":"flameshot/classImgurUploader/#public-attributes-inherited-from-imguploaderbase","title":"Public Attributes inherited from ImgUploaderBase","text":"<p>See ImgUploaderBase</p> Type Name QString m_currentImageName"},{"location":"flameshot/classImgurUploader/#public-functions","title":"Public Functions","text":"Type Name ImgurUploader (const QPixmap &amp; capture, QWidget * parent=nullptr)  virtual void deleteImage (const QString &amp; fileName, const QString &amp; deleteToken)"},{"location":"flameshot/classImgurUploader/#public-functions-inherited-from-imguploaderbase","title":"Public Functions inherited from ImgUploaderBase","text":"<p>See ImgUploaderBase</p> Type Name ImgUploaderBase (const QPixmap &amp; capture, QWidget * parent=nullptr)  virtual void deleteImage (const QString &amp; fileName, const QString &amp; deleteToken) = 0 const QUrl &amp; imageURL ()  NotificationWidget * notification ()  const QPixmap &amp; pixmap ()  void setImageURL (const QUrl &amp; imageURL)  void setInfoLabelText (const QString &amp; text)  void setPixmap (const QPixmap &amp; pixmap)  LoadSpinner * spinner ()  virtual void upload () = 0"},{"location":"flameshot/classImgurUploader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classImgurUploader/#function-imguruploader","title":"function ImgurUploader","text":"<pre><code>explicit ImgurUploader::ImgurUploader (\n    const QPixmap &amp; capture,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classImgurUploader/#function-deleteimage","title":"function deleteImage","text":"<pre><code>virtual void ImgurUploader::deleteImage (\n    const QString &amp; fileName,\n    const QString &amp; deleteToken\n) \n</code></pre> <p>Implements ImgUploaderBase::deleteImage</p>"},{"location":"flameshot/classInfoWindow/","title":"Class InfoWindow","text":"<p>ClassList &gt; InfoWindow</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classInfoWindow/#public-functions","title":"Public Functions","text":"Type Name InfoWindow (QWidget * parent=nullptr)  ~InfoWindow ()"},{"location":"flameshot/classInfoWindow/#protected-functions","title":"Protected Functions","text":"Type Name void keyPressEvent (QKeyEvent * event)"},{"location":"flameshot/classInfoWindow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classInfoWindow/#function-infowindow","title":"function InfoWindow","text":"<pre><code>explicit InfoWindow::InfoWindow (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classInfoWindow/#function-infowindow_1","title":"function ~InfoWindow","text":"<pre><code>InfoWindow::~InfoWindow () \n</code></pre>"},{"location":"flameshot/classInfoWindow/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classInfoWindow/#function-keypressevent","title":"function keyPressEvent","text":"<pre><code>void InfoWindow::keyPressEvent (\n    QKeyEvent * event\n) \n</code></pre>"},{"location":"flameshot/classInvertTool/","title":"Class InvertTool","text":"<p>ClassList &gt; InvertTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classInvertTool/#public-functions","title":"Public Functions","text":"Type Name InvertTool (QObject * parent=nullptr)  QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawSearchArea (QPainter &amp; painter, const QPixmap &amp; pixmap) override QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classInvertTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classInvertTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classInvertTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classInvertTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classInvertTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classInvertTool/#function-inverttool","title":"function InvertTool","text":"<pre><code>explicit InvertTool::InvertTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classInvertTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect InvertTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * InvertTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-description","title":"function description","text":"<pre><code>QString InvertTool::description () override const\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-drawsearcharea","title":"function drawSearchArea","text":"<pre><code>void InvertTool::drawSearchArea (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-icon","title":"function icon","text":"<pre><code>QIcon InvertTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-name","title":"function name","text":"<pre><code>QString InvertTool::name () override const\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void InvertTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classInvertTool/#function-process","title":"function process","text":"<pre><code>void InvertTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classInvertTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classInvertTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type InvertTool::type () override const\n</code></pre>"},{"location":"flameshot/classKeySequence/","title":"Class KeySequence","text":"<p>ClassList &gt; KeySequence</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classKeySequence/#public-functions","title":"Public Functions","text":"Type Name KeySequence (const QKeySequence &amp; fallback={})  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value). virtual QVariant representation (const QVariant &amp; val) overrideReturn the representation of the value in the config file."},{"location":"flameshot/classKeySequence/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classKeySequence/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classKeySequence/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classKeySequence/#function-keysequence","title":"function KeySequence","text":"<pre><code>KeySequence::KeySequence (\n    const QKeySequence &amp; fallback={}\n) \n</code></pre>"},{"location":"flameshot/classKeySequence/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool KeySequence::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classKeySequence/#function-expected","title":"function expected","text":"<pre><code>virtual QString KeySequence::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classKeySequence/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant KeySequence::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classKeySequence/#function-representation","title":"function representation","text":"<p>Return the representation of the value in the config file. </p> <pre><code>virtual QVariant KeySequence::representation (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Override this if you want to write the value in a different format than the one provided by <code>QVariant</code>. </p> <p>Implements ValueHandler::representation</p>"},{"location":"flameshot/classLauncherItemDelegate/","title":"Class LauncherItemDelegate","text":"<p>ClassList &gt; LauncherItemDelegate</p> <p>Inherits the following classes: QStyledItemDelegate</p>"},{"location":"flameshot/classLauncherItemDelegate/#public-functions","title":"Public Functions","text":"Type Name LauncherItemDelegate (QObject * parent=nullptr)  void paint (QPainter * painter, const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) override const QSize sizeHint (const QStyleOptionViewItem &amp; option, const QModelIndex &amp; index) override const"},{"location":"flameshot/classLauncherItemDelegate/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classLauncherItemDelegate/#function-launcheritemdelegate","title":"function LauncherItemDelegate","text":"<pre><code>explicit LauncherItemDelegate::LauncherItemDelegate (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classLauncherItemDelegate/#function-paint","title":"function paint","text":"<pre><code>void LauncherItemDelegate::paint (\n    QPainter * painter,\n    const QStyleOptionViewItem &amp; option,\n    const QModelIndex &amp; index\n) override const\n</code></pre>"},{"location":"flameshot/classLauncherItemDelegate/#function-sizehint","title":"function sizeHint","text":"<pre><code>QSize LauncherItemDelegate::sizeHint (\n    const QStyleOptionViewItem &amp; option,\n    const QModelIndex &amp; index\n) override const\n</code></pre>"},{"location":"flameshot/classLineTool/","title":"Class LineTool","text":"<p>ClassList &gt; LineTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classLineTool/#public-functions","title":"Public Functions","text":"Type Name LineTool (QObject * parent=nullptr)  CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classLineTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classLineTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classLineTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classLineTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classLineTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classLineTool/#function-linetool","title":"function LineTool","text":"<pre><code>explicit LineTool::LineTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classLineTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * LineTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classLineTool/#function-description","title":"function description","text":"<pre><code>QString LineTool::description () override const\n</code></pre>"},{"location":"flameshot/classLineTool/#function-icon","title":"function icon","text":"<pre><code>QIcon LineTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classLineTool/#function-name","title":"function name","text":"<pre><code>QString LineTool::name () override const\n</code></pre>"},{"location":"flameshot/classLineTool/#function-process","title":"function process","text":"<pre><code>void LineTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classLineTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classLineTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type LineTool::type () override const\n</code></pre>"},{"location":"flameshot/classLoadSpinner/","title":"Class LoadSpinner","text":"<p>ClassList &gt; LoadSpinner</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classLoadSpinner/#public-functions","title":"Public Functions","text":"Type Name LoadSpinner (QWidget * parent=nullptr)  void setColor (const QColor &amp; c)  void setHeight (int h)  void setWidth (int w)  void start ()  void stop ()"},{"location":"flameshot/classLoadSpinner/#protected-functions","title":"Protected Functions","text":"Type Name void paintEvent (QPaintEvent *)"},{"location":"flameshot/classLoadSpinner/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classLoadSpinner/#function-loadspinner","title":"function LoadSpinner","text":"<pre><code>explicit LoadSpinner::LoadSpinner (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classLoadSpinner/#function-setcolor","title":"function setColor","text":"<pre><code>void LoadSpinner::setColor (\n    const QColor &amp; c\n) \n</code></pre>"},{"location":"flameshot/classLoadSpinner/#function-setheight","title":"function setHeight","text":"<pre><code>void LoadSpinner::setHeight (\n    int h\n) \n</code></pre>"},{"location":"flameshot/classLoadSpinner/#function-setwidth","title":"function setWidth","text":"<pre><code>void LoadSpinner::setWidth (\n    int w\n) \n</code></pre>"},{"location":"flameshot/classLoadSpinner/#function-start","title":"function start","text":"<pre><code>void LoadSpinner::start () \n</code></pre>"},{"location":"flameshot/classLoadSpinner/#function-stop","title":"function stop","text":"<pre><code>void LoadSpinner::stop () \n</code></pre>"},{"location":"flameshot/classLoadSpinner/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classLoadSpinner/#function-paintevent","title":"function paintEvent","text":"<pre><code>void LoadSpinner::paintEvent (\n    QPaintEvent *\n) \n</code></pre>"},{"location":"flameshot/classLowerBoundedInt/","title":"Class LowerBoundedInt","text":"<p>ClassList &gt; LowerBoundedInt</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classLowerBoundedInt/#public-functions","title":"Public Functions","text":"Type Name LowerBoundedInt (int min, int def)  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value)."},{"location":"flameshot/classLowerBoundedInt/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classLowerBoundedInt/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classLowerBoundedInt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classLowerBoundedInt/#function-lowerboundedint","title":"function LowerBoundedInt","text":"<pre><code>LowerBoundedInt::LowerBoundedInt (\n    int min,\n    int def\n) \n</code></pre>"},{"location":"flameshot/classLowerBoundedInt/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool LowerBoundedInt::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classLowerBoundedInt/#function-expected","title":"function expected","text":"<pre><code>virtual QString LowerBoundedInt::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classLowerBoundedInt/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant LowerBoundedInt::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classMagnifierWidget/","title":"Class MagnifierWidget","text":"<p>ClassList &gt; MagnifierWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classMagnifierWidget/#public-functions","title":"Public Functions","text":"Type Name MagnifierWidget (const QPixmap &amp; p, const QColor &amp; c, bool isSquare, QWidget * parent=nullptr)"},{"location":"flameshot/classMagnifierWidget/#protected-functions","title":"Protected Functions","text":"Type Name void paintEvent (QPaintEvent *) override"},{"location":"flameshot/classMagnifierWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classMagnifierWidget/#function-magnifierwidget","title":"function MagnifierWidget","text":"<pre><code>explicit MagnifierWidget::MagnifierWidget (\n    const QPixmap &amp; p,\n    const QColor &amp; c,\n    bool isSquare,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classMagnifierWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classMagnifierWidget/#function-paintevent","title":"function paintEvent","text":"<pre><code>void MagnifierWidget::paintEvent (\n    QPaintEvent *\n) override\n</code></pre>"},{"location":"flameshot/classMarkerTool/","title":"Class MarkerTool","text":"<p>ClassList &gt; MarkerTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classMarkerTool/#public-functions","title":"Public Functions","text":"Type Name MarkerTool (QObject * parent=nullptr)  CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QRect mousePreviewRect (const CaptureContext &amp; context) override const QString name () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classMarkerTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classMarkerTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classMarkerTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classMarkerTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classMarkerTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classMarkerTool/#function-markertool","title":"function MarkerTool","text":"<pre><code>explicit MarkerTool::MarkerTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * MarkerTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-description","title":"function description","text":"<pre><code>QString MarkerTool::description () override const\n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-icon","title":"function icon","text":"<pre><code>QIcon MarkerTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-mousepreviewrect","title":"function mousePreviewRect","text":"<pre><code>QRect MarkerTool::mousePreviewRect (\n    const CaptureContext &amp; context\n) override const\n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-name","title":"function name","text":"<pre><code>QString MarkerTool::name () override const\n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void MarkerTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classMarkerTool/#function-process","title":"function process","text":"<pre><code>void MarkerTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classMarkerTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classMarkerTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type MarkerTool::type () override const\n</code></pre>"},{"location":"flameshot/classModificationCommand/","title":"Class ModificationCommand","text":"<p>ClassList &gt; ModificationCommand</p> <p>Inherits the following classes: QUndoCommand</p>"},{"location":"flameshot/classModificationCommand/#public-functions","title":"Public Functions","text":"Type Name ModificationCommand (CaptureWidget * captureWidget, const CaptureToolObjects &amp; captureToolObjects, const CaptureToolObjects &amp; captureToolObjectsBackup)  virtual void redo () override virtual void undo () override"},{"location":"flameshot/classModificationCommand/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classModificationCommand/#function-modificationcommand","title":"function ModificationCommand","text":"<pre><code>ModificationCommand::ModificationCommand (\n    CaptureWidget * captureWidget,\n    const CaptureToolObjects &amp; captureToolObjects,\n    const CaptureToolObjects &amp; captureToolObjectsBackup\n) \n</code></pre>"},{"location":"flameshot/classModificationCommand/#function-redo","title":"function redo","text":"<pre><code>virtual void ModificationCommand::redo () override\n</code></pre>"},{"location":"flameshot/classModificationCommand/#function-undo","title":"function undo","text":"<pre><code>virtual void ModificationCommand::undo () override\n</code></pre>"},{"location":"flameshot/classMoveTool/","title":"Class MoveTool","text":"<p>ClassList &gt; MoveTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classMoveTool/#public-functions","title":"Public Functions","text":"Type Name MoveTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const bool isSelectable () override const QString name () override const CaptureTool::Type type () override const"},{"location":"flameshot/classMoveTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classMoveTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classMoveTool/#function-movetool","title":"function MoveTool","text":"<pre><code>explicit MoveTool::MoveTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classMoveTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool MoveTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classMoveTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * MoveTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classMoveTool/#function-description","title":"function description","text":"<pre><code>QString MoveTool::description () override const\n</code></pre>"},{"location":"flameshot/classMoveTool/#function-icon","title":"function icon","text":"<pre><code>QIcon MoveTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classMoveTool/#function-isselectable","title":"function isSelectable","text":"<pre><code>bool MoveTool::isSelectable () override const\n</code></pre>"},{"location":"flameshot/classMoveTool/#function-name","title":"function name","text":"<pre><code>QString MoveTool::name () override const\n</code></pre>"},{"location":"flameshot/classMoveTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type MoveTool::type () override const\n</code></pre>"},{"location":"flameshot/classNotificationWidget/","title":"Class NotificationWidget","text":"<p>ClassList &gt; NotificationWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classNotificationWidget/#public-functions","title":"Public Functions","text":"Type Name NotificationWidget (QWidget * parent=nullptr)  void showMessage (const QString &amp; msg)"},{"location":"flameshot/classNotificationWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classNotificationWidget/#function-notificationwidget","title":"function NotificationWidget","text":"<pre><code>explicit NotificationWidget::NotificationWidget (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classNotificationWidget/#function-showmessage","title":"function showMessage","text":"<pre><code>void NotificationWidget::showMessage (\n    const QString &amp; msg\n) \n</code></pre>"},{"location":"flameshot/classNotifierBox/","title":"Class NotifierBox","text":"<p>ClassList &gt; NotifierBox</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classNotifierBox/#public-functions","title":"Public Functions","text":"Type Name NotifierBox (QWidget * parent=nullptr)"},{"location":"flameshot/classNotifierBox/#protected-functions","title":"Protected Functions","text":"Type Name virtual void enterEvent (QEvent *) override virtual void paintEvent (QPaintEvent *) override"},{"location":"flameshot/classNotifierBox/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classNotifierBox/#function-notifierbox","title":"function NotifierBox","text":"<pre><code>explicit NotifierBox::NotifierBox (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classNotifierBox/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classNotifierBox/#function-enterevent","title":"function enterEvent","text":"<pre><code>virtual void NotifierBox::enterEvent (\n    QEvent *\n) override\n</code></pre>"},{"location":"flameshot/classNotifierBox/#function-paintevent","title":"function paintEvent","text":"<pre><code>virtual void NotifierBox::paintEvent (\n    QPaintEvent *\n) override\n</code></pre>"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/","title":"Class OrgFreedesktopPortalRequestInterface","text":"<p>ClassList &gt; OrgFreedesktopPortalRequestInterface</p> <p>Inherits the following classes: QDBusAbstractInterface</p>"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-functions","title":"Public Functions","text":"Type Name OrgFreedesktopPortalRequestInterface (const QString &amp; service, const QString &amp; path, const QDBusConnection &amp; connection, QObject * parent=nullptr)  ~OrgFreedesktopPortalRequestInterface ()"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-static-functions","title":"Public Static Functions","text":"Type Name const char * staticInterfaceName ()"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#function-orgfreedesktopportalrequestinterface","title":"function OrgFreedesktopPortalRequestInterface","text":"<pre><code>OrgFreedesktopPortalRequestInterface::OrgFreedesktopPortalRequestInterface (\n    const QString &amp; service,\n    const QString &amp; path,\n    const QDBusConnection &amp; connection,\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#function-orgfreedesktopportalrequestinterface_1","title":"function ~OrgFreedesktopPortalRequestInterface","text":"<pre><code>OrgFreedesktopPortalRequestInterface::~OrgFreedesktopPortalRequestInterface () \n</code></pre>"},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classOrgFreedesktopPortalRequestInterface/#function-staticinterfacename","title":"function staticInterfaceName","text":"<pre><code>static inline const char * OrgFreedesktopPortalRequestInterface::staticInterfaceName () \n</code></pre>"},{"location":"flameshot/classOrientablePushButton/","title":"Class OrientablePushButton","text":"<p>ClassList &gt; OrientablePushButton</p> <p>Inherits the following classes: CaptureButton</p>"},{"location":"flameshot/classOrientablePushButton/#public-types","title":"Public Types","text":"Type Name enum Orientation"},{"location":"flameshot/classOrientablePushButton/#public-functions","title":"Public Functions","text":"Type Name OrientablePushButton (QWidget * parent=nullptr)  OrientablePushButton (const QString &amp; text, QWidget * parent=nullptr)  OrientablePushButton (const QIcon &amp; icon, const QString &amp; text, QWidget * parent=nullptr)  OrientablePushButton::Orientation orientation () const void setOrientation (OrientablePushButton::Orientation orientation)  QSize sizeHint () const"},{"location":"flameshot/classOrientablePushButton/#public-functions-inherited-from-capturebutton","title":"Public Functions inherited from CaptureButton","text":"<p>See CaptureButton</p> Type Name CaptureButton () = delete CaptureButton (QWidget * parent=nullptr)  CaptureButton (const QString &amp; text, QWidget * parent=nullptr)  CaptureButton (const QIcon &amp; icon, const QString &amp; text, QWidget * parent=nullptr)  void setColor (const QColor &amp; c)  QString styleSheet () const"},{"location":"flameshot/classOrientablePushButton/#public-static-functions-inherited-from-capturebutton","title":"Public Static Functions inherited from CaptureButton","text":"<p>See CaptureButton</p> Type Name QString globalStyleSheet ()"},{"location":"flameshot/classOrientablePushButton/#protected-functions","title":"Protected Functions","text":"Type Name void paintEvent (QPaintEvent * event)"},{"location":"flameshot/classOrientablePushButton/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classOrientablePushButton/#enum-orientation","title":"enum Orientation","text":"<pre><code>enum OrientablePushButton::Orientation {\n    Horizontal,\n    VerticalTopToBottom,\n    VerticalBottomToTop\n};\n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classOrientablePushButton/#function-orientablepushbutton-13","title":"function OrientablePushButton [1/3]","text":"<pre><code>OrientablePushButton::OrientablePushButton (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#function-orientablepushbutton-23","title":"function OrientablePushButton [2/3]","text":"<pre><code>OrientablePushButton::OrientablePushButton (\n    const QString &amp; text,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#function-orientablepushbutton-33","title":"function OrientablePushButton [3/3]","text":"<pre><code>OrientablePushButton::OrientablePushButton (\n    const QIcon &amp; icon,\n    const QString &amp; text,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#function-orientation","title":"function orientation","text":"<pre><code>OrientablePushButton::Orientation OrientablePushButton::orientation () const\n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#function-setorientation","title":"function setOrientation","text":"<pre><code>void OrientablePushButton::setOrientation (\n    OrientablePushButton::Orientation orientation\n) \n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#function-sizehint","title":"function sizeHint","text":"<pre><code>QSize OrientablePushButton::sizeHint () const\n</code></pre>"},{"location":"flameshot/classOrientablePushButton/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classOrientablePushButton/#function-paintevent","title":"function paintEvent","text":"<pre><code>void OrientablePushButton::paintEvent (\n    QPaintEvent * event\n) \n</code></pre>"},{"location":"flameshot/classOverlayMessage/","title":"Class OverlayMessage","text":"<p>ClassList &gt; OverlayMessage</p> <p>Overlay a message in capture mode. More...</p> <ul> <li><code>#include &lt;overlaymessage.h&gt;</code></li> </ul> <p>Inherits the following classes: QLabel</p>"},{"location":"flameshot/classOverlayMessage/#public-functions","title":"Public Functions","text":"Type Name OverlayMessage () = delete"},{"location":"flameshot/classOverlayMessage/#public-static-functions","title":"Public Static Functions","text":"Type Name QString compileFromKeyMap (const QList&lt; QPair&lt; QString, QString &gt;&gt; &amp; map) Compile a message from a set of shortcuts and descriptions. void init (QWidget * parent, const QRect &amp; targetArea)  OverlayMessage * instance ()  void pop ()  void push (const QString &amp; msg) Push a message to the message stack. void pushKeyMap (const QList&lt; QPair&lt; QString, QString &gt;&gt; &amp; map)  void setVisibility (bool visible)"},{"location":"flameshot/classOverlayMessage/#detailed-description","title":"Detailed Description","text":"<p>The message must be initialized by calling <code>init</code> before it can be used. That can be done once per capture session. The class is a singleton.</p> <p>To change the active message call <code>push</code>. This will automatically show the widget. Previous messages won't be forgotten and will be reactivated after you call <code>pop</code>. You can show/hide the message using <code>setVisibility</code> (this won't push/pop anything).</p> <p>Note:</p> <p>You have to make sure that widgets pop the messages they pushed when they are closed, to avoid potential bugs and resource leaks. </p>"},{"location":"flameshot/classOverlayMessage/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classOverlayMessage/#function-overlaymessage-12","title":"function OverlayMessage [1/2]","text":"<pre><code>OverlayMessage::OverlayMessage () = delete\n</code></pre>"},{"location":"flameshot/classOverlayMessage/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classOverlayMessage/#function-compilefromkeymap","title":"function compileFromKeyMap","text":"<p>Compile a message from a set of shortcuts and descriptions. </p> <pre><code>static QString OverlayMessage::compileFromKeyMap (\n    const QList&lt; QPair&lt; QString, QString &gt;&gt; &amp; map\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>map</code> List of (shortcut, description) pairs </li> </ul>"},{"location":"flameshot/classOverlayMessage/#function-init","title":"function init","text":"<pre><code>static void OverlayMessage::init (\n    QWidget * parent,\n    const QRect &amp; targetArea\n) \n</code></pre>"},{"location":"flameshot/classOverlayMessage/#function-instance","title":"function instance","text":"<pre><code>static OverlayMessage * OverlayMessage::instance () \n</code></pre>"},{"location":"flameshot/classOverlayMessage/#function-pop","title":"function pop","text":"<pre><code>static void OverlayMessage::pop () \n</code></pre>"},{"location":"flameshot/classOverlayMessage/#function-push","title":"function push","text":"<p>Push a message to the message stack. </p> <pre><code>static void OverlayMessage::push (\n    const QString &amp; msg\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>msg</code> Message text formatted as rich text </li> </ul>"},{"location":"flameshot/classOverlayMessage/#function-pushkeymap","title":"function pushKeyMap","text":"<pre><code>static void OverlayMessage::pushKeyMap (\n    const QList&lt; QPair&lt; QString, QString &gt;&gt; &amp; map\n) \n</code></pre>"},{"location":"flameshot/classOverlayMessage/#function-setvisibility","title":"function setVisibility","text":"<pre><code>static void OverlayMessage::setVisibility (\n    bool visible\n) \n</code></pre>"},{"location":"flameshot/namespacePathInfo/","title":"Namespace PathInfo","text":"<p>Namespace List &gt; PathInfo</p>"},{"location":"flameshot/namespacePathInfo/#public-functions","title":"Public Functions","text":"Type Name const QString blackIconPath ()  QStringList translationsPaths ()  const QString whiteIconPath ()"},{"location":"flameshot/namespacePathInfo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/namespacePathInfo/#function-blackiconpath","title":"function blackIconPath","text":"<pre><code>const QString PathInfo::blackIconPath () \n</code></pre>"},{"location":"flameshot/namespacePathInfo/#function-translationspaths","title":"function translationsPaths","text":"<pre><code>QStringList PathInfo::translationsPaths () \n</code></pre>"},{"location":"flameshot/namespacePathInfo/#function-whiteiconpath","title":"function whiteIconPath","text":"<pre><code>const QString PathInfo::whiteIconPath () \n</code></pre>"},{"location":"flameshot/classPencilTool/","title":"Class PencilTool","text":"<p>ClassList &gt; PencilTool</p> <p>Inherits the following classes: AbstractPathTool</p>"},{"location":"flameshot/classPencilTool/#public-functions","title":"Public Functions","text":"Type Name PencilTool (QObject * parent=nullptr)  CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classPencilTool/#public-functions-inherited-from-abstractpathtool","title":"Public Functions inherited from AbstractPathTool","text":"<p>See AbstractPathTool</p> Type Name AbstractPathTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; mousePos) override const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classPencilTool/#protected-attributes-inherited-from-abstractpathtool","title":"Protected Attributes inherited from AbstractPathTool","text":"<p>See AbstractPathTool</p> Type Name QColor m_color int m_padding QRect m_pathArea QVector&lt; QPoint &gt; m_points QPoint m_pos"},{"location":"flameshot/classPencilTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classPencilTool/#protected-functions-inherited-from-abstractpathtool","title":"Protected Functions inherited from AbstractPathTool","text":"<p>See AbstractPathTool</p> Type Name void addPoint (const QPoint &amp; point)  void copyParams (const AbstractPathTool * from, AbstractPathTool * to)"},{"location":"flameshot/classPencilTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classPencilTool/#function-penciltool","title":"function PencilTool","text":"<pre><code>explicit PencilTool::PencilTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classPencilTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * PencilTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classPencilTool/#function-description","title":"function description","text":"<pre><code>QString PencilTool::description () override const\n</code></pre>"},{"location":"flameshot/classPencilTool/#function-icon","title":"function icon","text":"<pre><code>QIcon PencilTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classPencilTool/#function-name","title":"function name","text":"<pre><code>QString PencilTool::name () override const\n</code></pre>"},{"location":"flameshot/classPencilTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void PencilTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classPencilTool/#function-process","title":"function process","text":"<pre><code>void PencilTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classPencilTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classPencilTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type PencilTool::type () override const\n</code></pre>"},{"location":"flameshot/classPinTool/","title":"Class PinTool","text":"<p>ClassList &gt; PinTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classPinTool/#public-functions","title":"Public Functions","text":"Type Name PinTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classPinTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classPinTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classPinTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classPinTool/#function-pintool","title":"function PinTool","text":"<pre><code>explicit PinTool::PinTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classPinTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool PinTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classPinTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * PinTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classPinTool/#function-description","title":"function description","text":"<pre><code>QString PinTool::description () override const\n</code></pre>"},{"location":"flameshot/classPinTool/#function-icon","title":"function icon","text":"<pre><code>QIcon PinTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classPinTool/#function-name","title":"function name","text":"<pre><code>QString PinTool::name () override const\n</code></pre>"},{"location":"flameshot/classPinTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classPinTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type PinTool::type () override const\n</code></pre>"},{"location":"flameshot/classPinWidget/","title":"Class PinWidget","text":"<p>ClassList &gt; PinWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classPinWidget/#public-functions","title":"Public Functions","text":"Type Name PinWidget (const QPixmap &amp; pixmap, const QRect &amp; geometry, QWidget * parent=nullptr)"},{"location":"flameshot/classPinWidget/#protected-functions","title":"Protected Functions","text":"Type Name void enterEvent (QEvent *) override bool event (QEvent * event) override void keyPressEvent (QKeyEvent * event) override void leaveEvent (QEvent *) override void mouseDoubleClickEvent (QMouseEvent *) override void mouseMoveEvent (QMouseEvent * e) override void mousePressEvent (QMouseEvent * e) override void paintEvent (QPaintEvent * event) override"},{"location":"flameshot/classPinWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classPinWidget/#function-pinwidget","title":"function PinWidget","text":"<pre><code>explicit PinWidget::PinWidget (\n    const QPixmap &amp; pixmap,\n    const QRect &amp; geometry,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classPinWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classPinWidget/#function-enterevent","title":"function enterEvent","text":"<pre><code>void PinWidget::enterEvent (\n    QEvent *\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-event","title":"function event","text":"<pre><code>bool PinWidget::event (\n    QEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-keypressevent","title":"function keyPressEvent","text":"<pre><code>void PinWidget::keyPressEvent (\n    QKeyEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-leaveevent","title":"function leaveEvent","text":"<pre><code>void PinWidget::leaveEvent (\n    QEvent *\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-mousedoubleclickevent","title":"function mouseDoubleClickEvent","text":"<pre><code>void PinWidget::mouseDoubleClickEvent (\n    QMouseEvent *\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-mousemoveevent","title":"function mouseMoveEvent","text":"<pre><code>void PinWidget::mouseMoveEvent (\n    QMouseEvent * e\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-mousepressevent","title":"function mousePressEvent","text":"<pre><code>void PinWidget::mousePressEvent (\n    QMouseEvent * e\n) override\n</code></pre>"},{"location":"flameshot/classPinWidget/#function-paintevent","title":"function paintEvent","text":"<pre><code>void PinWidget::paintEvent (\n    QPaintEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classPixelateTool/","title":"Class PixelateTool","text":"<p>ClassList &gt; PixelateTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classPixelateTool/#public-functions","title":"Public Functions","text":"Type Name PixelateTool (QObject * parent=nullptr)  QRect boundingRect () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawSearchArea (QPainter &amp; painter, const QPixmap &amp; pixmap) override QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classPixelateTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classPixelateTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classPixelateTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classPixelateTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classPixelateTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classPixelateTool/#function-pixelatetool","title":"function PixelateTool","text":"<pre><code>explicit PixelateTool::PixelateTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect PixelateTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * PixelateTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-description","title":"function description","text":"<pre><code>QString PixelateTool::description () override const\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-drawsearcharea","title":"function drawSearchArea","text":"<pre><code>void PixelateTool::drawSearchArea (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-icon","title":"function icon","text":"<pre><code>QIcon PixelateTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-name","title":"function name","text":"<pre><code>QString PixelateTool::name () override const\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void PixelateTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classPixelateTool/#function-process","title":"function process","text":"<pre><code>void PixelateTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classPixelateTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classPixelateTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type PixelateTool::type () override const\n</code></pre>"},{"location":"flameshot/classQGuiAppCurrentScreen/","title":"Class QGuiAppCurrentScreen","text":"<p>ClassList &gt; QGuiAppCurrentScreen</p>"},{"location":"flameshot/classQGuiAppCurrentScreen/#public-functions","title":"Public Functions","text":"Type Name QGuiAppCurrentScreen ()  QScreen * currentScreen ()  QScreen * currentScreen (const QPoint &amp; pos)"},{"location":"flameshot/classQGuiAppCurrentScreen/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classQGuiAppCurrentScreen/#function-qguiappcurrentscreen","title":"function QGuiAppCurrentScreen","text":"<pre><code>explicit QGuiAppCurrentScreen::QGuiAppCurrentScreen () \n</code></pre>"},{"location":"flameshot/classQGuiAppCurrentScreen/#function-currentscreen-12","title":"function currentScreen [1/2]","text":"<pre><code>QScreen * QGuiAppCurrentScreen::currentScreen () \n</code></pre>"},{"location":"flameshot/classQGuiAppCurrentScreen/#function-currentscreen-22","title":"function currentScreen [2/2]","text":"<pre><code>QScreen * QGuiAppCurrentScreen::currentScreen (\n    const QPoint &amp; pos\n) \n</code></pre>"},{"location":"flameshot/classQSharedPointer/","title":"Class QSharedPointer","text":"<p>template &lt;class T class T&gt;</p> <p>ClassList &gt; QSharedPointer</p>"},{"location":"flameshot/classRectangleTool/","title":"Class RectangleTool","text":"<p>ClassList &gt; RectangleTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classRectangleTool/#public-functions","title":"Public Functions","text":"Type Name RectangleTool (QObject * parent=nullptr)  CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classRectangleTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classRectangleTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classRectangleTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classRectangleTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classRectangleTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classRectangleTool/#function-rectangletool","title":"function RectangleTool","text":"<pre><code>explicit RectangleTool::RectangleTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classRectangleTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * RectangleTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classRectangleTool/#function-description","title":"function description","text":"<pre><code>QString RectangleTool::description () override const\n</code></pre>"},{"location":"flameshot/classRectangleTool/#function-icon","title":"function icon","text":"<pre><code>QIcon RectangleTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classRectangleTool/#function-name","title":"function name","text":"<pre><code>QString RectangleTool::name () override const\n</code></pre>"},{"location":"flameshot/classRectangleTool/#function-process","title":"function process","text":"<pre><code>void RectangleTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classRectangleTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classRectangleTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type RectangleTool::type () override const\n</code></pre>"},{"location":"flameshot/classRedoTool/","title":"Class RedoTool","text":"<p>ClassList &gt; RedoTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classRedoTool/#public-functions","title":"Public Functions","text":"Type Name RedoTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classRedoTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classRedoTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classRedoTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classRedoTool/#function-redotool","title":"function RedoTool","text":"<pre><code>explicit RedoTool::RedoTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classRedoTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool RedoTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classRedoTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * RedoTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classRedoTool/#function-description","title":"function description","text":"<pre><code>QString RedoTool::description () override const\n</code></pre>"},{"location":"flameshot/classRedoTool/#function-icon","title":"function icon","text":"<pre><code>QIcon RedoTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classRedoTool/#function-name","title":"function name","text":"<pre><code>QString RedoTool::name () override const\n</code></pre>"},{"location":"flameshot/classRedoTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classRedoTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type RedoTool::type () override const\n</code></pre>"},{"location":"flameshot/classRegion/","title":"Class Region","text":"<p>ClassList &gt; Region</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classRegion/#public-functions","title":"Public Functions","text":"Type Name virtual bool check (const QVariant &amp; val) overrideCheck the value semantically."},{"location":"flameshot/classRegion/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classRegion/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classRegion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classRegion/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool Region::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classSaveFileExtension/","title":"Class SaveFileExtension","text":"<p>ClassList &gt; SaveFileExtension</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classSaveFileExtension/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classSaveFileExtension/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classSaveTool/","title":"Class SaveTool","text":"<p>ClassList &gt; SaveTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classSaveTool/#public-functions","title":"Public Functions","text":"Type Name SaveTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classSaveTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classSaveTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classSaveTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSaveTool/#function-savetool","title":"function SaveTool","text":"<pre><code>explicit SaveTool::SaveTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSaveTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool SaveTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classSaveTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * SaveTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classSaveTool/#function-description","title":"function description","text":"<pre><code>QString SaveTool::description () override const\n</code></pre>"},{"location":"flameshot/classSaveTool/#function-icon","title":"function icon","text":"<pre><code>QIcon SaveTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classSaveTool/#function-name","title":"function name","text":"<pre><code>QString SaveTool::name () override const\n</code></pre>"},{"location":"flameshot/classSaveTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classSaveTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type SaveTool::type () override const\n</code></pre>"},{"location":"flameshot/classScreenGrabber/","title":"Class ScreenGrabber","text":"<p>ClassList &gt; ScreenGrabber</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classScreenGrabber/#public-functions","title":"Public Functions","text":"Type Name ScreenGrabber (QObject * parent=nullptr)  QRect desktopGeometry ()  void freeDesktopPortal (bool &amp; ok, QPixmap &amp; res)  void generalGrimScreenshot (bool &amp; ok, QPixmap &amp; res)  QPixmap grabEntireDesktop (bool &amp; ok)  QPixmap grabScreen (QScreen * screenNumber, bool &amp; ok)  QRect screenGeometry (QScreen * screen)"},{"location":"flameshot/classScreenGrabber/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classScreenGrabber/#function-screengrabber","title":"function ScreenGrabber","text":"<pre><code>explicit ScreenGrabber::ScreenGrabber (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classScreenGrabber/#function-desktopgeometry","title":"function desktopGeometry","text":"<pre><code>QRect ScreenGrabber::desktopGeometry () \n</code></pre>"},{"location":"flameshot/classScreenGrabber/#function-freedesktopportal","title":"function freeDesktopPortal","text":"<pre><code>void ScreenGrabber::freeDesktopPortal (\n    bool &amp; ok,\n    QPixmap &amp; res\n) \n</code></pre>"},{"location":"flameshot/classScreenGrabber/#function-generalgrimscreenshot","title":"function generalGrimScreenshot","text":"<pre><code>void ScreenGrabber::generalGrimScreenshot (\n    bool &amp; ok,\n    QPixmap &amp; res\n) \n</code></pre>"},{"location":"flameshot/classScreenGrabber/#function-grabentiredesktop","title":"function grabEntireDesktop","text":"<pre><code>QPixmap ScreenGrabber::grabEntireDesktop (\n    bool &amp; ok\n) \n</code></pre>"},{"location":"flameshot/classScreenGrabber/#function-grabscreen","title":"function grabScreen","text":"<pre><code>QPixmap ScreenGrabber::grabScreen (\n    QScreen * screenNumber,\n    bool &amp; ok\n) \n</code></pre>"},{"location":"flameshot/classScreenGrabber/#function-screengeometry","title":"function screenGeometry","text":"<pre><code>QRect ScreenGrabber::screenGeometry (\n    QScreen * screen\n) \n</code></pre>"},{"location":"flameshot/classSelectionTool/","title":"Class SelectionTool","text":"<p>ClassList &gt; SelectionTool</p> <p>Inherits the following classes: AbstractTwoPointTool</p>"},{"location":"flameshot/classSelectionTool/#public-functions","title":"Public Functions","text":"Type Name SelectionTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override"},{"location":"flameshot/classSelectionTool/#public-functions-inherited-from-abstracttwopointtool","title":"Public Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name AbstractTwoPointTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const const QColor &amp; color ()  bool isSelectable () override const bool isValid () override const QRect mousePreviewRect (const CaptureContext &amp; context) override const void move (const QPoint &amp; pos) override void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPair&lt; QPoint, QPoint &gt; points () const const QPoint * pos () override bool showMousePreview () override const int size () override const"},{"location":"flameshot/classSelectionTool/#protected-attributes-inherited-from-abstracttwopointtool","title":"Protected Attributes inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name bool m_supportsDiagonalAdj   = = false bool m_supportsOrthogonalAdj   = = false"},{"location":"flameshot/classSelectionTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classSelectionTool/#protected-functions-inherited-from-abstracttwopointtool","title":"Protected Functions inherited from AbstractTwoPointTool","text":"<p>See AbstractTwoPointTool</p> Type Name void copyParams (const AbstractTwoPointTool * from, AbstractTwoPointTool * to)  void setPadding (int padding)"},{"location":"flameshot/classSelectionTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSelectionTool/#function-selectiontool","title":"function SelectionTool","text":"<pre><code>explicit SelectionTool::SelectionTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSelectionTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool SelectionTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classSelectionTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * SelectionTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classSelectionTool/#function-description","title":"function description","text":"<pre><code>QString SelectionTool::description () override const\n</code></pre>"},{"location":"flameshot/classSelectionTool/#function-icon","title":"function icon","text":"<pre><code>QIcon SelectionTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classSelectionTool/#function-name","title":"function name","text":"<pre><code>QString SelectionTool::name () override const\n</code></pre>"},{"location":"flameshot/classSelectionTool/#function-process","title":"function process","text":"<pre><code>void SelectionTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classSelectionTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classSelectionTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type SelectionTool::type () override const\n</code></pre>"},{"location":"flameshot/classSelectionWidget/","title":"Class SelectionWidget","text":"<p>ClassList &gt; SelectionWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classSelectionWidget/#public-types","title":"Public Types","text":"Type Name enum SideType"},{"location":"flameshot/classSelectionWidget/#public-functions","title":"Public Functions","text":"Type Name SelectionWidget (QColor c, QWidget * parent=nullptr)  QRect fullGeometry () const QRect geometry () const SideType getMouseSide (const QPoint &amp; mousePos) constGet the side where the mouse cursor is. QVector&lt; QRect &gt; handlerAreas ()  QRect rect () const void setGeometry (const QRect &amp; r)  void setGeometryAnimated (const QRect &amp; r)  void setIdleCentralCursor (const QCursor &amp; cursor)  void setIgnoreMouse (bool ignore)"},{"location":"flameshot/classSelectionWidget/#protected-functions","title":"Protected Functions","text":"Type Name bool eventFilter (QObject * obj, QEvent * event) override void hideEvent (QHideEvent *) override void moveEvent (QMoveEvent *) override void paintEvent (QPaintEvent *) override void parentMouseMoveEvent (QMouseEvent * e)  void parentMousePressEvent (QMouseEvent * e)  void parentMouseReleaseEvent (QMouseEvent * e)  void resizeEvent (QResizeEvent *) override void showEvent (QShowEvent *) override"},{"location":"flameshot/classSelectionWidget/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/classSelectionWidget/#enum-sidetype","title":"enum SideType","text":"<pre><code>enum SelectionWidget::SideType {\n    NO_SIDE = 0,\n    TOP_SIDE = 0b0001,\n    BOTTOM_SIDE = 0b0010,\n    RIGHT_SIDE = 0b0100,\n    LEFT_SIDE = 0b1000,\n    TOPLEFT_SIDE = TOP_SIDE | LEFT_SIDE,\n    BOTTOMLEFT_SIDE = BOTTOM_SIDE | LEFT_SIDE,\n    TOPRIGHT_SIDE = TOP_SIDE | RIGHT_SIDE,\n    BOTTOMRIGHT_SIDE = BOTTOM_SIDE | RIGHT_SIDE,\n    CENTER = 0b10000\n};\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSelectionWidget/#function-selectionwidget","title":"function SelectionWidget","text":"<pre><code>explicit SelectionWidget::SelectionWidget (\n    QColor c,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-fullgeometry","title":"function fullGeometry","text":"<pre><code>QRect SelectionWidget::fullGeometry () const\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-geometry","title":"function geometry","text":"<pre><code>QRect SelectionWidget::geometry () const\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-getmouseside","title":"function getMouseSide","text":"<p>Get the side where the mouse cursor is. </p> <pre><code>SideType SelectionWidget::getMouseSide (\n    const QPoint &amp; mousePos\n) const\n</code></pre> <p>Parameters:</p> <ul> <li><code>mousePos</code> Mouse cursor position relative to the parent widget. </li> </ul>"},{"location":"flameshot/classSelectionWidget/#function-handlerareas","title":"function handlerAreas","text":"<pre><code>QVector&lt; QRect &gt; SelectionWidget::handlerAreas () \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-rect","title":"function rect","text":"<pre><code>QRect SelectionWidget::rect () const\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-setgeometry","title":"function setGeometry","text":"<pre><code>void SelectionWidget::setGeometry (\n    const QRect &amp; r\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-setgeometryanimated","title":"function setGeometryAnimated","text":"<pre><code>void SelectionWidget::setGeometryAnimated (\n    const QRect &amp; r\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-setidlecentralcursor","title":"function setIdleCentralCursor","text":"<pre><code>void SelectionWidget::setIdleCentralCursor (\n    const QCursor &amp; cursor\n) \n</code></pre> <p>Set the cursor that will be active when the mouse is inside the selection and the mouse is not clicked. </p>"},{"location":"flameshot/classSelectionWidget/#function-setignoremouse","title":"function setIgnoreMouse","text":"<pre><code>void SelectionWidget::setIgnoreMouse (\n    bool ignore\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classSelectionWidget/#function-eventfilter","title":"function eventFilter","text":"<pre><code>bool SelectionWidget::eventFilter (\n    QObject * obj,\n    QEvent * event\n) override\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-hideevent","title":"function hideEvent","text":"<pre><code>void SelectionWidget::hideEvent (\n    QHideEvent *\n) override\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-moveevent","title":"function moveEvent","text":"<pre><code>void SelectionWidget::moveEvent (\n    QMoveEvent *\n) override\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-paintevent","title":"function paintEvent","text":"<pre><code>void SelectionWidget::paintEvent (\n    QPaintEvent *\n) override\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-parentmousemoveevent","title":"function parentMouseMoveEvent","text":"<pre><code>void SelectionWidget::parentMouseMoveEvent (\n    QMouseEvent * e\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-parentmousepressevent","title":"function parentMousePressEvent","text":"<pre><code>void SelectionWidget::parentMousePressEvent (\n    QMouseEvent * e\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-parentmousereleaseevent","title":"function parentMouseReleaseEvent","text":"<pre><code>void SelectionWidget::parentMouseReleaseEvent (\n    QMouseEvent * e\n) \n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void SelectionWidget::resizeEvent (\n    QResizeEvent *\n) override\n</code></pre>"},{"location":"flameshot/classSelectionWidget/#function-showevent","title":"function showEvent","text":"<pre><code>void SelectionWidget::showEvent (\n    QShowEvent *\n) override\n</code></pre>"},{"location":"flameshot/classSetShortcutDialog/","title":"Class SetShortcutDialog","text":"<p>ClassList &gt; SetShortcutDialog</p> <p>Inherits the following classes: QDialog</p>"},{"location":"flameshot/classSetShortcutDialog/#public-functions","title":"Public Functions","text":"Type Name SetShortcutDialog (QDialog * parent=nullptr, const QString &amp; shortcutName=\"\")  void keyPressEvent (QKeyEvent * ke)  void keyReleaseEvent (QKeyEvent * event)  const QKeySequence &amp; shortcut ()"},{"location":"flameshot/classSetShortcutDialog/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSetShortcutDialog/#function-setshortcutdialog","title":"function SetShortcutDialog","text":"<pre><code>explicit SetShortcutDialog::SetShortcutDialog (\n    QDialog * parent=nullptr,\n    const QString &amp; shortcutName=\"\"\n) \n</code></pre>"},{"location":"flameshot/classSetShortcutDialog/#function-keypressevent","title":"function keyPressEvent","text":"<pre><code>void SetShortcutDialog::keyPressEvent (\n    QKeyEvent * ke\n) \n</code></pre>"},{"location":"flameshot/classSetShortcutDialog/#function-keyreleaseevent","title":"function keyReleaseEvent","text":"<pre><code>void SetShortcutDialog::keyReleaseEvent (\n    QKeyEvent * event\n) \n</code></pre>"},{"location":"flameshot/classSetShortcutDialog/#function-shortcut","title":"function shortcut","text":"<pre><code>const QKeySequence &amp; SetShortcutDialog::shortcut () \n</code></pre>"},{"location":"flameshot/classShortcutsWidget/","title":"Class ShortcutsWidget","text":"<p>ClassList &gt; ShortcutsWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classShortcutsWidget/#public-functions","title":"Public Functions","text":"Type Name ShortcutsWidget (QWidget * parent=nullptr)"},{"location":"flameshot/classShortcutsWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classShortcutsWidget/#function-shortcutswidget","title":"function ShortcutsWidget","text":"<pre><code>explicit ShortcutsWidget::ShortcutsWidget (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSidePanelWidget/","title":"Class SidePanelWidget","text":"<p>ClassList &gt; SidePanelWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classSidePanelWidget/#public-functions","title":"Public Functions","text":"Type Name SidePanelWidget (QPixmap * p, QWidget * parent=nullptr)"},{"location":"flameshot/classSidePanelWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSidePanelWidget/#function-sidepanelwidget","title":"function SidePanelWidget","text":"<pre><code>explicit SidePanelWidget::SidePanelWidget (\n    QPixmap * p,\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/","title":"Class SizeDecreaseTool","text":"<p>ClassList &gt; SizeDecreaseTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classSizeDecreaseTool/#public-functions","title":"Public Functions","text":"Type Name SizeDecreaseTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classSizeDecreaseTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classSizeDecreaseTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classSizeDecreaseTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSizeDecreaseTool/#function-sizedecreasetool","title":"function SizeDecreaseTool","text":"<pre><code>explicit SizeDecreaseTool::SizeDecreaseTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool SizeDecreaseTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * SizeDecreaseTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/#function-description","title":"function description","text":"<pre><code>QString SizeDecreaseTool::description () override const\n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/#function-icon","title":"function icon","text":"<pre><code>QIcon SizeDecreaseTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/#function-name","title":"function name","text":"<pre><code>QString SizeDecreaseTool::name () override const\n</code></pre>"},{"location":"flameshot/classSizeDecreaseTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classSizeDecreaseTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type SizeDecreaseTool::type () override const\n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/","title":"Class SizeIncreaseTool","text":"<p>ClassList &gt; SizeIncreaseTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classSizeIncreaseTool/#public-functions","title":"Public Functions","text":"Type Name SizeIncreaseTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classSizeIncreaseTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classSizeIncreaseTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classSizeIncreaseTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSizeIncreaseTool/#function-sizeincreasetool","title":"function SizeIncreaseTool","text":"<pre><code>explicit SizeIncreaseTool::SizeIncreaseTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool SizeIncreaseTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * SizeIncreaseTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/#function-description","title":"function description","text":"<pre><code>QString SizeIncreaseTool::description () override const\n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/#function-icon","title":"function icon","text":"<pre><code>QIcon SizeIncreaseTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/#function-name","title":"function name","text":"<pre><code>QString SizeIncreaseTool::name () override const\n</code></pre>"},{"location":"flameshot/classSizeIncreaseTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classSizeIncreaseTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type SizeIncreaseTool::type () override const\n</code></pre>"},{"location":"flameshot/classStrftimeChooserWidget/","title":"Class StrftimeChooserWidget","text":"<p>ClassList &gt; StrftimeChooserWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classStrftimeChooserWidget/#public-functions","title":"Public Functions","text":"Type Name StrftimeChooserWidget (QWidget * parent=nullptr)"},{"location":"flameshot/classStrftimeChooserWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classStrftimeChooserWidget/#function-strftimechooserwidget","title":"function StrftimeChooserWidget","text":"<pre><code>explicit StrftimeChooserWidget::StrftimeChooserWidget (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classString/","title":"Class String","text":"<p>ClassList &gt; String</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classString/#public-functions","title":"Public Functions","text":"Type Name String (QString def)  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value)."},{"location":"flameshot/classString/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classString/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classString/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classString/#function-string","title":"function String","text":"<pre><code>String::String (\n    QString def\n) \n</code></pre>"},{"location":"flameshot/classString/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool String::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classString/#function-expected","title":"function expected","text":"<pre><code>virtual QString String::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classString/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant String::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classStyleOverride/","title":"Class StyleOverride","text":"<p>ClassList &gt; StyleOverride</p> <p>Inherits the following classes: QProxyStyle</p>"},{"location":"flameshot/classStyleOverride/#public-functions","title":"Public Functions","text":"Type Name int styleHint (StyleHint hint, const QStyleOption * option=Q_NULLPTR, const QWidget * widget=Q_NULLPTR, QStyleHintReturn * returnData=Q_NULLPTR) const"},{"location":"flameshot/classStyleOverride/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classStyleOverride/#function-stylehint","title":"function styleHint","text":"<pre><code>int StyleOverride::styleHint (\n    StyleHint hint,\n    const QStyleOption * option=Q_NULLPTR,\n    const QWidget * widget=Q_NULLPTR,\n    QStyleHintReturn * returnData=Q_NULLPTR\n) const\n</code></pre>"},{"location":"flameshot/classSystemNotification/","title":"Class SystemNotification","text":"<p>ClassList &gt; SystemNotification</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classSystemNotification/#public-functions","title":"Public Functions","text":"Type Name SystemNotification (QObject * parent=nullptr)  void sendMessage (const QString &amp; text, const QString &amp; savePath={})  void sendMessage (const QString &amp; text, const QString &amp; title, const QString &amp; savePath, const int timeout=5000)"},{"location":"flameshot/classSystemNotification/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classSystemNotification/#function-systemnotification","title":"function SystemNotification","text":"<pre><code>explicit SystemNotification::SystemNotification (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classSystemNotification/#function-sendmessage-12","title":"function sendMessage [1/2]","text":"<pre><code>void SystemNotification::sendMessage (\n    const QString &amp; text,\n    const QString &amp; savePath={}\n) \n</code></pre>"},{"location":"flameshot/classSystemNotification/#function-sendmessage-22","title":"function sendMessage [2/2]","text":"<pre><code>void SystemNotification::sendMessage (\n    const QString &amp; text,\n    const QString &amp; title,\n    const QString &amp; savePath,\n    const int timeout=5000\n) \n</code></pre>"},{"location":"flameshot/structTerminalApp/","title":"Struct TerminalApp","text":"<p>ClassList &gt; TerminalApp</p>"},{"location":"flameshot/structTerminalApp/#public-attributes","title":"Public Attributes","text":"Type Name QString arg QString name"},{"location":"flameshot/structTerminalApp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/structTerminalApp/#variable-arg","title":"variable arg","text":"<pre><code>QString TerminalApp::arg;\n</code></pre>"},{"location":"flameshot/structTerminalApp/#variable-name","title":"variable name","text":"<pre><code>QString TerminalApp::name;\n</code></pre>"},{"location":"flameshot/classTerminalLauncher/","title":"Class TerminalLauncher","text":"<p>ClassList &gt; TerminalLauncher</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classTerminalLauncher/#public-functions","title":"Public Functions","text":"Type Name TerminalLauncher (QObject * parent=nullptr)"},{"location":"flameshot/classTerminalLauncher/#public-static-functions","title":"Public Static Functions","text":"Type Name bool launchDetached (const QString &amp; command)"},{"location":"flameshot/classTerminalLauncher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classTerminalLauncher/#function-terminallauncher","title":"function TerminalLauncher","text":"<pre><code>explicit TerminalLauncher::TerminalLauncher (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classTerminalLauncher/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classTerminalLauncher/#function-launchdetached","title":"function launchDetached","text":"<pre><code>static bool TerminalLauncher::launchDetached (\n    const QString &amp; command\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/","title":"Class TextConfig","text":"<p>ClassList &gt; TextConfig</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classTextConfig/#public-functions","title":"Public Functions","text":"Type Name TextConfig (QWidget * parent=nullptr)  void setFontFamily (const QString &amp; fontFamily)  void setItalic (bool italic)  void setStrikeOut (bool strikeout)  void setTextAlignment (Qt::AlignmentFlag alignment)  void setUnderline (bool underline)  void setWeight (int weight)"},{"location":"flameshot/classTextConfig/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classTextConfig/#function-textconfig","title":"function TextConfig","text":"<pre><code>explicit TextConfig::TextConfig (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/#function-setfontfamily","title":"function setFontFamily","text":"<pre><code>void TextConfig::setFontFamily (\n    const QString &amp; fontFamily\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/#function-setitalic","title":"function setItalic","text":"<pre><code>void TextConfig::setItalic (\n    bool italic\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/#function-setstrikeout","title":"function setStrikeOut","text":"<pre><code>void TextConfig::setStrikeOut (\n    bool strikeout\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/#function-settextalignment","title":"function setTextAlignment","text":"<pre><code>void TextConfig::setTextAlignment (\n    Qt::AlignmentFlag alignment\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/#function-setunderline","title":"function setUnderline","text":"<pre><code>void TextConfig::setUnderline (\n    bool underline\n) \n</code></pre>"},{"location":"flameshot/classTextConfig/#function-setweight","title":"function setWeight","text":"<pre><code>void TextConfig::setWeight (\n    int weight\n) \n</code></pre>"},{"location":"flameshot/classTextTool/","title":"Class TextTool","text":"<p>ClassList &gt; TextTool</p> <p>Inherits the following classes: CaptureTool</p>"},{"location":"flameshot/classTextTool/#public-functions","title":"Public Functions","text":"Type Name TextTool (QObject * parent=nullptr)  QRect boundingRect () override const bool closeOnButtonPressed () override const QWidget * configurationWidget () override CaptureTool * copy (QObject * parent=nullptr) override QString description () override const void drawObjectSelection (QPainter &amp; painter) override QIcon icon (const QColor &amp; background, bool inEditor) override const QString info () override bool isChanged () override bool isSelectable () override const bool isValid () override const void move (const QPoint &amp; pos) override QString name () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override const QPoint * pos () override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override void setEditMode (bool editMode) override bool showMousePreview () override const QWidget * widget () override ~TextTool () override"},{"location":"flameshot/classTextTool/#protected-functions","title":"Protected Functions","text":"Type Name void copyParams (const TextTool * from, TextTool * to)  CaptureTool::Type type () override const"},{"location":"flameshot/classTextTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classTextTool/#function-texttool","title":"function TextTool","text":"<pre><code>explicit TextTool::TextTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classTextTool/#function-boundingrect","title":"function boundingRect","text":"<pre><code>QRect TextTool::boundingRect () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool TextTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-configurationwidget","title":"function configurationWidget","text":"<pre><code>QWidget * TextTool::configurationWidget () override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * TextTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-description","title":"function description","text":"<pre><code>QString TextTool::description () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-drawobjectselection","title":"function drawObjectSelection","text":"<pre><code>void TextTool::drawObjectSelection (\n    QPainter &amp; painter\n) override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-icon","title":"function icon","text":"<pre><code>QIcon TextTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-info","title":"function info","text":"<pre><code>QString TextTool::info () override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-ischanged","title":"function isChanged","text":"<pre><code>bool TextTool::isChanged () override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-isselectable","title":"function isSelectable","text":"<pre><code>bool TextTool::isSelectable () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-isvalid","title":"function isValid","text":"<pre><code>bool TextTool::isValid () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-move","title":"function move","text":"<pre><code>void TextTool::move (\n    const QPoint &amp; pos\n) override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-name","title":"function name","text":"<pre><code>QString TextTool::name () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-paintmousepreview","title":"function paintMousePreview","text":"<pre><code>void TextTool::paintMousePreview (\n    QPainter &amp; painter,\n    const CaptureContext &amp; context\n) override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-pos","title":"function pos","text":"<pre><code>const QPoint * TextTool::pos () override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-process","title":"function process","text":"<pre><code>void TextTool::process (\n    QPainter &amp; painter,\n    const QPixmap &amp; pixmap\n) override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-seteditmode","title":"function setEditMode","text":"<pre><code>void TextTool::setEditMode (\n    bool editMode\n) override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-showmousepreview","title":"function showMousePreview","text":"<pre><code>bool TextTool::showMousePreview () override const\n</code></pre>"},{"location":"flameshot/classTextTool/#function-widget","title":"function widget","text":"<pre><code>QWidget * TextTool::widget () override\n</code></pre>"},{"location":"flameshot/classTextTool/#function-texttool_1","title":"function ~TextTool","text":"<pre><code>TextTool::~TextTool () override\n</code></pre>"},{"location":"flameshot/classTextTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classTextTool/#function-copyparams","title":"function copyParams","text":"<pre><code>void TextTool::copyParams (\n    const TextTool * from,\n    TextTool * to\n) \n</code></pre>"},{"location":"flameshot/classTextTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type TextTool::type () override const\n</code></pre>"},{"location":"flameshot/classTextWidget/","title":"Class TextWidget","text":"<p>ClassList &gt; TextWidget</p> <p>Inherits the following classes: QTextEdit</p>"},{"location":"flameshot/classTextWidget/#public-functions","title":"Public Functions","text":"Type Name TextWidget (QWidget * parent=nullptr)  void adjustSize ()  void setFont (const QFont &amp; f)"},{"location":"flameshot/classTextWidget/#protected-functions","title":"Protected Functions","text":"Type Name void resizeEvent (QResizeEvent * e)  void showEvent (QShowEvent * e)"},{"location":"flameshot/classTextWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classTextWidget/#function-textwidget","title":"function TextWidget","text":"<pre><code>explicit TextWidget::TextWidget (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classTextWidget/#function-adjustsize","title":"function adjustSize","text":"<pre><code>void TextWidget::adjustSize () \n</code></pre>"},{"location":"flameshot/classTextWidget/#function-setfont","title":"function setFont","text":"<pre><code>void TextWidget::setFont (\n    const QFont &amp; f\n) \n</code></pre>"},{"location":"flameshot/classTextWidget/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classTextWidget/#function-resizeevent","title":"function resizeEvent","text":"<pre><code>void TextWidget::resizeEvent (\n    QResizeEvent * e\n) \n</code></pre>"},{"location":"flameshot/classTextWidget/#function-showevent","title":"function showEvent","text":"<pre><code>void TextWidget::showEvent (\n    QShowEvent * e\n) \n</code></pre>"},{"location":"flameshot/classToolFactory/","title":"Class ToolFactory","text":"<p>ClassList &gt; ToolFactory</p> <p>Inherits the following classes: QObject</p>"},{"location":"flameshot/classToolFactory/#public-functions","title":"Public Functions","text":"Type Name CaptureTool * CreateTool (CaptureTool::Type t, QObject * parent=nullptr)  ToolFactory (QObject * parent=nullptr)  ToolFactory (const ToolFactory &amp;) = delete ToolFactory &amp; operator= (const ToolFactory &amp;) = delete"},{"location":"flameshot/classToolFactory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classToolFactory/#function-createtool","title":"function CreateTool","text":"<pre><code>CaptureTool * ToolFactory::CreateTool (\n    CaptureTool::Type t,\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classToolFactory/#function-toolfactory-12","title":"function ToolFactory [1/2]","text":"<pre><code>explicit ToolFactory::ToolFactory (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classToolFactory/#function-toolfactory-22","title":"function ToolFactory [2/2]","text":"<pre><code>ToolFactory::ToolFactory (\n    const ToolFactory &amp;\n) = delete\n</code></pre>"},{"location":"flameshot/classToolFactory/#function-operator","title":"function operator=","text":"<pre><code>ToolFactory &amp; ToolFactory::operator= (\n    const ToolFactory &amp;\n) = delete\n</code></pre>"},{"location":"flameshot/classTrayIcon/","title":"Class TrayIcon","text":"<p>ClassList &gt; TrayIcon</p> <p>Inherits the following classes: QSystemTrayIcon</p>"},{"location":"flameshot/classTrayIcon/#public-functions","title":"Public Functions","text":"Type Name TrayIcon (QObject * parent=nullptr)  QAction * appUpdates ()  virtual ~TrayIcon ()"},{"location":"flameshot/classTrayIcon/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classTrayIcon/#function-trayicon","title":"function TrayIcon","text":"<pre><code>TrayIcon::TrayIcon (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classTrayIcon/#function-appupdates","title":"function appUpdates","text":"<pre><code>QAction * TrayIcon::appUpdates () \n</code></pre>"},{"location":"flameshot/classTrayIcon/#function-trayicon_1","title":"function ~TrayIcon","text":"<pre><code>virtual TrayIcon::~TrayIcon () \n</code></pre>"},{"location":"flameshot/classUIcolorEditor/","title":"Class UIcolorEditor","text":"<p>ClassList &gt; UIcolorEditor</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classUIcolorEditor/#public-functions","title":"Public Functions","text":"Type Name UIcolorEditor (QWidget * parent=nullptr)"},{"location":"flameshot/classUIcolorEditor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUIcolorEditor/#function-uicoloreditor","title":"function UIcolorEditor","text":"<pre><code>explicit UIcolorEditor::UIcolorEditor (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/namespaceUi/","title":"Namespace Ui","text":"<p>Namespace List &gt; Ui</p>"},{"location":"flameshot/classUndoTool/","title":"Class UndoTool","text":"<p>ClassList &gt; UndoTool</p> <p>Inherits the following classes: AbstractActionTool</p>"},{"location":"flameshot/classUndoTool/#public-functions","title":"Public Functions","text":"Type Name UndoTool (QObject * parent=nullptr)  bool closeOnButtonPressed () override const CaptureTool * copy (QObject * parent=nullptr) override QString description () override const QIcon icon (const QColor &amp; background, bool inEditor) override const QString name () override const"},{"location":"flameshot/classUndoTool/#public-functions-inherited-from-abstractactiontool","title":"Public Functions inherited from AbstractActionTool","text":"<p>See AbstractActionTool</p> Type Name AbstractActionTool (QObject * parent=nullptr)  QRect boundingRect () override const bool isSelectable () override const bool isValid () override const void paintMousePreview (QPainter &amp; painter, const CaptureContext &amp; context) override void process (QPainter &amp; painter, const QPixmap &amp; pixmap) override bool showMousePreview () override const"},{"location":"flameshot/classUndoTool/#protected-functions","title":"Protected Functions","text":"Type Name CaptureTool::Type type () override const"},{"location":"flameshot/classUndoTool/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUndoTool/#function-undotool","title":"function UndoTool","text":"<pre><code>explicit UndoTool::UndoTool (\n    QObject * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classUndoTool/#function-closeonbuttonpressed","title":"function closeOnButtonPressed","text":"<pre><code>bool UndoTool::closeOnButtonPressed () override const\n</code></pre>"},{"location":"flameshot/classUndoTool/#function-copy","title":"function copy","text":"<pre><code>CaptureTool * UndoTool::copy (\n    QObject * parent=nullptr\n) override\n</code></pre>"},{"location":"flameshot/classUndoTool/#function-description","title":"function description","text":"<pre><code>QString UndoTool::description () override const\n</code></pre>"},{"location":"flameshot/classUndoTool/#function-icon","title":"function icon","text":"<pre><code>QIcon UndoTool::icon (\n    const QColor &amp; background,\n    bool inEditor\n) override const\n</code></pre>"},{"location":"flameshot/classUndoTool/#function-name","title":"function name","text":"<pre><code>QString UndoTool::name () override const\n</code></pre>"},{"location":"flameshot/classUndoTool/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classUndoTool/#function-type","title":"function type","text":"<pre><code>CaptureTool::Type UndoTool::type () override const\n</code></pre>"},{"location":"flameshot/classUpdateNotificationWidget/","title":"Class UpdateNotificationWidget","text":"<p>ClassList &gt; UpdateNotificationWidget</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classUpdateNotificationWidget/#public-functions","title":"Public Functions","text":"Type Name UpdateNotificationWidget (QWidget * parent, const QString &amp; appLatestVersion, QString appLatestUrl)  void hide ()  void setAppLatestVersion (const QString &amp; latestVersion)  void show ()"},{"location":"flameshot/classUpdateNotificationWidget/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUpdateNotificationWidget/#function-updatenotificationwidget","title":"function UpdateNotificationWidget","text":"<pre><code>explicit UpdateNotificationWidget::UpdateNotificationWidget (\n    QWidget * parent,\n    const QString &amp; appLatestVersion,\n    QString appLatestUrl\n) \n</code></pre>"},{"location":"flameshot/classUpdateNotificationWidget/#function-hide","title":"function hide","text":"<pre><code>void UpdateNotificationWidget::hide () \n</code></pre>"},{"location":"flameshot/classUpdateNotificationWidget/#function-setapplatestversion","title":"function setAppLatestVersion","text":"<pre><code>void UpdateNotificationWidget::setAppLatestVersion (\n    const QString &amp; latestVersion\n) \n</code></pre>"},{"location":"flameshot/classUpdateNotificationWidget/#function-show","title":"function show","text":"<pre><code>void UpdateNotificationWidget::show () \n</code></pre>"},{"location":"flameshot/classUploadHistory/","title":"Class UploadHistory","text":"<p>ClassList &gt; UploadHistory</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classUploadHistory/#public-functions","title":"Public Functions","text":"Type Name UploadHistory (QWidget * parent=nullptr)  void loadHistory ()  ~UploadHistory ()"},{"location":"flameshot/classUploadHistory/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUploadHistory/#function-uploadhistory","title":"function UploadHistory","text":"<pre><code>explicit UploadHistory::UploadHistory (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classUploadHistory/#function-loadhistory","title":"function loadHistory","text":"<pre><code>void UploadHistory::loadHistory () \n</code></pre>"},{"location":"flameshot/classUploadHistory/#function-uploadhistory_1","title":"function ~UploadHistory","text":"<pre><code>UploadHistory::~UploadHistory () \n</code></pre>"},{"location":"flameshot/classUploadLineItem/","title":"Class UploadLineItem","text":"<p>ClassList &gt; UploadLineItem</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classUploadLineItem/#public-functions","title":"Public Functions","text":"Type Name UploadLineItem (QWidget * parent, QPixmap const &amp; preview, QString const &amp; timestamp, QString const &amp; url, QString const &amp; fullFileName, HistoryFileName const &amp; unpackFileName)  ~UploadLineItem ()"},{"location":"flameshot/classUploadLineItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUploadLineItem/#function-uploadlineitem","title":"function UploadLineItem","text":"<pre><code>UploadLineItem::UploadLineItem (\n    QWidget * parent,\n    QPixmap const &amp; preview,\n    QString const &amp; timestamp,\n    QString const &amp; url,\n    QString const &amp; fullFileName,\n    HistoryFileName const &amp; unpackFileName\n) \n</code></pre>"},{"location":"flameshot/classUploadLineItem/#function-uploadlineitem_1","title":"function ~UploadLineItem","text":"<pre><code>UploadLineItem::~UploadLineItem () \n</code></pre>"},{"location":"flameshot/classUserColors/","title":"Class UserColors","text":"<p>ClassList &gt; UserColors</p> <p>Inherits the following classes: ValueHandler</p>"},{"location":"flameshot/classUserColors/#public-functions","title":"Public Functions","text":"Type Name UserColors (int min, int max)  virtual bool check (const QVariant &amp; val) overrideCheck the value semantically. virtual QString expected () overrideThe expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () overrideFallback value (default value). virtual QVariant process (const QVariant &amp; val) overrideProcess a value, presuming it is a valid <code>QVariant</code> . virtual QVariant representation (const QVariant &amp; val) overrideReturn the representation of the value in the config file."},{"location":"flameshot/classUserColors/#public-functions-inherited-from-valuehandler","title":"Public Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classUserColors/#protected-functions-inherited-from-valuehandler","title":"Protected Functions inherited from ValueHandler","text":"<p>See ValueHandler</p> Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classUserColors/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUserColors/#function-usercolors","title":"function UserColors","text":"<pre><code>UserColors::UserColors (\n    int min,\n    int max\n) \n</code></pre>"},{"location":"flameshot/classUserColors/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool UserColors::check (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p> <p>Implements ValueHandler::check</p>"},{"location":"flameshot/classUserColors/#function-expected","title":"function expected","text":"<pre><code>virtual QString UserColors::expected () override\n</code></pre> <p>Implements ValueHandler::expected</p>"},{"location":"flameshot/classUserColors/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant UserColors::fallback () override\n</code></pre> <p>Implements ValueHandler::fallback</p>"},{"location":"flameshot/classUserColors/#function-process","title":"function process","text":"<p>Process a value, presuming it is a valid <code>QVariant</code> .</p> <pre><code>virtual QVariant UserColors::process (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>The processed value </p> <p>Note:</p> <p>You will usually want to override this. In rare cases, you may want to override <code>value</code>. </p> <p>Implements ValueHandler::process</p>"},{"location":"flameshot/classUserColors/#function-representation","title":"function representation","text":"<p>Return the representation of the value in the config file. </p> <pre><code>virtual QVariant UserColors::representation (\n    const QVariant &amp; val\n) override\n</code></pre> <p>Override this if you want to write the value in a different format than the one provided by <code>QVariant</code>. </p> <p>Implements ValueHandler::representation</p>"},{"location":"flameshot/classUtilityPanel/","title":"Class UtilityPanel","text":"<p>ClassList &gt; UtilityPanel</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classUtilityPanel/#public-functions","title":"Public Functions","text":"Type Name UtilityPanel (CaptureWidget * captureWidget)  int activeLayerIndex ()  void clearToolWidget ()  void fillCaptureTools (const QList&lt; QPointer&lt; CaptureTool &gt;&gt; &amp; captureToolObjectsHistory)  void hide ()  bool isVisible () const void pushWidget (QWidget * widget)  void setActiveLayer (int index)  void setToolWidget (QWidget * weight)  void show ()  QWidget * toolWidget () const"},{"location":"flameshot/classUtilityPanel/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classUtilityPanel/#function-utilitypanel","title":"function UtilityPanel","text":"<pre><code>explicit UtilityPanel::UtilityPanel (\n    CaptureWidget * captureWidget\n) \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-activelayerindex","title":"function activeLayerIndex","text":"<pre><code>int UtilityPanel::activeLayerIndex () \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-cleartoolwidget","title":"function clearToolWidget","text":"<pre><code>void UtilityPanel::clearToolWidget () \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-fillcapturetools","title":"function fillCaptureTools","text":"<pre><code>void UtilityPanel::fillCaptureTools (\n    const QList&lt; QPointer&lt; CaptureTool &gt;&gt; &amp; captureToolObjectsHistory\n) \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-hide","title":"function hide","text":"<pre><code>void UtilityPanel::hide () \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-isvisible","title":"function isVisible","text":"<pre><code>bool UtilityPanel::isVisible () const\n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-pushwidget","title":"function pushWidget","text":"<pre><code>void UtilityPanel::pushWidget (\n    QWidget * widget\n) \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-setactivelayer","title":"function setActiveLayer","text":"<pre><code>void UtilityPanel::setActiveLayer (\n    int index\n) \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-settoolwidget","title":"function setToolWidget","text":"<pre><code>void UtilityPanel::setToolWidget (\n    QWidget * weight\n) \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-show","title":"function show","text":"<pre><code>void UtilityPanel::show () \n</code></pre>"},{"location":"flameshot/classUtilityPanel/#function-toolwidget","title":"function toolWidget","text":"<pre><code>QWidget * UtilityPanel::toolWidget () const\n</code></pre>"},{"location":"flameshot/classValueHandler/","title":"Class ValueHandler","text":"<p>ClassList &gt; ValueHandler</p> <p>Handles the value of a configuration option (abstract class). More...</p> <ul> <li><code>#include &lt;valuehandler.h&gt;</code></li> </ul> <p>Inherited by the following classes: Bool,  BoundedInt,  ButtonList,  Color,  ExistingDir,  FilenamePattern,  KeySequence,  LowerBoundedInt,  Region,  SaveFileExtension,  String,  UserColors</p>"},{"location":"flameshot/classValueHandler/#public-functions","title":"Public Functions","text":"Type Name virtual bool check (const QVariant &amp; val) = 0Check the value semantically. virtual QString expected () The expected value (descriptive). Used when reporting configuration errors. virtual QVariant fallback () Fallback value (default value). virtual QVariant representation (const QVariant &amp; val) Return the representation of the value in the config file. QVariant value (const QVariant &amp; val) Adapt the value for proper use."},{"location":"flameshot/classValueHandler/#protected-functions","title":"Protected Functions","text":"Type Name virtual QVariant process (const QVariant &amp; val) Process a value, presuming it is a valid <code>QVariant</code> ."},{"location":"flameshot/classValueHandler/#detailed-description","title":"Detailed Description","text":"<p>Each configuration option is represented as a <code>QVariant</code>. If the option was not specified in a config file, the <code>QVariant</code> will be invalid.</p> <p>Each option will usually be handled in three different ways: * have its value checked for semantic errors (type, format, etc). </p> <p>See also: ValueHandler::check</p> <ul> <li>have its value (that was taken from the config file) adapted for proper use. </li> </ul> <p>See also: ValueHandler::value</p> <ul> <li>provided a fallback value in case: the config does not explicitly specify it, or the config contains an error and is globally falling back to defaults. </li> </ul> <p>See also: ValueHandler::fallback.</p> <ul> <li>some options may want to be stored in the config file in a different way than the default one provided by <code>QVariant</code>. </li> </ul> <p>See also: ValueHandler::representation</p> <p>Note:</p> <p>Please see the documentation of the functions to learn when you should override each. </p>"},{"location":"flameshot/classValueHandler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classValueHandler/#function-check","title":"function check","text":"<p>Check the value semantically. </p> <pre><code>virtual bool ValueHandler::check (\n    const QVariant &amp; val\n) = 0\n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>Whether the value is correct </p> <p>Note:</p> <p>The function should presume that <code>val.isValid()</code> is true. </p>"},{"location":"flameshot/classValueHandler/#function-expected","title":"function expected","text":"<pre><code>virtual QString ValueHandler::expected () \n</code></pre>"},{"location":"flameshot/classValueHandler/#function-fallback","title":"function fallback","text":"<pre><code>virtual QVariant ValueHandler::fallback () \n</code></pre>"},{"location":"flameshot/classValueHandler/#function-representation","title":"function representation","text":"<p>Return the representation of the value in the config file. </p> <pre><code>virtual QVariant ValueHandler::representation (\n    const QVariant &amp; val\n) \n</code></pre> <p>Override this if you want to write the value in a different format than the one provided by <code>QVariant</code>. </p>"},{"location":"flameshot/classValueHandler/#function-value","title":"function value","text":"<p>Adapt the value for proper use. </p> <pre><code>QVariant ValueHandler::value (\n    const QVariant &amp; val\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>The modified value</p> <p>If the value is invalid (unspecified in the config) or does not pass <code>check</code>, the fallback will be returned. Otherwise the value is processed by <code>process</code> and then returned.</p> <p>Note:</p> <p>Cannot be overridden </p> <p>See also: fallback, process </p>"},{"location":"flameshot/classValueHandler/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"flameshot/classValueHandler/#function-process","title":"function process","text":"<p>Process a value, presuming it is a valid <code>QVariant</code> .</p> <pre><code>virtual QVariant ValueHandler::process (\n    const QVariant &amp; val\n) \n</code></pre> <p>Parameters:</p> <ul> <li><code>val</code> The value that was read from the config file </li> </ul> <p>Returns:</p> <p>The processed value </p> <p>Note:</p> <p>You will usually want to override this. In rare cases, you may want to override <code>value</code>. </p>"},{"location":"flameshot/classVisualsEditor/","title":"Class VisualsEditor","text":"<p>ClassList &gt; VisualsEditor</p> <p>Inherits the following classes: QWidget</p>"},{"location":"flameshot/classVisualsEditor/#public-functions","title":"Public Functions","text":"Type Name VisualsEditor (QWidget * parent=nullptr)"},{"location":"flameshot/classVisualsEditor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classVisualsEditor/#function-visualseditor","title":"function VisualsEditor","text":"<pre><code>explicit VisualsEditor::VisualsEditor (\n    QWidget * parent=nullptr\n) \n</code></pre>"},{"location":"flameshot/classWaylandUtils/","title":"Class WaylandUtils","text":"<p>ClassList &gt; WaylandUtils</p>"},{"location":"flameshot/classWaylandUtils/#public-functions","title":"Public Functions","text":"Type Name WaylandUtils ()"},{"location":"flameshot/classWaylandUtils/#public-static-functions","title":"Public Static Functions","text":"Type Name bool waylandDetected ()"},{"location":"flameshot/classWaylandUtils/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/classWaylandUtils/#function-waylandutils","title":"function WaylandUtils","text":"<pre><code>WaylandUtils::WaylandUtils () \n</code></pre>"},{"location":"flameshot/classWaylandUtils/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"flameshot/classWaylandUtils/#function-waylanddetected","title":"function waylandDetected","text":"<pre><code>static bool WaylandUtils::waylandDetected () \n</code></pre>"},{"location":"flameshot/structWinLnkFileParser/","title":"Struct WinLnkFileParser","text":"<p>ClassList &gt; WinLnkFileParser</p>"},{"location":"flameshot/structWinLnkFileParser/#public-functions","title":"Public Functions","text":"Type Name WinLnkFileParser ()  QString getAllUsersStartMenuPath ()  QVector&lt; DesktopAppData &gt; getAppsByCategory (const QString &amp; category)  QMap&lt; QString, QVector&lt; DesktopAppData &gt; &gt; getAppsByCategory (const QStringList &amp; categories)  DesktopAppData parseLnkFile (const QFileInfo &amp; fiLnk, bool &amp; ok) const int processDirectory (const QDir &amp; dir)"},{"location":"flameshot/structWinLnkFileParser/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/structWinLnkFileParser/#function-winlnkfileparser","title":"function WinLnkFileParser","text":"<pre><code>WinLnkFileParser::WinLnkFileParser () \n</code></pre>"},{"location":"flameshot/structWinLnkFileParser/#function-getallusersstartmenupath","title":"function getAllUsersStartMenuPath","text":"<pre><code>QString WinLnkFileParser::getAllUsersStartMenuPath () \n</code></pre>"},{"location":"flameshot/structWinLnkFileParser/#function-getappsbycategory-12","title":"function getAppsByCategory [1/2]","text":"<pre><code>QVector&lt; DesktopAppData &gt; WinLnkFileParser::getAppsByCategory (\n    const QString &amp; category\n) \n</code></pre>"},{"location":"flameshot/structWinLnkFileParser/#function-getappsbycategory-22","title":"function getAppsByCategory [2/2]","text":"<pre><code>QMap&lt; QString, QVector&lt; DesktopAppData &gt; &gt; WinLnkFileParser::getAppsByCategory (\n    const QStringList &amp; categories\n) \n</code></pre>"},{"location":"flameshot/structWinLnkFileParser/#function-parselnkfile","title":"function parseLnkFile","text":"<pre><code>DesktopAppData WinLnkFileParser::parseLnkFile (\n    const QFileInfo &amp; fiLnk,\n    bool &amp; ok\n) const\n</code></pre>"},{"location":"flameshot/structWinLnkFileParser/#function-processdirectory","title":"function processDirectory","text":"<pre><code>int WinLnkFileParser::processDirectory (\n    const QDir &amp; dir\n) \n</code></pre>"},{"location":"flameshot/namespaceorg/","title":"Namespace org","text":"<p>Namespace List &gt; org</p>"},{"location":"flameshot/namespaceorg/#namespaces","title":"Namespaces","text":"Type Name namespace freedesktop"},{"location":"flameshot/namespaceorg_1_1freedesktop/","title":"Namespace org::freedesktop","text":"<p>Namespace List &gt; org &gt; freedesktop</p>"},{"location":"flameshot/namespaceorg_1_1freedesktop/#namespaces","title":"Namespaces","text":"Type Name namespace portal"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/","title":"Namespace org::freedesktop::portal","text":"<p>Namespace List &gt; org &gt; freedesktop &gt; portal</p>"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#public-types","title":"Public Types","text":"Type Name typedef ::OrgFreedesktopPortalRequestInterface Request"},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/namespaceorg_1_1freedesktop_1_1portal/#typedef-request","title":"typedef Request","text":"<pre><code>typedef ::OrgFreedesktopPortalRequestInterface org::freedesktop::portal::Request;\n</code></pre>"},{"location":"flameshot/namespacestrfparse/","title":"Namespace strfparse","text":"<p>Namespace List &gt; strfparse</p>"},{"location":"flameshot/namespacestrfparse/#public-functions","title":"Public Functions","text":"Type Name std::vector&lt; char &gt; create_specifier_list ()  std::string format_time_string (std::string const &amp; specifier)  std::vector&lt; char &gt; match_specifiers (std::string const &amp; specifier, std::vector&lt; char &gt; allowed_specifier)  std::string replace_all (std::string input, std::string const &amp; to_find, std::string const &amp; to_replace)  std::vector&lt; std::string &gt; split (std::string const &amp; s, char delimiter)"},{"location":"flameshot/namespacestrfparse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/namespacestrfparse/#function-create_specifier_list","title":"function create_specifier_list","text":"<pre><code>std::vector&lt; char &gt; strfparse::create_specifier_list () \n</code></pre>"},{"location":"flameshot/namespacestrfparse/#function-format_time_string","title":"function format_time_string","text":"<pre><code>std::string strfparse::format_time_string (\n    std::string const &amp; specifier\n) \n</code></pre>"},{"location":"flameshot/namespacestrfparse/#function-match_specifiers","title":"function match_specifiers","text":"<pre><code>std::vector&lt; char &gt; strfparse::match_specifiers (\n    std::string const &amp; specifier,\n    std::vector&lt; char &gt; allowed_specifier\n) \n</code></pre>"},{"location":"flameshot/namespacestrfparse/#function-replace_all","title":"function replace_all","text":"<pre><code>std::string strfparse::replace_all (\n    std::string input,\n    std::string const &amp; to_find,\n    std::string const &amp; to_replace\n) \n</code></pre>"},{"location":"flameshot/namespacestrfparse/#function-split","title":"function split","text":"<pre><code>std::vector&lt; std::string &gt; strfparse::split (\n    std::string const &amp; s,\n    char delimiter\n) \n</code></pre>"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Type Name file main.cpp"},{"location":"flameshot/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir cli dir config dir core dir tools dir utils dir widgets"},{"location":"flameshot/dir_b78fdfbbb632ce54d070469d6a721373/","title":"Dir cli","text":"<p>FileList &gt; cli</p>"},{"location":"flameshot/dir_b78fdfbbb632ce54d070469d6a721373/#files","title":"Files","text":"Type Name file commandargument.cpp file commandargument.h file commandlineparser.cpp file commandlineparser.h file commandoption.cpp file commandoption.h"},{"location":"flameshot/commandargument_8cpp/","title":"File commandargument.cpp","text":"<p>FileList &gt; cli &gt; commandargument.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"commandargument.h\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"flameshot/commandargument_8cpp_source/","title":"File commandargument.cpp","text":"<p>File List &gt; cli &gt; commandargument.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"commandargument.h\"\n\n#include &lt;utility&gt;\n\nCommandArgument::CommandArgument() = default;\n\nCommandArgument::CommandArgument(QString name, QString description)\n  : m_name(std::move(name))\n  , m_description(std::move(description))\n{}\n\nvoid CommandArgument::setName(const QString&amp; name)\n{\n    m_name = name;\n}\n\nQString CommandArgument::name() const\n{\n    return m_name;\n}\n\nvoid CommandArgument::setDescription(const QString&amp; description)\n{\n    m_description = description;\n}\n\nQString CommandArgument::description() const\n{\n    return m_description;\n}\n\nbool CommandArgument::isRoot() const\n{\n    return m_name.isEmpty() &amp;&amp; m_description.isEmpty();\n}\n\nbool CommandArgument::operator==(const CommandArgument&amp; arg) const\n{\n    return m_description == arg.m_description &amp;&amp; m_name == arg.m_name;\n}\n\n</code></pre>"},{"location":"flameshot/commandargument_8h/","title":"File commandargument.h","text":"<p>FileList &gt; cli &gt; commandargument.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QString&gt;</code></li> </ul>"},{"location":"flameshot/commandargument_8h/#classes","title":"Classes","text":"Type Name class CommandArgument"},{"location":"flameshot/commandargument_8h_source/","title":"File commandargument.h","text":"<p>File List &gt; cli &gt; commandargument.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QString&gt;\n\nclass CommandArgument\n{\npublic:\n    CommandArgument();\n    explicit CommandArgument(QString name, QString description);\n\n    void setName(const QString&amp; name);\n    QString name() const;\n\n    void setDescription(const QString&amp; description);\n    QString description() const;\n\n    bool isRoot() const;\n\n    bool operator==(const CommandArgument&amp; arg) const;\n\nprivate:\n    QString m_name;\n    QString m_description;\n};\n\n</code></pre>"},{"location":"flameshot/commandlineparser_8cpp/","title":"File commandlineparser.cpp","text":"<p>FileList &gt; cli &gt; commandlineparser.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"commandlineparser.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QTextStream&gt;</code></li> </ul>"},{"location":"flameshot/commandlineparser_8cpp_source/","title":"File commandlineparser.cpp","text":"<p>File List &gt; cli &gt; commandlineparser.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"commandlineparser.h\"\n#include \"abstractlogger.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QApplication&gt;\n#include &lt;QTextStream&gt;\n\nCommandLineParser::CommandLineParser()\n  : m_description(qApp-&gt;applicationName())\n{}\n\nnamespace {\n\nAbstractLogger out =\n  AbstractLogger::info(AbstractLogger::Stdout).enableMessageHeader(false);\nAbstractLogger err = AbstractLogger::error(AbstractLogger::Stderr);\n\nauto versionOption =\n  CommandOption({ \"v\", \"version\" },\n                QStringLiteral(\"Displays version information\"));\nauto helpOption =\n  CommandOption({ \"h\", \"help\" }, QStringLiteral(\"Displays this help\"));\n\nQString optionsToString(const QList&lt;CommandOption&gt;&amp; options,\n                        const QList&lt;CommandArgument&gt;&amp; subcommands)\n{\n    int size = 0; // track the largest size\n    QStringList dashedOptionList;\n    // save the dashed options and its size in order to print the description\n    // of every option at the same horizontal character position.\n    for (auto const&amp; option : options) {\n        QStringList dashedOptions = option.dashedNames();\n        QString joinedDashedOptions = dashedOptions.join(QStringLiteral(\", \"));\n        if (!option.valueName().isEmpty()) {\n            joinedDashedOptions +=\n              QStringLiteral(\" &lt;%1&gt;\").arg(option.valueName());\n        }\n        if (joinedDashedOptions.length() &gt; size) {\n            size = joinedDashedOptions.length();\n        }\n        dashedOptionList &lt;&lt; joinedDashedOptions;\n    }\n    // check the length of the subcommands\n    for (auto const&amp; subcommand : subcommands) {\n        if (subcommand.name().length() &gt; size) {\n            size = subcommand.name().length();\n        }\n    }\n    // generate the text\n    QString result;\n    if (!dashedOptionList.isEmpty()) {\n        result += QObject::tr(\"Options\") + \":\\n\";\n        QString linePadding =\n          QStringLiteral(\" \").repeated(size + 4).prepend(\"\\n\");\n        for (int i = 0; i &lt; options.length(); ++i) {\n            result += QStringLiteral(\"  %1  %2\\n\")\n                        .arg(dashedOptionList.at(i).leftJustified(size, ' '))\n                        .arg(options.at(i).description().replace(\n                          QLatin1String(\"\\n\"), linePadding));\n        }\n        if (!subcommands.isEmpty()) {\n            result += QLatin1String(\"\\n\");\n        }\n    }\n    if (!subcommands.isEmpty()) {\n        result += QObject::tr(\"Subcommands\") + \":\\n\";\n    }\n    for (const auto&amp; subcommand : subcommands) {\n        result += QStringLiteral(\"  %1  %2\\n\")\n                    .arg(subcommand.name().leftJustified(size, ' '))\n                    .arg(subcommand.description());\n    }\n    return result;\n}\n\n} // unnamed namespace\n\nbool CommandLineParser::processArgs(const QStringList&amp; args,\n                                    QStringList::const_iterator&amp; actualIt,\n                                    Node*&amp; actualNode)\n{\n    QString argument = *actualIt;\n    bool ok = true;\n    bool isValidArg = false;\n    for (Node&amp; n : actualNode-&gt;subNodes) {\n        if (n.argument.name() == argument) {\n            actualNode = &amp;n;\n            isValidArg = true;\n            break;\n        }\n    }\n    if (isValidArg) {\n        auto nextArg = actualNode-&gt;argument;\n        m_foundArgs.append(nextArg);\n        // check next is help\n        ++actualIt;\n        ok = processIfOptionIsHelp(args, actualIt, actualNode);\n        --actualIt;\n    } else {\n        ok = false;\n        err &lt;&lt; QStringLiteral(\"'%1' is not a valid argument.\").arg(argument);\n    }\n    return ok;\n}\n\nbool CommandLineParser::processOptions(const QStringList&amp; args,\n                                       QStringList::const_iterator&amp; actualIt,\n                                       Node* const actualNode)\n{\n    QString arg = *actualIt;\n    bool ok = true;\n    // track values\n    int equalsPos = arg.indexOf(QLatin1String(\"=\"));\n    QString valueStr;\n    if (equalsPos != -1) {\n        valueStr = arg.mid(equalsPos + 1); // right\n        arg = arg.mid(0, equalsPos);       // left\n    }\n    // check format -x --xx...\n    bool isDoubleDashed = arg.startsWith(QLatin1String(\"--\"));\n    ok = isDoubleDashed ? arg.length() &gt; 3 : arg.length() == 2;\n    if (!ok) {\n        err &lt;&lt; QStringLiteral(\"the option %1 has a wrong format.\").arg(arg);\n        return ok;\n    }\n    arg = isDoubleDashed ? arg.remove(0, 2) : arg.remove(0, 1);\n    // get option\n    auto endIt = actualNode-&gt;options.cend();\n    auto optionIt = endIt;\n    for (auto i = actualNode-&gt;options.cbegin(); i != endIt; ++i) {\n        if ((*i).names().contains(arg)) {\n            optionIt = i;\n            break;\n        }\n    }\n    if (optionIt == endIt) {\n        QString argName = actualNode-&gt;argument.name();\n        if (argName.isEmpty()) {\n            argName = qApp-&gt;applicationName();\n        }\n        err &lt;&lt; QStringLiteral(\"the option '%1' is not a valid option \"\n                              \"for the argument '%2'.\")\n                 .arg(arg)\n                 .arg(argName);\n        ok = false;\n        return ok;\n    }\n    // check presence of values\n    CommandOption option = *optionIt;\n    bool requiresValue = !(option.valueName().isEmpty());\n    if (!requiresValue &amp;&amp; equalsPos != -1) {\n        err &lt;&lt; QStringLiteral(\"the option '%1' contains a '=' and it doesn't \"\n                              \"require a value.\")\n                 .arg(arg);\n        ok = false;\n        return ok;\n    } else if (requiresValue &amp;&amp; valueStr.isEmpty()) {\n        // find in the next\n        if (actualIt + 1 != args.cend()) {\n            ++actualIt;\n        } else {\n            err &lt;&lt; QStringLiteral(\"Expected value after the option '%1'.\")\n                     .arg(arg);\n            ok = false;\n            return ok;\n        }\n        valueStr = *actualIt;\n    }\n    // check the value correctness\n    if (requiresValue) {\n        ok = option.checkValue(valueStr);\n        if (!ok) {\n            QString msg = option.errorMsg();\n            if (!msg.endsWith(QLatin1String(\".\"))) {\n                msg += QLatin1String(\".\");\n            }\n            err &lt;&lt; msg;\n            return ok;\n        }\n        option.setValue(valueStr);\n    }\n    m_foundOptions.append(option);\n    return ok;\n}\n\nbool CommandLineParser::parse(const QStringList&amp; args)\n{\n    m_foundArgs.clear();\n    m_foundOptions.clear();\n    bool ok = true;\n    Node* actualNode = &amp;m_parseTree;\n    auto it = ++args.cbegin();\n    // check  version option\n    QStringList dashedVersion = versionOption.dashedNames();\n    if (m_withVersion &amp;&amp; args.length() &gt; 1 &amp;&amp;\n        dashedVersion.contains(args.at(1))) {\n        if (args.length() == 2) {\n            printVersion();\n            m_foundOptions &lt;&lt; versionOption;\n        } else {\n            err &lt;&lt; \"Invalid arguments after the version option.\";\n            ok = false;\n        }\n        return ok;\n    }\n    // check  help option\n    ok = processIfOptionIsHelp(args, it, actualNode);\n    // process the other args\n    for (; it != args.cend() &amp;&amp; ok; ++it) {\n        const QString&amp; val = *it;\n        if (val.startsWith(QLatin1String(\"-\"))) {\n            ok = processOptions(args, it, actualNode);\n\n        } else {\n            ok = processArgs(args, it, actualNode);\n        }\n    }\n    if (!ok &amp;&amp; !m_generalErrorMessage.isEmpty()) {\n        err.enableMessageHeader(false);\n        err &lt;&lt; m_generalErrorMessage;\n        err.enableMessageHeader(true);\n    }\n    return ok;\n}\n\nCommandOption CommandLineParser::addVersionOption()\n{\n    m_withVersion = true;\n    return versionOption;\n}\n\nCommandOption CommandLineParser::addHelpOption()\n{\n    m_withHelp = true;\n    return helpOption;\n}\n\nbool CommandLineParser::AddArgument(const CommandArgument&amp; arg,\n                                    const CommandArgument&amp; parent)\n{\n    bool res = true;\n    Node* n = findParent(parent);\n    if (n == nullptr) {\n        res = false;\n    } else {\n        Node child;\n        child.argument = arg;\n        n-&gt;subNodes.append(child);\n    }\n    return res;\n}\n\nbool CommandLineParser::AddOption(const CommandOption&amp; option,\n                                  const CommandArgument&amp; parent)\n{\n    bool res = true;\n    Node* n = findParent(parent);\n    if (n == nullptr) {\n        res = false;\n    } else {\n        n-&gt;options.append(option);\n    }\n    return res;\n}\n\nbool CommandLineParser::AddOptions(const QList&lt;CommandOption&gt;&amp; options,\n                                   const CommandArgument&amp; parent)\n{\n    bool res = true;\n    for (auto const&amp; option : options) {\n        if (!AddOption(option, parent)) {\n            res = false;\n            break;\n        }\n    }\n    return res;\n}\n\nvoid CommandLineParser::setGeneralErrorMessage(const QString&amp; msg)\n{\n    m_generalErrorMessage = msg;\n}\n\nvoid CommandLineParser::setDescription(const QString&amp; description)\n{\n    m_description = description;\n}\n\nbool CommandLineParser::isSet(const CommandArgument&amp; arg) const\n{\n    return m_foundArgs.contains(arg);\n}\n\nbool CommandLineParser::isSet(const CommandOption&amp; option) const\n{\n    return m_foundOptions.contains(option);\n}\n\nQString CommandLineParser::value(const CommandOption&amp; option) const\n{\n    QString value = option.value();\n    for (const CommandOption&amp; fOption : m_foundOptions) {\n        if (option == fOption) {\n            value = fOption.value();\n            break;\n        }\n    }\n    return value;\n}\n\nvoid CommandLineParser::printVersion()\n{\n    out &lt;&lt; GlobalValues::versionInfo();\n}\n\nvoid CommandLineParser::printHelp(QStringList args, const Node* node)\n{\n    args.removeLast(); // remove the help, it's always the last\n    QString helpText;\n\n    // add usage info\n    QString argName = node-&gt;argument.name();\n    if (argName.isEmpty()) {\n        argName = qApp-&gt;applicationName();\n    }\n    QString argText =\n      node-&gt;subNodes.isEmpty() ? \"\" : \"[\" + QObject::tr(\"subcommands\") + \"]\";\n    helpText += (QObject::tr(\"Usage\") + \": %1 [%2-\" + QObject::tr(\"options\") +\n                 QStringLiteral(\"] %3\\n\\n\"))\n                  .arg(args.join(QStringLiteral(\" \")))\n                  .arg(argName)\n                  .arg(argText);\n\n    // short section about default behavior\n    helpText += QObject::tr(\"Per default runs Flameshot in the background and \"\n                            \"adds a tray icon for configuration.\");\n    helpText += \"\\n\\n\";\n\n    // add command options and subarguments\n    QList&lt;CommandArgument&gt; subcommands;\n    for (const Node&amp; n : node-&gt;subNodes) {\n        subcommands.append(n.argument);\n    }\n    auto modifiedOptions = node-&gt;options;\n    if (m_withHelp) {\n        modifiedOptions &lt;&lt; helpOption;\n    }\n    if (m_withVersion &amp;&amp; node == &amp;m_parseTree) {\n        modifiedOptions &lt;&lt; versionOption;\n    }\n    helpText += optionsToString(modifiedOptions, subcommands);\n    // print it\n    out &lt;&lt; helpText;\n}\n\nCommandLineParser::Node* CommandLineParser::findParent(\n  const CommandArgument&amp; parent)\n{\n    if (parent == CommandArgument()) {\n        return &amp;m_parseTree;\n    }\n    // find the parent in the subNodes recursively\n    Node* res = nullptr;\n    for (auto&amp; subNode : m_parseTree.subNodes) {\n        res = recursiveParentSearch(parent, subNode);\n        if (res != nullptr) {\n            break;\n        }\n    }\n    return res;\n}\n\nCommandLineParser::Node* CommandLineParser::recursiveParentSearch(\n  const CommandArgument&amp; parent,\n  Node&amp; node) const\n{\n    Node* res = nullptr;\n    if (node.argument == parent) {\n        res = &amp;node;\n    } else {\n        for (auto&amp; subNode : node.subNodes) {\n            res = recursiveParentSearch(parent, subNode);\n            if (res != nullptr) {\n                break;\n            }\n        }\n    }\n    return res;\n}\n\nbool CommandLineParser::processIfOptionIsHelp(\n  const QStringList&amp; args,\n  QStringList::const_iterator&amp; actualIt,\n  Node*&amp; actualNode)\n{\n    bool ok = true;\n    auto dashedHelpNames = helpOption.dashedNames();\n    if (m_withHelp &amp;&amp; actualIt != args.cend() &amp;&amp;\n        dashedHelpNames.contains(*actualIt)) {\n        if (actualIt + 1 == args.cend()) {\n            m_foundOptions &lt;&lt; helpOption;\n            printHelp(args, actualNode);\n            actualIt++;\n        } else {\n            err &lt;&lt; \"Invalid arguments after the help option.\";\n            ok = false;\n        }\n    }\n    return ok;\n}\n\n</code></pre>"},{"location":"flameshot/commandlineparser_8h/","title":"File commandlineparser.h","text":"<p>FileList &gt; cli &gt; commandlineparser.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/cli/commandargument.h\"</code></li> <li><code>#include \"src/cli/commandoption.h\"</code></li> <li><code>#include &lt;QMap&gt;</code></li> </ul>"},{"location":"flameshot/commandlineparser_8h/#classes","title":"Classes","text":"Type Name class CommandLineParser"},{"location":"flameshot/commandlineparser_8h_source/","title":"File commandlineparser.h","text":"<p>File List &gt; cli &gt; commandlineparser.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/cli/commandargument.h\"\n#include \"src/cli/commandoption.h\"\n#include &lt;QMap&gt;\n\nclass CommandLineParser\n{\npublic:\n    CommandLineParser();\n\n    bool parse(const QStringList&amp; args);\n\n    CommandArgument rootArgument() const { return CommandArgument(); }\n\n    CommandOption addVersionOption();\n    CommandOption addHelpOption();\n\n    bool AddArgument(const CommandArgument&amp; arg,\n                     const CommandArgument&amp; parent = CommandArgument());\n\n    bool AddOption(const CommandOption&amp; option,\n                   const CommandArgument&amp; parent = CommandArgument());\n\n    bool AddOptions(const QList&lt;CommandOption&gt;&amp; options,\n                    const CommandArgument&amp; parent = CommandArgument());\n\n    void setGeneralErrorMessage(const QString&amp; msg);\n    void setDescription(const QString&amp; description);\n\n    bool isSet(const CommandArgument&amp; arg) const;\n    bool isSet(const CommandOption&amp; option) const;\n    QString value(const CommandOption&amp; option) const;\n\nprivate:\n    bool m_withHelp = false;\n    bool m_withVersion = false;\n    QString m_description;\n    QString m_generalErrorMessage;\n\n    struct Node\n    {\n        explicit Node(const CommandArgument&amp; arg)\n          : argument(arg)\n        {}\n        Node() {}\n        bool operator==(const Node&amp; n) const\n        {\n            return argument == n.argument &amp;&amp; options == n.options &amp;&amp;\n                   subNodes == n.subNodes;\n        }\n        CommandArgument argument;\n        QList&lt;CommandOption&gt; options;\n        QList&lt;Node&gt; subNodes;\n    };\n\n    Node m_parseTree;\n    QList&lt;CommandOption&gt; m_foundOptions;\n    QList&lt;CommandArgument&gt; m_foundArgs;\n\n    // helper functions\n    void printVersion();\n    void printHelp(QStringList args, const Node* node);\n    Node* findParent(const CommandArgument&amp; parent);\n    Node* recursiveParentSearch(const CommandArgument&amp; parent,\n                                Node&amp; node) const;\n    bool processIfOptionIsHelp(const QStringList&amp; args,\n                               QStringList::const_iterator&amp; actualIt,\n                               Node*&amp; actualNode);\n    bool processArgs(const QStringList&amp; args,\n                     QStringList::const_iterator&amp; actualIt,\n                     Node*&amp; actualNode);\n    bool processOptions(const QStringList&amp; args,\n                        QStringList::const_iterator&amp; actualIt,\n                        Node* const actualNode);\n};\n\n</code></pre>"},{"location":"flameshot/commandoption_8cpp/","title":"File commandoption.cpp","text":"<p>FileList &gt; cli &gt; commandoption.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"commandoption.h\"</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"flameshot/commandoption_8cpp_source/","title":"File commandoption.cpp","text":"<p>File List &gt; cli &gt; commandoption.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"commandoption.h\"\n\n#include &lt;utility&gt;\n\nCommandOption::CommandOption(const QString&amp; name,\n                             QString description,\n                             QString valueName,\n                             QString defaultValue)\n  : m_names(name)\n  , m_description(std::move(description))\n  , m_valueName(std::move(valueName))\n  , m_value(std::move(defaultValue))\n{\n    m_checker = [](QString const&amp;) { return true; };\n}\n\nCommandOption::CommandOption(QStringList names,\n                             QString description,\n                             QString valueName,\n                             QString defaultValue)\n  : m_names(std::move(names))\n  , m_description(std::move(description))\n  , m_valueName(std::move(valueName))\n  , m_value(std::move(defaultValue))\n{\n    m_checker = [](QString const&amp;) -&gt; bool { return true; };\n}\n\nvoid CommandOption::setName(const QString&amp; name)\n{\n    m_names = QStringList() &lt;&lt; name;\n}\n\nvoid CommandOption::setNames(const QStringList&amp; names)\n{\n    m_names = names;\n}\n\nQStringList CommandOption::names() const\n{\n    return m_names;\n}\n\nQStringList CommandOption::dashedNames() const\n{\n    QStringList dashedNames;\n    for (const QString&amp; name : m_names) {\n        // prepend \"-\" to single character options, and \"--\" to the others\n        QString dashedName = (name.length() == 1)\n                               ? QStringLiteral(\"-%1\").arg(name)\n                               : QStringLiteral(\"--%1\").arg(name);\n        dashedNames &lt;&lt; dashedName;\n    }\n    return dashedNames;\n}\n\nvoid CommandOption::setValueName(const QString&amp; name)\n{\n    m_valueName = name;\n}\n\nQString CommandOption::valueName() const\n{\n    return m_valueName;\n}\n\nvoid CommandOption::setValue(const QString&amp; value)\n{\n    if (m_valueName.isEmpty()) {\n        m_valueName = QLatin1String(\"value\");\n    }\n    m_value = value;\n}\n\nQString CommandOption::value() const\n{\n    return m_value;\n}\n\nvoid CommandOption::addChecker(const function&lt;bool(const QString&amp;)&gt; checker,\n                               const QString&amp; errMsg)\n{\n    m_checker = checker;\n    m_errorMsg = errMsg;\n}\n\nbool CommandOption::checkValue(const QString&amp; value) const\n{\n    return m_checker(value);\n}\n\nQString CommandOption::description() const\n{\n    return m_description;\n}\n\nvoid CommandOption::setDescription(const QString&amp; description)\n{\n    m_description = description;\n}\n\nQString CommandOption::errorMsg() const\n{\n    return m_errorMsg;\n}\n\nbool CommandOption::operator==(const CommandOption&amp; option) const\n{\n    return m_description == option.m_description &amp;&amp; m_names == option.m_names &amp;&amp;\n           m_valueName == option.m_valueName;\n}\n\n</code></pre>"},{"location":"flameshot/commandoption_8h/","title":"File commandoption.h","text":"<p>FileList &gt; cli &gt; commandoption.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QStringList&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> </ul>"},{"location":"flameshot/commandoption_8h/#classes","title":"Classes","text":"Type Name class CommandOption"},{"location":"flameshot/commandoption_8h_source/","title":"File commandoption.h","text":"<p>File List &gt; cli &gt; commandoption.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QStringList&gt;\n#include &lt;functional&gt;\n\nusing std::function;\n\nclass CommandOption\n{\npublic:\n    CommandOption(const QString&amp; name,\n                  QString description,\n                  QString valueName = QString(),\n                  QString defaultValue = QString());\n\n    CommandOption(QStringList names,\n                  QString description,\n                  QString valueName = QString(),\n                  QString defaultValue = QString());\n\n    void setName(const QString&amp; name);\n    void setNames(const QStringList&amp; names);\n    QStringList names() const;\n    QStringList dashedNames() const;\n\n    void setValueName(const QString&amp; name);\n    QString valueName() const;\n\n    void setValue(const QString&amp; value);\n    QString value() const;\n\n    void addChecker(const function&lt;bool(QString const&amp;)&gt; checker,\n                    const QString&amp; errMsg);\n    bool checkValue(const QString&amp; value) const;\n\n    QString description() const;\n    void setDescription(const QString&amp; description);\n\n    QString errorMsg() const;\n\n    bool operator==(const CommandOption&amp; option) const;\n\nprivate:\n    QStringList m_names;\n    QString m_description;\n    QString m_valueName;\n    QString m_value;\n\n    function&lt;bool(QString const&amp;)&gt; m_checker;\n    QString m_errorMsg;\n};\n\n</code></pre>"},{"location":"flameshot/dir_7e83d1792d529f4aa7126ac7e0b3b699/","title":"Dir config","text":"<p>FileList &gt; config</p>"},{"location":"flameshot/dir_7e83d1792d529f4aa7126ac7e0b3b699/#files","title":"Files","text":"Type Name file buttonlistview.cpp file buttonlistview.h file cacheutils.cpp file cacheutils.h file clickablelabel.cpp file clickablelabel.h file colorpickereditmode.cpp file colorpickereditmode.h file colorpickereditor.cpp file colorpickereditor.h file configerrordetails.cpp file configerrordetails.h file configresolver.cpp file configresolver.h file configwindow.cpp file configwindow.h file extendedslider.cpp file extendedslider.h file filenameeditor.cpp file filenameeditor.h file generalconf.cpp file generalconf.h file setshortcutwidget.cpp file setshortcutwidget.h file shortcutswidget.cpp file shortcutswidget.h file strftimechooserwidget.cpp file strftimechooserwidget.h file styleoverride.cpp file styleoverride.h file uicoloreditor.cpp file uicoloreditor.h file visualseditor.cpp file visualseditor.h"},{"location":"flameshot/buttonlistview_8cpp/","title":"File buttonlistview.cpp","text":"<p>FileList &gt; config &gt; buttonlistview.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"buttonlistview.h\"</code></li> <li><code>#include \"src/tools/toolfactory.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QListWidgetItem&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> </ul>"},{"location":"flameshot/buttonlistview_8cpp_source/","title":"File buttonlistview.cpp","text":"<p>File List &gt; config &gt; buttonlistview.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"buttonlistview.h\"\n#include \"src/tools/toolfactory.h\"\n#include \"src/utils/confighandler.h\"\n#include &lt;QListWidgetItem&gt;\n#include &lt;algorithm&gt;\n\nButtonListView::ButtonListView(QWidget* parent)\n  : QListWidget(parent)\n{\n    setMouseTracking(true);\n    setFlow(QListWidget::TopToBottom);\n    initButtonList();\n    updateComponents();\n    connect(\n      this, &amp;QListWidget::itemClicked, this, &amp;ButtonListView::reverseItemCheck);\n}\n\nvoid ButtonListView::initButtonList()\n{\n    ToolFactory factory;\n    auto listTypes = CaptureToolButton::getIterableButtonTypes();\n\n    for (const CaptureTool::Type t : listTypes) {\n        CaptureTool* tool = factory.CreateTool(t);\n\n        // add element to the local map\n        m_buttonTypeByName.insert(tool-&gt;name(), t);\n\n        // init the menu option\n        auto* m_buttonItem = new QListWidgetItem(this);\n\n        // when the background is lighter than gray, it uses the white icons\n        QColor bgColor = this-&gt;palette().color(QWidget::backgroundRole());\n        m_buttonItem-&gt;setIcon(tool-&gt;icon(bgColor, false));\n\n        m_buttonItem-&gt;setFlags(Qt::ItemIsUserCheckable);\n        QColor foregroundColor =\n          this-&gt;palette().color(QWidget::foregroundRole());\n        m_buttonItem-&gt;setForeground(foregroundColor);\n\n        m_buttonItem-&gt;setText(tool-&gt;name());\n        m_buttonItem-&gt;setToolTip(tool-&gt;description());\n        tool-&gt;deleteLater();\n    }\n}\n\nvoid ButtonListView::updateActiveButtons(QListWidgetItem* item)\n{\n    CaptureTool::Type bType = m_buttonTypeByName[item-&gt;text()];\n    if (item-&gt;checkState() == Qt::Checked) {\n        m_listButtons.append(bType);\n        // TODO refactor so we don't need external sorts\n        using bt = CaptureTool::Type;\n        std::sort(m_listButtons.begin(), m_listButtons.end(), [](bt a, bt b) {\n            return CaptureToolButton::getPriorityByButton(a) &lt;\n                   CaptureToolButton::getPriorityByButton(b);\n        });\n    } else {\n        m_listButtons.removeOne(bType);\n    }\n    ConfigHandler().setButtons(m_listButtons);\n}\n\nvoid ButtonListView::reverseItemCheck(QListWidgetItem* item)\n{\n    if (item-&gt;checkState() == Qt::Checked) {\n        item-&gt;setCheckState(Qt::Unchecked);\n    } else {\n        item-&gt;setCheckState(Qt::Checked);\n    }\n    updateActiveButtons(item);\n}\n\nvoid ButtonListView::selectAll()\n{\n    ConfigHandler().setAllTheButtons();\n    for (int i = 0; i &lt; this-&gt;count(); ++i) {\n        QListWidgetItem* item = this-&gt;item(i);\n        item-&gt;setCheckState(Qt::Checked);\n    }\n}\n\nvoid ButtonListView::updateComponents()\n{\n    m_listButtons = ConfigHandler().buttons();\n    auto listTypes = CaptureToolButton::getIterableButtonTypes();\n    for (int i = 0; i &lt; this-&gt;count(); ++i) {\n        QListWidgetItem* item = this-&gt;item(i);\n        auto elem = static_cast&lt;CaptureTool::Type&gt;(listTypes.at(i));\n        if (m_listButtons.contains(elem)) {\n            item-&gt;setCheckState(Qt::Checked);\n        } else {\n            item-&gt;setCheckState(Qt::Unchecked);\n        }\n    }\n}\n\n</code></pre>"},{"location":"flameshot/buttonlistview_8h/","title":"File buttonlistview.h","text":"<p>FileList &gt; config &gt; buttonlistview.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/widgets/capture/capturetoolbutton.h\"</code></li> <li><code>#include &lt;QListWidget&gt;</code></li> </ul>"},{"location":"flameshot/buttonlistview_8h/#classes","title":"Classes","text":"Type Name class ButtonListView"},{"location":"flameshot/buttonlistview_8h_source/","title":"File buttonlistview.h","text":"<p>File List &gt; config &gt; buttonlistview.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/widgets/capture/capturetoolbutton.h\"\n#include &lt;QListWidget&gt;\n\nclass ButtonListView : public QListWidget\n{\npublic:\n    explicit ButtonListView(QWidget* parent = nullptr);\n\npublic slots:\n    void selectAll();\n    void updateComponents();\n\nprivate slots:\n    void reverseItemCheck(QListWidgetItem*);\n\nprotected:\n    void initButtonList();\n\nprivate:\n    QList&lt;CaptureTool::Type&gt; m_listButtons;\n    QMap&lt;QString, CaptureTool::Type&gt; m_buttonTypeByName;\n\n    void updateActiveButtons(QListWidgetItem*);\n};\n\n</code></pre>"},{"location":"flameshot/cacheutils_8cpp/","title":"File cacheutils.cpp","text":"<p>FileList &gt; config &gt; cacheutils.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cacheutils.h\"</code></li> <li><code>#include &lt;QDataStream&gt;</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QFile&gt;</code></li> <li><code>#include &lt;QRect&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> </ul>"},{"location":"flameshot/cacheutils_8cpp/#public-functions","title":"Public Functions","text":"Type Name QString getCachePath ()  QRect getLastRegion ()  void setLastRegion (QRect const &amp; newRegion)"},{"location":"flameshot/cacheutils_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/cacheutils_8cpp/#function-getcachepath","title":"function getCachePath","text":"<pre><code>QString getCachePath () \n</code></pre>"},{"location":"flameshot/cacheutils_8cpp/#function-getlastregion","title":"function getLastRegion","text":"<pre><code>QRect getLastRegion () \n</code></pre>"},{"location":"flameshot/cacheutils_8cpp/#function-setlastregion","title":"function setLastRegion","text":"<pre><code>void setLastRegion (\n    QRect const &amp; newRegion\n) \n</code></pre>"},{"location":"flameshot/cacheutils_8cpp_source/","title":"File cacheutils.cpp","text":"<p>File List &gt; config &gt; cacheutils.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Jeremy Borgman\n\n#include \"cacheutils.h\"\n#include &lt;QDataStream&gt;\n#include &lt;QDir&gt;\n#include &lt;QFile&gt;\n#include &lt;QRect&gt;\n#include &lt;QStandardPaths&gt;\n#include &lt;QString&gt;\n\nQString getCachePath()\n{\n    auto cachePath =\n      QStandardPaths::writableLocation(QStandardPaths::CacheLocation);\n    if (!QDir(cachePath).exists()) {\n        QDir().mkpath(cachePath);\n    }\n    return cachePath;\n}\n\nvoid setLastRegion(QRect const&amp; newRegion)\n{\n    auto cachePath = getCachePath() + \"/region.txt\";\n\n    QFile file(cachePath);\n    if (file.open(QIODevice::WriteOnly)) {\n        QDataStream out(&amp;file);\n        out &lt;&lt; newRegion;\n        file.close();\n    }\n}\n\nQRect getLastRegion()\n{\n    auto cachePath = getCachePath() + \"/region.txt\";\n    QFile file(cachePath);\n\n    QRect lastRegion;\n    if (file.open(QIODevice::ReadOnly)) {\n        QDataStream input(&amp;file);\n        input &gt;&gt; lastRegion;\n        file.close();\n    } else {\n        lastRegion = QRect(0, 0, 0, 0);\n    }\n\n    return lastRegion;\n}\n\n</code></pre>"},{"location":"flameshot/cacheutils_8h/","title":"File cacheutils.h","text":"<p>FileList &gt; config &gt; cacheutils.h</p> <p>Go to the source code of this file.</p>"},{"location":"flameshot/cacheutils_8h/#public-functions","title":"Public Functions","text":"Type Name QString getCachePath ()  QRect getLastRegion ()  void setLastRegion (QRect const &amp; newRegion)"},{"location":"flameshot/cacheutils_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/cacheutils_8h/#function-getcachepath","title":"function getCachePath","text":"<pre><code>QString getCachePath () \n</code></pre>"},{"location":"flameshot/cacheutils_8h/#function-getlastregion","title":"function getLastRegion","text":"<pre><code>QRect getLastRegion () \n</code></pre>"},{"location":"flameshot/cacheutils_8h/#function-setlastregion","title":"function setLastRegion","text":"<pre><code>void setLastRegion (\n    QRect const &amp; newRegion\n) \n</code></pre>"},{"location":"flameshot/cacheutils_8h_source/","title":"File cacheutils.h","text":"<p>File List &gt; config &gt; cacheutils.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Jeremy Borgman\n\n#ifndef FLAMESHOT_CACHEUTILS_H\n#define FLAMESHOT_CACHEUTILS_H\n\nclass QString;\nclass QRect;\n\nQString getCachePath();\nQRect getLastRegion();\nvoid setLastRegion(QRect const&amp; newRegion);\n\n#endif // FLAMESHOT_CACHEUTILS_H\n\n</code></pre>"},{"location":"flameshot/clickablelabel_8cpp/","title":"File clickablelabel.cpp","text":"<p>FileList &gt; config &gt; clickablelabel.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"clickablelabel.h\"</code></li> </ul>"},{"location":"flameshot/clickablelabel_8cpp_source/","title":"File clickablelabel.cpp","text":"<p>File List &gt; config &gt; clickablelabel.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"clickablelabel.h\"\n\nClickableLabel::ClickableLabel(QWidget* parent)\n  : QLabel(parent)\n{}\n\nClickableLabel::ClickableLabel(const QString&amp; s, QWidget* parent)\n  : QLabel(parent)\n{\n    setText(s);\n}\n\nvoid ClickableLabel::mousePressEvent(QMouseEvent*)\n{\n    emit clicked();\n}\n\n</code></pre>"},{"location":"flameshot/clickablelabel_8h/","title":"File clickablelabel.h","text":"<p>FileList &gt; config &gt; clickablelabel.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QLabel&gt;</code></li> </ul>"},{"location":"flameshot/clickablelabel_8h/#classes","title":"Classes","text":"Type Name class ClickableLabel"},{"location":"flameshot/clickablelabel_8h_source/","title":"File clickablelabel.h","text":"<p>File List &gt; config &gt; clickablelabel.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QLabel&gt;\n\nclass ClickableLabel : public QLabel\n{\n    Q_OBJECT\npublic:\n    explicit ClickableLabel(QWidget* parent = nullptr);\n    ClickableLabel(const QString&amp; s, QWidget* parent = nullptr);\n\nsignals:\n    void clicked();\n\nprivate:\n    void mousePressEvent(QMouseEvent*);\n};\n\n</code></pre>"},{"location":"flameshot/colorpickereditmode_8cpp/","title":"File colorpickereditmode.cpp","text":"<p>FileList &gt; config &gt; colorpickereditmode.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"colorpickereditmode.h\"</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/colorpickereditmode_8cpp_source/","title":"File colorpickereditmode.cpp","text":"<p>File List &gt; config &gt; colorpickereditmode.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2022 Dearsh Oberoi\n\n#include \"colorpickereditmode.h\"\n\n#include &lt;QMouseEvent&gt;\n#include &lt;QPainter&gt;\n\nColorPickerEditMode::ColorPickerEditMode(QWidget* parent)\n  : ColorPickerWidget(parent)\n{\n    m_isPressing = false;\n    m_isDragging = false;\n    installEventFilter(this);\n}\n\nbool ColorPickerEditMode::eventFilter(QObject* obj, QEvent* event)\n{\n    auto widget = static_cast&lt;QWidget*&gt;(obj);\n\n    switch (event-&gt;type()) {\n        case QEvent::MouseButtonPress: {\n            auto mouseEvent = static_cast&lt;QMouseEvent*&gt;(event);\n\n            if (mouseEvent-&gt;button() == Qt::LeftButton) {\n                m_mousePressPos = mouseEvent-&gt;pos();\n                m_mouseMovePos = m_mousePressPos;\n\n                for (int i = 1; i &lt; m_colorList.size(); ++i) {\n                    if (m_colorAreaList.at(i).contains(m_mousePressPos)) {\n                        m_isPressing = true;\n                        m_draggedPresetInitialPos =\n                          m_colorAreaList[i].topLeft();\n                        m_selectedIndex = i;\n                        update(m_colorAreaList.at(i) +\n                               QMargins(10, 10, 10, 10));\n                        update(m_colorAreaList.at(m_lastIndex) +\n                               QMargins(10, 10, 10, 10));\n                        m_lastIndex = i;\n                        emit colorSelected(m_selectedIndex);\n                        break;\n                    }\n                }\n            }\n        } break;\n        case QEvent::MouseMove: {\n            auto mouseEvent = static_cast&lt;QMouseEvent*&gt;(event);\n\n            if (m_isPressing) {\n                QPoint eventPos = mouseEvent-&gt;pos();\n                QPoint diff = eventPos - m_mouseMovePos;\n                m_colorAreaList[m_selectedIndex].translate(diff);\n                widget-&gt;update();\n\n                if (!m_isDragging) {\n                    QPoint totalMovedDiff = eventPos - m_mousePressPos;\n                    if (totalMovedDiff.manhattanLength() &gt; 3) {\n                        m_isDragging = true;\n                    }\n                }\n\n                m_mouseMovePos = eventPos;\n            }\n        } break;\n        case QEvent::MouseButtonRelease: {\n            m_isPressing = false;\n            if (m_isDragging) {\n                QPoint draggedPresetCenter =\n                  m_colorAreaList[m_selectedIndex].center();\n                m_isDragging = false;\n\n                bool swapped = false;\n\n                for (int i = 1; i &lt; m_colorList.size(); ++i) {\n                    if (i != m_selectedIndex &amp;&amp;\n                        m_colorAreaList.at(i).contains(draggedPresetCenter)) {\n                        // swap colors\n                        QColor temp = m_colorList[i];\n                        m_colorList[i] = m_colorList[m_selectedIndex];\n                        m_colorList[m_selectedIndex] = temp;\n                        m_config.setUserColors(m_colorList);\n\n                        m_colorAreaList[m_selectedIndex].moveTo(\n                          m_draggedPresetInitialPos);\n                        m_selectedIndex = i;\n                        widget-&gt;update();\n                        m_lastIndex = i;\n                        emit presetsSwapped(m_selectedIndex);\n                        swapped = true;\n                        break;\n                    }\n                }\n\n                if (!swapped) {\n                    m_colorAreaList[m_selectedIndex].moveTo(\n                      m_draggedPresetInitialPos);\n                    widget-&gt;update();\n                }\n            }\n        } break;\n        default:\n            break;\n    }\n\n    return QObject::eventFilter(obj, event);\n}\n\n</code></pre>"},{"location":"flameshot/colorpickereditmode_8h/","title":"File colorpickereditmode.h","text":"<p>FileList &gt; config &gt; colorpickereditmode.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/widgets/colorpickerwidget.h\"</code></li> </ul>"},{"location":"flameshot/colorpickereditmode_8h/#classes","title":"Classes","text":"Type Name class ColorPickerEditMode"},{"location":"flameshot/colorpickereditmode_8h_source/","title":"File colorpickereditmode.h","text":"<p>File List &gt; config &gt; colorpickereditmode.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2022 Dearsh Oberoi\n\n#pragma once\n\n#include \"src/utils/confighandler.h\"\n#include \"src/widgets/colorpickerwidget.h\"\n\nclass ColorPickerEditMode : public ColorPickerWidget\n{\n    Q_OBJECT\npublic:\n    explicit ColorPickerEditMode(QWidget* parent = nullptr);\n\nsignals:\n    void colorSelected(int index);\n    void presetsSwapped(int index);\n\nprivate:\n    bool eventFilter(QObject* obj, QEvent* event) override;\n\n    bool m_isPressing = false;\n    bool m_isDragging = false;\n    QPoint m_mouseMovePos;\n    QPoint m_mousePressPos;\n    QPoint m_draggedPresetInitialPos;\n    ConfigHandler m_config;\n};\n\n</code></pre>"},{"location":"flameshot/colorpickereditor_8cpp/","title":"File colorpickereditor.cpp","text":"<p>FileList &gt; config &gt; colorpickereditor.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"colorpickereditor.h\"</code></li> <li><code>#include \"colorpickereditmode.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QGridLayout&gt;</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QLineEdit&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> </ul>"},{"location":"flameshot/colorpickereditor_8cpp_source/","title":"File colorpickereditor.cpp","text":"<p>File List &gt; config &gt; colorpickereditor.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2022 Dearsh Oberoi\n\n#include \"colorpickereditor.h\"\n#include \"colorpickereditmode.h\"\n#include \"src/utils/globalvalues.h\"\n\n#include &lt;QApplication&gt;\n#include &lt;QColor&gt;\n#include &lt;QGridLayout&gt;\n#include &lt;QHBoxLayout&gt;\n#include &lt;QLabel&gt;\n#include &lt;QLineEdit&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QString&gt;\n#include &lt;QVector&gt;\n\nColorPickerEditor::ColorPickerEditor(QWidget* parent)\n  : QWidget(parent)\n  , m_selectedIndex(1)\n{\n    m_color = m_config.drawColor();\n    m_colorList = m_config.userColors();\n\n    m_gLayout = new QGridLayout(this);\n\n    m_colorpicker = new ColorPickerEditMode(this);\n    m_gLayout-&gt;addWidget(m_colorpicker, 0, 0);\n\n    m_colorWheel = new color_widgets::ColorWheel(this);\n    m_colorWheel-&gt;setColor(m_color);\n    const int size = GlobalValues::buttonBaseSize() * 3.5;\n    m_colorWheel-&gt;setMinimumSize(size, size);\n    m_gLayout-&gt;addWidget(m_colorWheel, 1, 0);\n\n    auto* m_vLocalLayout1 = new QVBoxLayout();\n    m_vLocalLayout1-&gt;addStretch();\n\n    m_colorEditLabel = new QLabel(tr(\"Edit Preset:\"), this);\n    m_vLocalLayout1-&gt;addWidget(m_colorEditLabel);\n\n    m_colorEdit = new QLineEdit(this);\n    m_colorEdit-&gt;setText(m_colorList[m_selectedIndex].name(QColor::HexRgb));\n    m_colorEdit-&gt;setToolTip(tr(\"Enter color to update preset\"));\n    connect(m_colorpicker,\n            &amp;ColorPickerEditMode::colorSelected,\n            this,\n            [this](int index) {\n                m_selectedIndex = index;\n                m_colorEdit-&gt;setText(\n                  m_colorList[m_selectedIndex].name(QColor::HexRgb));\n            });\n    connect(m_colorpicker,\n            &amp;ColorPickerEditMode::presetsSwapped,\n            this,\n            [this](int index) {\n                m_selectedIndex = index;\n                m_colorList = m_config.userColors();\n                m_colorEdit-&gt;setText(\n                  m_colorList[m_selectedIndex].name(QColor::HexRgb));\n            });\n    m_vLocalLayout1-&gt;addWidget(m_colorEdit);\n\n    m_updatePresetButton = new QPushButton(tr(\"Update\"), this);\n    m_updatePresetButton-&gt;setToolTip(\n      tr(\"Press button to update the selected preset\"));\n    connect(m_updatePresetButton,\n            &amp;QPushButton::pressed,\n            this,\n            &amp;ColorPickerEditor::onUpdatePreset);\n    m_vLocalLayout1-&gt;addWidget(m_updatePresetButton);\n\n    m_deletePresetButton = new QPushButton(tr(\"Delete\"), this);\n    m_deletePresetButton-&gt;setToolTip(\n      tr(\"Press button to delete the selected preset\"));\n    connect(m_deletePresetButton,\n            &amp;QPushButton::pressed,\n            this,\n            &amp;ColorPickerEditor::onDeletePreset);\n    m_vLocalLayout1-&gt;addWidget(m_deletePresetButton);\n\n    m_vLocalLayout1-&gt;addStretch();\n\n    m_gLayout-&gt;addLayout(m_vLocalLayout1, 0, 1);\n\n    auto* m_vLocalLayout2 = new QVBoxLayout();\n    m_vLocalLayout2-&gt;addStretch();\n\n    m_addPresetLabel = new QLabel(tr(\"Add Preset:\"), this);\n    m_vLocalLayout2-&gt;addWidget(m_addPresetLabel);\n\n    m_colorInput = new QLineEdit(this);\n    m_colorInput-&gt;setText(m_color.name(QColor::HexRgb));\n    m_colorInput-&gt;setToolTip(\n      tr(\"Enter color manually or select it using the color-wheel\"));\n    connect(m_colorWheel,\n            &amp;color_widgets::ColorWheel::colorSelected,\n            this,\n            [=](QColor c) {\n                m_color = c;\n                m_colorInput-&gt;setText(m_color.name(QColor::HexRgb));\n            });\n    m_vLocalLayout2-&gt;addWidget(m_colorInput);\n\n    m_addPresetButton = new QPushButton(tr(\"Add\"), this);\n    m_addPresetButton-&gt;setToolTip(tr(\"Press button to add preset\"));\n    connect(m_addPresetButton,\n            &amp;QPushButton::pressed,\n            this,\n            &amp;ColorPickerEditor::onAddPreset);\n    m_vLocalLayout2-&gt;addWidget(m_addPresetButton);\n\n    m_vLocalLayout2-&gt;addStretch();\n\n    m_gLayout-&gt;addLayout(m_vLocalLayout2, 1, 1);\n}\n\nvoid ColorPickerEditor::addPreset()\n{\n    if (m_colorList.contains(m_color)) {\n        return;\n    }\n\n    const int maxPresetsAllowed = 17;\n\n    if (m_colorList.size() &gt;= maxPresetsAllowed) {\n        QMessageBox::critical(\n          this,\n          tr(\"Error\"),\n          tr(\"Unable to add preset. Maximum limit reached.\"));\n        return;\n    }\n\n    m_colorList &lt;&lt; m_color;\n\n    m_config.setUserColors(m_colorList);\n}\n\nvoid ColorPickerEditor::deletePreset()\n{\n    const int minPresetsAllowed = 3;\n\n    if (m_colorList.size() &lt;= minPresetsAllowed) {\n        QMessageBox::critical(\n          this,\n          tr(\"Error\"),\n          tr(\"Unable to remove preset. Minimum limit reached.\"));\n        return;\n    }\n\n    m_colorList.remove(m_selectedIndex);\n\n    m_config.setUserColors(m_colorList);\n}\n\nvoid ColorPickerEditor::updatePreset()\n{\n    QColor c = QColor(m_colorEdit-&gt;text());\n\n    if (m_colorList.contains(c)) {\n        m_colorEdit-&gt;setText(m_colorList[m_selectedIndex].name(QColor::HexRgb));\n        return;\n    }\n\n    m_colorList[m_selectedIndex] = c;\n\n    m_config.setUserColors(m_colorList);\n}\n\nvoid ColorPickerEditor::onAddPreset()\n{\n    if (QColor::isValidColor(m_colorInput-&gt;text())) {\n        m_color = QColor(m_colorInput-&gt;text());\n        m_colorInput-&gt;setText(m_color.name(QColor::HexRgb));\n    } else {\n        m_colorInput-&gt;setText(m_color.name(QColor::HexRgb));\n        return;\n    }\n\n    addPreset();\n    m_colorpicker-&gt;updateWidget();\n    m_selectedIndex = 1;\n    m_colorpicker-&gt;updateSelection(m_selectedIndex);\n    m_colorEdit-&gt;setText(m_colorList[m_selectedIndex].name(QColor::HexRgb));\n}\n\nvoid ColorPickerEditor::onDeletePreset()\n{\n    deletePreset();\n    m_colorpicker-&gt;updateWidget();\n    m_selectedIndex = 1;\n    m_colorpicker-&gt;updateSelection(m_selectedIndex);\n    m_colorEdit-&gt;setText(m_colorList[m_selectedIndex].name(QColor::HexRgb));\n}\n\nvoid ColorPickerEditor::onUpdatePreset()\n{\n    if (QColor::isValidColor(m_colorEdit-&gt;text())) {\n        QColor c = QColor(m_colorEdit-&gt;text());\n        m_colorEdit-&gt;setText(c.name(QColor::HexRgb));\n    } else {\n        m_colorEdit-&gt;setText(m_colorList[m_selectedIndex].name(QColor::HexRgb));\n        return;\n    }\n\n    updatePreset();\n    m_colorpicker-&gt;updateWidget();\n}\n\n</code></pre>"},{"location":"flameshot/colorpickereditor_8h/","title":"File colorpickereditor.h","text":"<p>FileList &gt; config &gt; colorpickereditor.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"QtColorWidgets/color_wheel.hpp\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/colorpickereditor_8h/#classes","title":"Classes","text":"Type Name class ColorPickerEditor"},{"location":"flameshot/colorpickereditor_8h_source/","title":"File colorpickereditor.h","text":"<p>File List &gt; config &gt; colorpickereditor.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2022 Dearsh Oberoi\n\n#pragma once\n\n#include \"QtColorWidgets/color_wheel.hpp\"\n#include \"src/utils/confighandler.h\"\n\n#include &lt;QWidget&gt;\n\nclass ColorPickerEditMode;\nclass QLabel;\nclass QPushButton;\nclass QLineEdit;\nclass QColor;\nclass QGridLayout;\n\nclass ColorPickerEditor : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit ColorPickerEditor(QWidget* parent = nullptr);\n\nprivate slots:\n    void onAddPreset();\n    void onDeletePreset();\n    void onUpdatePreset();\n\nprivate:\n    void addPreset();\n    void deletePreset();\n    void updatePreset();\n\n    ColorPickerEditMode* m_colorpicker;\n    color_widgets::ColorWheel* m_colorWheel;\n\n    QLabel* m_colorEditLabel;\n    QLineEdit* m_colorEdit;\n    QPushButton* m_deletePresetButton;\n    QPushButton* m_updatePresetButton;\n\n    QLineEdit* m_colorInput;\n    QLabel* m_addPresetLabel;\n    QPushButton* m_addPresetButton;\n\n    QColor m_color;\n    int m_selectedIndex;\n    QVector&lt;QColor&gt; m_colorList;\n    ConfigHandler m_config;\n\n    QGridLayout* m_gLayout;\n};\n\n</code></pre>"},{"location":"flameshot/configerrordetails_8cpp/","title":"File configerrordetails.cpp","text":"<p>FileList &gt; config &gt; configerrordetails.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/config/configerrordetails.h\"</code></li> <li><code>#include \"src/utils/abstractlogger.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDialogButtonBox&gt;</code></li> <li><code>#include &lt;QTextEdit&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/configerrordetails_8cpp_source/","title":"File configerrordetails.cpp","text":"<p>File List &gt; config &gt; configerrordetails.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"src/config/configerrordetails.h\"\n\n#include \"src/utils/abstractlogger.h\"\n#include \"src/utils/confighandler.h\"\n\n#include &lt;QApplication&gt;\n#include &lt;QDialogButtonBox&gt;\n#include &lt;QTextEdit&gt;\n#include &lt;QVBoxLayout&gt;\n\nConfigErrorDetails::ConfigErrorDetails(QWidget* parent)\n  : QDialog(parent)\n{\n    // Generate error log message\n    QString str;\n    AbstractLogger stream(str, AbstractLogger::Error);\n    ConfigHandler().checkForErrors(&amp;stream);\n\n    // Set up dialog\n    setWindowTitle(tr(\"Configuration errors\"));\n    setLayout(new QVBoxLayout(this));\n\n    // Add text display\n    auto* textDisplay = new QTextEdit(this);\n    textDisplay-&gt;setPlainText(str);\n    textDisplay-&gt;setReadOnly(true);\n    layout()-&gt;addWidget(textDisplay);\n\n    // Add Ok button\n    using BBox = QDialogButtonBox;\n    BBox* buttons = new BBox(BBox::Ok);\n    layout()-&gt;addWidget(buttons);\n    connect(buttons, &amp;BBox::clicked, this, [this]() { close(); });\n\n    show();\n\n    qApp-&gt;processEvents();\n    QPoint center = geometry().center();\n    QRect dialogRect(0, 0, 600, 400);\n    dialogRect.moveCenter(center);\n    setGeometry(dialogRect);\n}\n\n</code></pre>"},{"location":"flameshot/configerrordetails_8h/","title":"File configerrordetails.h","text":"<p>FileList &gt; config &gt; configerrordetails.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QDialog&gt;</code></li> </ul>"},{"location":"flameshot/configerrordetails_8h/#classes","title":"Classes","text":"Type Name class ConfigErrorDetails"},{"location":"flameshot/configerrordetails_8h_source/","title":"File configerrordetails.h","text":"<p>File List &gt; config &gt; configerrordetails.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include &lt;QDialog&gt;\n\n#pragma once\n\nclass ConfigErrorDetails : public QDialog\n{\npublic:\n    ConfigErrorDetails(QWidget* parent = nullptr);\n};\n\n</code></pre>"},{"location":"flameshot/configresolver_8cpp/","title":"File configresolver.cpp","text":"<p>FileList &gt; config &gt; configresolver.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/config/configresolver.h\"</code></li> <li><code>#include \"src/config/configerrordetails.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/valuehandler.h\"</code></li> <li><code>#include &lt;QDialogButtonBox&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QSplitter&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/configresolver_8cpp_source/","title":"File configresolver.cpp","text":"<p>File List &gt; config &gt; configresolver.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"src/config/configresolver.h\"\n#include \"src/config/configerrordetails.h\"\n#include \"src/utils/confighandler.h\"\n\n#include \"src/utils/valuehandler.h\"\n#include &lt;QDialogButtonBox&gt;\n#include &lt;QLabel&gt;\n#include &lt;QSplitter&gt;\n#include &lt;QVBoxLayout&gt;\n\nConfigResolver::ConfigResolver(QWidget* parent)\n  : QDialog(parent)\n{\n    setWindowTitle(tr(\"Resolve configuration errors\"));\n    setMinimumSize({ 250, 200 });\n    setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Maximum);\n    populate();\n    connect(ConfigHandler::getInstance(),\n            &amp;ConfigHandler::fileChanged,\n            this,\n            [this]() { populate(); });\n}\n\nQGridLayout* ConfigResolver::layout()\n{\n    return dynamic_cast&lt;QGridLayout*&gt;(QDialog::layout());\n}\n\nvoid ConfigResolver::populate()\n{\n    ConfigHandler config;\n    QList&lt;QString&gt; unrecognized;\n    QList&lt;QString&gt; semanticallyWrong;\n\n    config.checkUnrecognizedSettings(nullptr, &amp;unrecognized);\n    config.checkSemantics(nullptr, &amp;semanticallyWrong);\n\n    // Remove previous layout and children, if any\n    resetLayout();\n\n    bool anyErrors = !semanticallyWrong.isEmpty() || !unrecognized.isEmpty();\n    int row = 0;\n\n    // No errors detected\n    if (!anyErrors) {\n        accept();\n    } else {\n        layout()-&gt;addWidget(\n          new QLabel(\n            tr(\"&lt;b&gt;You must resolve all errors before continuing:&lt;/b&gt;\")),\n          0,\n          0,\n          1,\n          2);\n        ++row;\n    }\n\n    // List semantically incorrect settings with a \"Reset\" button\n    for (const auto&amp; key : semanticallyWrong) {\n        auto* label = new QLabel(key);\n        auto* reset = new QPushButton(tr(\"Reset\"));\n        label-&gt;setToolTip(\"This setting has a bad value.\");\n        reset-&gt;setToolTip(tr(\"Reset to the default value.\"));\n        layout()-&gt;addWidget(label, row, 0);\n        layout()-&gt;addWidget(reset, row, 1);\n        reset-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);\n\n        connect(reset, &amp;QPushButton::clicked, this, [key]() {\n            ConfigHandler().resetValue(key);\n        });\n\n        ++row;\n    }\n    // List unrecognized settings with a \"Remove\" button\n    for (const auto&amp; key : unrecognized) {\n        auto* label = new QLabel(key);\n        auto* remove = new QPushButton(tr(\"Remove\"));\n        label-&gt;setToolTip(\"This setting is unrecognized.\");\n        remove-&gt;setToolTip(tr(\"Remove this setting.\"));\n        layout()-&gt;addWidget(label, row, 0);\n        layout()-&gt;addWidget(remove, row, 1);\n        connect(remove, &amp;QPushButton::clicked, this, [key]() {\n            ConfigHandler().remove(key);\n        });\n        ++row;\n    }\n\n    if (!config.checkShortcutConflicts()) {\n        auto* conflicts = new QLabel(\n          tr(\"Some keyboard shortcuts have conflicts.\\n\"\n             \"This will NOT prevent flameshot from starting.\\n\"\n             \"Please solve them manually in the configuration file.\"));\n        conflicts-&gt;setWordWrap(true);\n        conflicts-&gt;setMaximumWidth(geometry().width());\n        conflicts-&gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);\n        layout()-&gt;addWidget(conflicts, row, 0, 1, 2, Qt::AlignCenter);\n        ++row;\n    }\n\n    auto* separator = new QFrame(this);\n    separator-&gt;setFrameShape(QFrame::HLine);\n    separator-&gt;setFrameShadow(QFrame::Sunken);\n    layout()-&gt;addWidget(separator, row, 0, 1, 2);\n    ++row;\n\n    using BBox = QDialogButtonBox;\n\n    // Add button box at the bottom\n    auto* buttons = new BBox(this);\n    layout()-&gt;addWidget(buttons, row, 0, 1, 2, Qt::AlignCenter);\n    if (anyErrors) {\n        auto* resolveAll = new QPushButton(tr(\"Resolve all\"));\n        resolveAll-&gt;setToolTip(tr(\"Resolve all listed errors.\"));\n        buttons-&gt;addButton(resolveAll, BBox::ResetRole);\n        connect(resolveAll, &amp;QPushButton::clicked, this, [=]() {\n            for (const auto&amp; key : semanticallyWrong) {\n                ConfigHandler().resetValue(key);\n            }\n            for (const auto&amp; key : unrecognized) {\n                ConfigHandler().remove(key);\n            }\n        });\n    }\n\n    auto* details = new QPushButton(tr(\"Details\"));\n    buttons-&gt;addButton(details, BBox::HelpRole);\n    connect(details, &amp;QPushButton::clicked, this, [this]() {\n        (new ConfigErrorDetails(this))-&gt;exec();\n    });\n\n    buttons-&gt;addButton(BBox::Cancel);\n\n    connect(buttons, &amp;BBox::rejected, this, [this]() { reject(); });\n}\n\nvoid ConfigResolver::resetLayout()\n{\n    for (auto* child : children()) {\n        child-&gt;deleteLater();\n    }\n    delete layout();\n    setLayout(new QGridLayout());\n    layout()-&gt;setSizeConstraint(QLayout::SetFixedSize);\n}\n\n</code></pre>"},{"location":"flameshot/configresolver_8h/","title":"File configresolver.h","text":"<p>FileList &gt; config &gt; configresolver.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QDialog&gt;</code></li> </ul>"},{"location":"flameshot/configresolver_8h/#classes","title":"Classes","text":"Type Name class ConfigResolver"},{"location":"flameshot/configresolver_8h_source/","title":"File configresolver.h","text":"<p>File List &gt; config &gt; configresolver.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#pragma once\n\n#include &lt;QDialog&gt;\n\nclass QGridLayout;\n\nclass ConfigResolver : public QDialog\n{\npublic:\n    ConfigResolver(QWidget* parent = nullptr);\n\n    QGridLayout* layout();\n\nprivate:\n    void populate();\n    void resetLayout();\n};\n\n</code></pre>"},{"location":"flameshot/configwindow_8cpp/","title":"File configwindow.cpp","text":"<p>FileList &gt; config &gt; configwindow.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"configwindow.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/config/configresolver.h\"</code></li> <li><code>#include \"src/config/filenameeditor.h\"</code></li> <li><code>#include \"src/config/generalconf.h\"</code></li> <li><code>#include \"src/config/shortcutswidget.h\"</code></li> <li><code>#include \"src/config/strftimechooserwidget.h\"</code></li> <li><code>#include \"src/config/visualseditor.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"src/utils/pathinfo.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDialogButtonBox&gt;</code></li> <li><code>#include &lt;QFileSystemWatcher&gt;</code></li> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QSizePolicy&gt;</code></li> <li><code>#include &lt;QTabBar&gt;</code></li> <li><code>#include &lt;QTextStream&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/configwindow_8cpp_source/","title":"File configwindow.cpp","text":"<p>File List &gt; config &gt; configwindow.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"configwindow.h\"\n#include \"abstractlogger.h\"\n#include \"src/config/configresolver.h\"\n#include \"src/config/filenameeditor.h\"\n#include \"src/config/generalconf.h\"\n#include \"src/config/shortcutswidget.h\"\n#include \"src/config/strftimechooserwidget.h\"\n#include \"src/config/visualseditor.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"src/utils/pathinfo.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDialogButtonBox&gt;\n#include &lt;QFileSystemWatcher&gt;\n#include &lt;QIcon&gt;\n#include &lt;QKeyEvent&gt;\n#include &lt;QLabel&gt;\n#include &lt;QSizePolicy&gt;\n#include &lt;QTabBar&gt;\n#include &lt;QTextStream&gt;\n#include &lt;QVBoxLayout&gt;\n\n// ConfigWindow contains the menus where you can configure the application\n\nConfigWindow::ConfigWindow(QWidget* parent)\n  : QWidget(parent)\n{\n    // We wrap QTabWidget in a QWidget because of a Qt bug\n    auto* layout = new QVBoxLayout(this);\n    m_tabWidget = new QTabWidget(this);\n    m_tabWidget-&gt;tabBar()-&gt;setUsesScrollButtons(false);\n    layout-&gt;addWidget(m_tabWidget);\n\n    setAttribute(Qt::WA_DeleteOnClose);\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    setWindowTitle(tr(\"Configuration\"));\n\n    connect(ConfigHandler::getInstance(),\n            &amp;ConfigHandler::fileChanged,\n            this,\n            &amp;ConfigWindow::updateChildren);\n\n    QColor background = this-&gt;palette().window().color();\n    bool isDark = ColorUtils::colorIsDark(background);\n    QString modifier =\n      isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();\n\n    // visuals\n    m_visuals = new VisualsEditor();\n    m_visualsTab = new QWidget();\n    auto* visualsLayout = new QVBoxLayout(m_visualsTab);\n    m_visualsTab-&gt;setLayout(visualsLayout);\n    visualsLayout-&gt;addWidget(m_visuals);\n    m_tabWidget-&gt;addTab(\n      m_visualsTab, QIcon(modifier + \"graphics.svg\"), tr(\"Interface\"));\n\n    // filename\n    m_filenameEditor = new FileNameEditor();\n    m_filenameEditorTab = new QWidget();\n    auto* filenameEditorLayout = new QVBoxLayout(m_filenameEditorTab);\n    m_filenameEditorTab-&gt;setLayout(filenameEditorLayout);\n    filenameEditorLayout-&gt;addWidget(m_filenameEditor);\n    m_tabWidget-&gt;addTab(m_filenameEditorTab,\n                        QIcon(modifier + \"name_edition.svg\"),\n                        tr(\"Filename Editor\"));\n\n    // general\n    m_generalConfig = new GeneralConf();\n    m_generalConfigTab = new QWidget();\n    auto* generalConfigLayout = new QVBoxLayout(m_generalConfigTab);\n    m_generalConfigTab-&gt;setLayout(generalConfigLayout);\n    generalConfigLayout-&gt;addWidget(m_generalConfig);\n    m_tabWidget-&gt;addTab(\n      m_generalConfigTab, QIcon(modifier + \"config.svg\"), tr(\"General\"));\n\n    // shortcuts\n    m_shortcuts = new ShortcutsWidget();\n    m_shortcutsTab = new QWidget();\n    auto* shortcutsLayout = new QVBoxLayout(m_shortcutsTab);\n    m_shortcutsTab-&gt;setLayout(shortcutsLayout);\n    shortcutsLayout-&gt;addWidget(m_shortcuts);\n    m_tabWidget-&gt;addTab(\n      m_shortcutsTab, QIcon(modifier + \"shortcut.svg\"), tr(\"Shortcuts\"));\n\n    // connect update sigslots\n    connect(this,\n            &amp;ConfigWindow::updateChildren,\n            m_filenameEditor,\n            &amp;FileNameEditor::updateComponents);\n    connect(this,\n            &amp;ConfigWindow::updateChildren,\n            m_visuals,\n            &amp;VisualsEditor::updateComponents);\n    connect(this,\n            &amp;ConfigWindow::updateChildren,\n            m_generalConfig,\n            &amp;GeneralConf::updateComponents);\n\n    // Error indicator (this must come last)\n    initErrorIndicator(m_visualsTab, m_visuals);\n    initErrorIndicator(m_filenameEditorTab, m_filenameEditor);\n    initErrorIndicator(m_generalConfigTab, m_generalConfig);\n    initErrorIndicator(m_shortcutsTab, m_shortcuts);\n}\n\nvoid ConfigWindow::keyPressEvent(QKeyEvent* e)\n{\n    if (e-&gt;key() == Qt::Key_Escape) {\n        close();\n    }\n}\n\nvoid ConfigWindow::initErrorIndicator(QWidget* tab, QWidget* widget)\n{\n    auto* label = new QLabel(tab);\n    auto* btnResolve = new QPushButton(tr(\"Resolve\"), tab);\n    auto* btnLayout = new QHBoxLayout();\n\n    // Set up label\n    label-&gt;setText(tr(\n      \"&lt;b&gt;Configuration file has errors. Resolve them before continuing.&lt;/b&gt;\"));\n    label-&gt;setStyleSheet(QStringLiteral(\":disabled { color: %1; }\")\n                           .arg(qApp-&gt;palette().color(QPalette::Text).name()));\n    label-&gt;setVisible(ConfigHandler().hasError());\n\n    // Set up \"Show errors\" button\n    btnResolve-&gt;setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Fixed);\n    btnLayout-&gt;addWidget(btnResolve);\n    btnResolve-&gt;setVisible(ConfigHandler().hasError());\n\n    widget-&gt;setEnabled(!ConfigHandler().hasError());\n\n    // Add label and button to the parent widget's layout\n    auto* layout = static_cast&lt;QBoxLayout*&gt;(tab-&gt;layout());\n    if (layout != nullptr) {\n        layout-&gt;insertWidget(0, label);\n        layout-&gt;insertLayout(1, btnLayout);\n    } else {\n        widget-&gt;layout()-&gt;addWidget(label);\n        widget-&gt;layout()-&gt;addWidget(btnResolve);\n    }\n\n    // Sigslots\n    connect(ConfigHandler::getInstance(), &amp;ConfigHandler::error, widget, [=]() {\n        widget-&gt;setEnabled(false);\n        label-&gt;show();\n        btnResolve-&gt;show();\n    });\n    connect(ConfigHandler::getInstance(),\n            &amp;ConfigHandler::errorResolved,\n            widget,\n            [=]() {\n                widget-&gt;setEnabled(true);\n                label-&gt;hide();\n                btnResolve-&gt;hide();\n            });\n    connect(btnResolve, &amp;QPushButton::clicked, this, [this]() {\n        ConfigResolver().exec();\n    });\n}\n\n</code></pre>"},{"location":"flameshot/configwindow_8h/","title":"File configwindow.h","text":"<p>FileList &gt; config &gt; configwindow.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QTabWidget&gt;</code></li> </ul>"},{"location":"flameshot/configwindow_8h/#classes","title":"Classes","text":"Type Name class ConfigWindow"},{"location":"flameshot/configwindow_8h_source/","title":"File configwindow.h","text":"<p>File List &gt; config &gt; configwindow.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QTabWidget&gt;\n\nclass FileNameEditor;\nclass ShortcutsWidget;\nclass GeneralConf;\nclass QFileSystemWatcher;\nclass VisualsEditor;\nclass QWidget;\n\nclass ConfigWindow : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit ConfigWindow(QWidget* parent = nullptr);\n\nsignals:\n    void updateChildren();\n\nprotected:\n    void keyPressEvent(QKeyEvent*);\n\nprivate:\n    QTabWidget* m_tabWidget;\n\n    FileNameEditor* m_filenameEditor;\n    QWidget* m_filenameEditorTab;\n\n    ShortcutsWidget* m_shortcuts;\n    QWidget* m_shortcutsTab;\n\n    GeneralConf* m_generalConfig;\n    QWidget* m_generalConfigTab;\n\n    VisualsEditor* m_visuals;\n    QWidget* m_visualsTab;\n\n    void initErrorIndicator(QWidget* tab, QWidget* widget);\n};\n\n</code></pre>"},{"location":"flameshot/extendedslider_8cpp/","title":"File extendedslider.cpp","text":"<p>FileList &gt; config &gt; extendedslider.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"extendedslider.h\"</code></li> </ul>"},{"location":"flameshot/extendedslider_8cpp_source/","title":"File extendedslider.cpp","text":"<p>File List &gt; config &gt; extendedslider.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"extendedslider.h\"\n\nExtendedSlider::ExtendedSlider(QWidget* parent)\n  : QSlider(parent)\n{\n    connect(this,\n            &amp;ExtendedSlider::valueChanged,\n            this,\n            &amp;ExtendedSlider::updateTooltip);\n    connect(\n      this, &amp;ExtendedSlider::sliderMoved, this, &amp;ExtendedSlider::fireTimer);\n    m_timer.setSingleShot(true);\n    connect(\n      &amp;m_timer, &amp;QTimer::timeout, this, &amp;ExtendedSlider::modificationsEnded);\n}\n\nint ExtendedSlider::mappedValue(int min, int max)\n{\n    qreal progress =\n      ((value() - minimum())) / static_cast&lt;qreal&gt;(maximum() - minimum());\n    return min + (max - min) * progress;\n}\n\nvoid ExtendedSlider::setMapedValue(int min, int val, int max)\n{\n    qreal progress = ((val - min) + 1) / static_cast&lt;qreal&gt;(max - min);\n    int value = minimum() + (maximum() - minimum()) * progress;\n    setValue(value);\n}\n\nvoid ExtendedSlider::updateTooltip()\n{\n    setToolTip(QString::number(value()) + \"%\");\n}\n\nvoid ExtendedSlider::fireTimer()\n{\n    m_timer.start(500);\n}\n\n</code></pre>"},{"location":"flameshot/extendedslider_8h/","title":"File extendedslider.h","text":"<p>FileList &gt; config &gt; extendedslider.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QSlider&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> </ul>"},{"location":"flameshot/extendedslider_8h/#classes","title":"Classes","text":"Type Name class ExtendedSlider"},{"location":"flameshot/extendedslider_8h_source/","title":"File extendedslider.h","text":"<p>File List &gt; config &gt; extendedslider.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QSlider&gt;\n#include &lt;QTimer&gt;\n\nclass ExtendedSlider : public QSlider\n{\n    Q_OBJECT\npublic:\n    explicit ExtendedSlider(QWidget* parent = nullptr);\n\n    int mappedValue(int min, int max);\n    void setMapedValue(int min, int val, int max);\n\nsignals:\n    void modificationsEnded();\n\nprivate slots:\n    void updateTooltip();\n    void fireTimer();\n\nprivate:\n    QTimer m_timer;\n};\n\n</code></pre>"},{"location":"flameshot/filenameeditor_8cpp/","title":"File filenameeditor.cpp","text":"<p>FileList &gt; config &gt; filenameeditor.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"filenameeditor.h\"</code></li> <li><code>#include \"src/config/strftimechooserwidget.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/filenamehandler.h\"</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QLineEdit&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/filenameeditor_8cpp_source/","title":"File filenameeditor.cpp","text":"<p>File List &gt; config &gt; filenameeditor.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"filenameeditor.h\"\n#include \"src/config/strftimechooserwidget.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/filenamehandler.h\"\n#include &lt;QHBoxLayout&gt;\n#include &lt;QLabel&gt;\n#include &lt;QLineEdit&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QVBoxLayout&gt;\n\nFileNameEditor::FileNameEditor(QWidget* parent)\n  : QWidget(parent)\n{\n    initWidgets();\n    initLayout();\n}\n\nvoid FileNameEditor::initLayout()\n{\n    m_layout = new QVBoxLayout(this);\n    auto* infoLabel = new QLabel(tr(\"Edit the name of your captures:\"), this);\n    infoLabel-&gt;setFixedHeight(20);\n    m_layout-&gt;addWidget(infoLabel);\n    m_layout-&gt;addWidget(m_helperButtons);\n    m_layout-&gt;addWidget(new QLabel(tr(\"Edit:\")));\n    m_layout-&gt;addWidget(m_nameEditor);\n    m_layout-&gt;addWidget(new QLabel(tr(\"Preview:\")));\n    m_layout-&gt;addWidget(m_outputLabel);\n\n    auto* horizLayout = new QHBoxLayout();\n    horizLayout-&gt;addWidget(m_saveButton);\n    horizLayout-&gt;addWidget(m_resetButton);\n    horizLayout-&gt;addWidget(m_clearButton);\n    m_layout-&gt;addLayout(horizLayout);\n}\n\nvoid FileNameEditor::initWidgets()\n{\n    m_nameHandler = new FileNameHandler(this);\n\n    // editor\n    m_nameEditor = new QLineEdit(this);\n    m_nameEditor-&gt;setMaxLength(FileNameHandler::MAX_CHARACTERS);\n\n    // preview\n    m_outputLabel = new QLineEdit(this);\n    m_outputLabel-&gt;setDisabled(true);\n    QString foreground = this-&gt;palette().windowText().color().name();\n    m_outputLabel-&gt;setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground));\n    QPalette pal = m_outputLabel-&gt;palette();\n    QColor color =\n      pal.color(QPalette::Disabled, m_outputLabel-&gt;backgroundRole());\n    pal.setColor(QPalette::Active, m_outputLabel-&gt;backgroundRole(), color);\n    m_outputLabel-&gt;setPalette(pal);\n\n    connect(m_nameEditor,\n            &amp;QLineEdit::textChanged,\n            this,\n            &amp;FileNameEditor::showParsedPattern);\n    updateComponents();\n\n    // helper buttons\n    m_helperButtons = new StrftimeChooserWidget(this);\n    connect(m_helperButtons,\n            &amp;StrftimeChooserWidget::variableEmitted,\n            this,\n            &amp;FileNameEditor::addToNameEditor);\n\n    // save\n    m_saveButton = new QPushButton(tr(\"Save\"), this);\n    connect(\n      m_saveButton, &amp;QPushButton::clicked, this, &amp;FileNameEditor::savePattern);\n    m_saveButton-&gt;setToolTip(tr(\"Saves the pattern\"));\n    // restore previous saved values\n    m_resetButton = new QPushButton(tr(\"Restore\"), this);\n    connect(\n      m_resetButton, &amp;QPushButton::clicked, this, &amp;FileNameEditor::resetName);\n    m_resetButton-&gt;setToolTip(tr(\"Restores the saved pattern\"));\n    // clear\n    m_clearButton = new QPushButton(tr(\"Clear\"), this);\n    connect(m_clearButton, &amp;QPushButton::clicked, this, [this]() {\n        m_nameEditor-&gt;setText(ConfigHandler().filenamePatternDefault());\n        m_nameEditor-&gt;selectAll();\n        m_nameEditor-&gt;setFocus();\n    });\n    m_clearButton-&gt;setToolTip(tr(\"Deletes the name\"));\n}\n\nvoid FileNameEditor::savePattern()\n{\n    QString pattern = m_nameEditor-&gt;text();\n    ConfigHandler().setFilenamePattern(pattern);\n}\n\nvoid FileNameEditor::showParsedPattern(const QString&amp; p)\n{\n    QString output = m_nameHandler-&gt;parseFilename(p);\n    m_outputLabel-&gt;setText(output);\n}\n\nvoid FileNameEditor::resetName()\n{\n    m_nameEditor-&gt;setText(ConfigHandler().filenamePattern());\n}\n\nvoid FileNameEditor::addToNameEditor(const QString&amp; s)\n{\n    m_nameEditor-&gt;setText(m_nameEditor-&gt;text() + s);\n    m_nameEditor-&gt;setFocus();\n}\n\nvoid FileNameEditor::updateComponents()\n{\n    m_nameEditor-&gt;setText(ConfigHandler().filenamePattern());\n    m_outputLabel-&gt;setText(m_nameHandler-&gt;parsedPattern());\n}\n\n</code></pre>"},{"location":"flameshot/filenameeditor_8h/","title":"File filenameeditor.h","text":"<p>FileList &gt; config &gt; filenameeditor.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/filenameeditor_8h/#classes","title":"Classes","text":"Type Name class FileNameEditor"},{"location":"flameshot/filenameeditor_8h_source/","title":"File filenameeditor.h","text":"<p>File List &gt; config &gt; filenameeditor.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QPointer&gt;\n#include &lt;QWidget&gt;\n\nclass QVBoxLayout;\nclass QLineEdit;\nclass FileNameHandler;\nclass QPushButton;\nclass StrftimeChooserWidget;\n\nclass FileNameEditor : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit FileNameEditor(QWidget* parent = nullptr);\n\nprivate:\n    QVBoxLayout* m_layout;\n    QLineEdit* m_outputLabel;\n    QLineEdit* m_nameEditor;\n    FileNameHandler* m_nameHandler;\n    StrftimeChooserWidget* m_helperButtons;\n    QPushButton* m_saveButton;\n    QPushButton* m_resetButton;\n    QPushButton* m_clearButton;\n\n    void initLayout();\n    void initWidgets();\n\npublic slots:\n    void addToNameEditor(const QString&amp; s);\n    void updateComponents();\n\nprivate slots:\n    void savePattern();\n    void showParsedPattern(const QString&amp;);\n    void resetName();\n};\n\n</code></pre>"},{"location":"flameshot/generalconf_8cpp/","title":"File generalconf.cpp","text":"<p>FileList &gt; config &gt; generalconf.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"generalconf.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QCheckBox&gt;</code></li> <li><code>#include &lt;QComboBox&gt;</code></li> <li><code>#include &lt;QFile&gt;</code></li> <li><code>#include &lt;QFileDialog&gt;</code></li> <li><code>#include &lt;QGroupBox&gt;</code></li> <li><code>#include &lt;QImageWriter&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QLineEdit&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QSettings&gt;</code></li> <li><code>#include &lt;QSizePolicy&gt;</code></li> <li><code>#include &lt;QSpinBox&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> <li><code>#include &lt;QTextCodec&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/generalconf_8cpp_source/","title":"File generalconf.cpp","text":"<p>File List &gt; config &gt; generalconf.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n#include \"generalconf.h\"\n#include \"src/core/flameshot.h\"\n#include \"src/utils/confighandler.h\"\n#include &lt;QCheckBox&gt;\n#include &lt;QComboBox&gt;\n#include &lt;QFile&gt;\n#include &lt;QFileDialog&gt;\n#include &lt;QGroupBox&gt;\n#include &lt;QImageWriter&gt;\n#include &lt;QLabel&gt;\n#include &lt;QLineEdit&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QSettings&gt;\n#include &lt;QSizePolicy&gt;\n#include &lt;QSpinBox&gt;\n#include &lt;QStandardPaths&gt;\n#include &lt;QTextCodec&gt;\n#include &lt;QVBoxLayout&gt;\n\nGeneralConf::GeneralConf(QWidget* parent)\n  : QWidget(parent)\n  , m_historyConfirmationToDelete(nullptr)\n  , m_undoLimit(nullptr)\n{\n    m_layout = new QVBoxLayout(this);\n    m_layout-&gt;setAlignment(Qt::AlignTop);\n\n    // Scroll area adapts the size of the content on small screens.\n    // It must be initialized before the checkboxes.\n    initScrollArea();\n\n    initAutostart();\n#if !defined(Q_OS_WIN)\n    initAutoCloseIdleDaemon();\n#endif\n    initShowTrayIcon();\n    initShowDesktopNotification();\n#if !defined(DISABLE_UPDATE_CHECKER)\n    initCheckForUpdates();\n#endif\n    initShowStartupLaunchMessage();\n    initAllowMultipleGuiInstances();\n    initSaveLastRegion();\n    initShowHelp();\n    initShowSidePanelButton();\n    initUseJpgForClipboard();\n    initCopyOnDoubleClick();\n    initSaveAfterCopy();\n    initCopyPathAfterSave();\n    initCopyAndCloseAfterUpload();\n    initUploadWithoutConfirmation();\n    initHistoryConfirmationToDelete();\n    initAntialiasingPinZoom();\n    initUploadHistoryMax();\n    initUndoLimit();\n    initUploadClientSecret();\n    initPredefinedColorPaletteLarge();\n    initShowSelectionGeometry();\n\n    m_layout-&gt;addStretch();\n\n    initShowMagnifier();\n    initSquareMagnifier();\n    initJpegQuality();\n    // this has to be at the end\n    initConfigButtons();\n    updateComponents();\n}\n\nvoid GeneralConf::_updateComponents(bool allowEmptySavePath)\n{\n    ConfigHandler config;\n    m_helpMessage-&gt;setChecked(config.showHelp());\n    m_sidePanelButton-&gt;setChecked(config.showSidePanelButton());\n    m_sysNotifications-&gt;setChecked(config.showDesktopNotification());\n    m_autostart-&gt;setChecked(config.startupLaunch());\n    m_copyURLAfterUpload-&gt;setChecked(config.copyURLAfterUpload());\n    m_saveAfterCopy-&gt;setChecked(config.saveAfterCopy());\n    m_copyPathAfterSave-&gt;setChecked(config.copyPathAfterSave());\n    m_antialiasingPinZoom-&gt;setChecked(config.antialiasingPinZoom());\n    m_useJpgForClipboard-&gt;setChecked(config.useJpgForClipboard());\n    m_copyOnDoubleClick-&gt;setChecked(config.copyOnDoubleClick());\n    m_uploadWithoutConfirmation-&gt;setChecked(config.uploadWithoutConfirmation());\n    m_historyConfirmationToDelete-&gt;setChecked(\n      config.historyConfirmationToDelete());\n#if !defined(DISABLE_UPDATE_CHECKER)\n    m_checkForUpdates-&gt;setChecked(config.checkForUpdates());\n#endif\n    m_allowMultipleGuiInstances-&gt;setChecked(config.allowMultipleGuiInstances());\n    m_showMagnifier-&gt;setChecked(config.showMagnifier());\n    m_squareMagnifier-&gt;setChecked(config.squareMagnifier());\n    m_saveLastRegion-&gt;setChecked(config.saveLastRegion());\n\n#if !defined(Q_OS_WIN)\n    m_autoCloseIdleDaemon-&gt;setChecked(config.autoCloseIdleDaemon());\n#endif\n\n    m_predefinedColorPaletteLarge-&gt;setChecked(\n      config.predefinedColorPaletteLarge());\n    m_showStartupLaunchMessage-&gt;setChecked(config.showStartupLaunchMessage());\n    m_screenshotPathFixedCheck-&gt;setChecked(config.savePathFixed());\n    m_uploadHistoryMax-&gt;setValue(config.uploadHistoryMax());\n    m_undoLimit-&gt;setValue(config.undoLimit());\n\n    if (allowEmptySavePath || !config.savePath().isEmpty()) {\n        m_savePath-&gt;setText(config.savePath());\n    }\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    m_showTray-&gt;setChecked(!config.disabledTrayIcon());\n#endif\n}\n\nvoid GeneralConf::updateComponents()\n{\n    _updateComponents(false);\n}\n\nvoid GeneralConf::saveLastRegion(bool checked)\n{\n    ConfigHandler().setSaveLastRegion(checked);\n}\n\nvoid GeneralConf::showHelpChanged(bool checked)\n{\n    ConfigHandler().setShowHelp(checked);\n}\n\nvoid GeneralConf::showSidePanelButtonChanged(bool checked)\n{\n    ConfigHandler().setShowSidePanelButton(checked);\n}\n\nvoid GeneralConf::showDesktopNotificationChanged(bool checked)\n{\n    ConfigHandler().setShowDesktopNotification(checked);\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nvoid GeneralConf::checkForUpdatesChanged(bool checked)\n{\n    ConfigHandler().setCheckForUpdates(checked);\n}\n#endif\n\nvoid GeneralConf::allowMultipleGuiInstancesChanged(bool checked)\n{\n    ConfigHandler().setAllowMultipleGuiInstances(checked);\n}\n\nvoid GeneralConf::autoCloseIdleDaemonChanged(bool checked)\n{\n    ConfigHandler().setAutoCloseIdleDaemon(checked);\n}\n\nvoid GeneralConf::autostartChanged(bool checked)\n{\n    ConfigHandler().setStartupLaunch(checked);\n}\n\nvoid GeneralConf::importConfiguration()\n{\n    QString fileName = QFileDialog::getOpenFileName(this, tr(\"Import\"));\n    if (fileName.isEmpty()) {\n        return;\n    }\n    QFile file(fileName);\n    QTextCodec* codec = QTextCodec::codecForLocale();\n    if (!file.open(QFile::ReadOnly)) {\n        QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to read file.\"));\n        return;\n    }\n    QString text = codec-&gt;toUnicode(file.readAll());\n    file.close();\n\n    QFile config(ConfigHandler().configFilePath());\n    if (!config.open(QFile::WriteOnly)) {\n        QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to write file.\"));\n        return;\n    }\n    config.write(codec-&gt;fromUnicode(text));\n    config.close();\n}\n\nvoid GeneralConf::exportFileConfiguration()\n{\n    QString defaultFileName = QSettings().fileName();\n    QString fileName =\n      QFileDialog::getSaveFileName(this, tr(\"Save File\"), defaultFileName);\n\n    // Cancel button or target same as source\n    if (fileName.isNull() || fileName == defaultFileName) {\n        return;\n    }\n\n    QFile targetFile(fileName);\n    if (targetFile.exists()) {\n        targetFile.remove();\n    }\n    bool ok = QFile::copy(ConfigHandler().configFilePath(), fileName);\n    if (!ok) {\n        QMessageBox::about(this, tr(\"Error\"), tr(\"Unable to write file.\"));\n    }\n}\n\nvoid GeneralConf::resetConfiguration()\n{\n    QMessageBox::StandardButton reply;\n    reply = QMessageBox::question(\n      this,\n      tr(\"Confirm Reset\"),\n      tr(\"Are you sure you want to reset the configuration?\"),\n      QMessageBox::Yes | QMessageBox::No);\n    if (reply == QMessageBox::Yes) {\n        m_savePath-&gt;setText(\n          QStandardPaths::writableLocation(QStandardPaths::PicturesLocation));\n        ConfigHandler().setDefaultSettings();\n        _updateComponents(true);\n    }\n}\n\nvoid GeneralConf::initScrollArea()\n{\n    m_scrollArea = new QScrollArea(this);\n    m_layout-&gt;addWidget(m_scrollArea);\n\n    auto* content = new QWidget(m_scrollArea);\n    m_scrollArea-&gt;setWidget(content);\n    m_scrollArea-&gt;setWidgetResizable(true);\n    m_scrollArea-&gt;setSizePolicy(QSizePolicy::Minimum, QSizePolicy::Maximum);\n    m_scrollArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n\n    content-&gt;setObjectName(\"content\");\n    m_scrollArea-&gt;setObjectName(\"scrollArea\");\n    m_scrollArea-&gt;setStyleSheet(\n      \"#content, #scrollArea { background: transparent; border: 0px; }\");\n    m_scrollAreaLayout = new QVBoxLayout(content);\n    m_scrollAreaLayout-&gt;setContentsMargins(0, 0, 20, 0);\n}\n\nvoid GeneralConf::initShowHelp()\n{\n    m_helpMessage = new QCheckBox(tr(\"Show help message\"), this);\n    m_helpMessage-&gt;setToolTip(tr(\"Show the help message at the beginning \"\n                                 \"in the capture mode\"));\n    m_scrollAreaLayout-&gt;addWidget(m_helpMessage);\n\n    connect(\n      m_helpMessage, &amp;QCheckBox::clicked, this, &amp;GeneralConf::showHelpChanged);\n}\n\nvoid GeneralConf::initSaveLastRegion()\n{\n    m_saveLastRegion = new QCheckBox(tr(\"Use last region for GUI mode\"), this);\n    m_saveLastRegion-&gt;setToolTip(\n      tr(\"Use the last region as the default selection for the next screenshot \"\n         \"in GUI mode\"));\n    m_scrollAreaLayout-&gt;addWidget(m_saveLastRegion);\n\n    connect(m_saveLastRegion,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::saveLastRegion);\n}\n\nvoid GeneralConf::initShowSidePanelButton()\n{\n    m_sidePanelButton = new QCheckBox(tr(\"Show the side panel button\"), this);\n    m_sidePanelButton-&gt;setToolTip(\n      tr(\"Show the side panel toggle button in the capture mode\"));\n    m_scrollAreaLayout-&gt;addWidget(m_sidePanelButton);\n\n    connect(m_sidePanelButton,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::showSidePanelButtonChanged);\n}\n\nvoid GeneralConf::initShowDesktopNotification()\n{\n    m_sysNotifications = new QCheckBox(tr(\"Show desktop notifications\"), this);\n    m_sysNotifications-&gt;setToolTip(tr(\"Enable desktop notifications\"));\n    m_scrollAreaLayout-&gt;addWidget(m_sysNotifications);\n\n    connect(m_sysNotifications,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::showDesktopNotificationChanged);\n}\n\nvoid GeneralConf::initShowTrayIcon()\n{\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    m_showTray = new QCheckBox(tr(\"Show tray icon\"), this);\n    m_showTray-&gt;setToolTip(tr(\"Show icon in the system tray\"));\n    m_scrollAreaLayout-&gt;addWidget(m_showTray);\n\n    connect(m_showTray, &amp;QCheckBox::clicked, this, [](bool checked) {\n        ConfigHandler().setDisabledTrayIcon(!checked);\n    });\n#endif\n}\n\nvoid GeneralConf::initHistoryConfirmationToDelete()\n{\n    m_historyConfirmationToDelete = new QCheckBox(\n      tr(\"Confirmation required to delete screenshot from the latest uploads\"),\n      this);\n    m_historyConfirmationToDelete-&gt;setToolTip(\n      tr(\"Ask for confirmation to delete screenshot from the latest uploads\"));\n    m_scrollAreaLayout-&gt;addWidget(m_historyConfirmationToDelete);\n\n    connect(m_historyConfirmationToDelete,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::historyConfirmationToDelete);\n}\n\nvoid GeneralConf::initConfigButtons()\n{\n    auto* buttonLayout = new QHBoxLayout();\n    auto* box = new QGroupBox(tr(\"Configuration File\"));\n    box-&gt;setFlat(true);\n    box-&gt;setLayout(buttonLayout);\n    m_layout-&gt;addWidget(box);\n\n    m_exportButton = new QPushButton(tr(\"Export\"));\n    buttonLayout-&gt;addWidget(m_exportButton);\n    connect(m_exportButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;GeneralConf::exportFileConfiguration);\n\n    m_importButton = new QPushButton(tr(\"Import\"));\n    buttonLayout-&gt;addWidget(m_importButton);\n    connect(m_importButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;GeneralConf::importConfiguration);\n\n    m_resetButton = new QPushButton(tr(\"Reset\"));\n    buttonLayout-&gt;addWidget(m_resetButton);\n    connect(m_resetButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;GeneralConf::resetConfiguration);\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nvoid GeneralConf::initCheckForUpdates()\n{\n    m_checkForUpdates = new QCheckBox(tr(\"Automatic check for updates\"), this);\n    m_checkForUpdates-&gt;setToolTip(tr(\"Check for updates automatically\"));\n    m_scrollAreaLayout-&gt;addWidget(m_checkForUpdates);\n\n    connect(m_checkForUpdates,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::checkForUpdatesChanged);\n}\n#endif\n\nvoid GeneralConf::initAllowMultipleGuiInstances()\n{\n    m_allowMultipleGuiInstances = new QCheckBox(\n      tr(\"Allow multiple flameshot GUI instances simultaneously\"), this);\n    m_allowMultipleGuiInstances-&gt;setToolTip(tr(\n      \"This allows you to take screenshots of Flameshot itself for example\"));\n    m_scrollAreaLayout-&gt;addWidget(m_allowMultipleGuiInstances);\n    connect(m_allowMultipleGuiInstances,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::allowMultipleGuiInstancesChanged);\n}\n\nvoid GeneralConf::initAutoCloseIdleDaemon()\n{\n    m_autoCloseIdleDaemon = new QCheckBox(\n      tr(\"Automatically unload from memory when it is not needed\"), this);\n    m_autoCloseIdleDaemon-&gt;setToolTip(tr(\n      \"Automatically close daemon (background process) when it is not needed\"));\n    m_scrollAreaLayout-&gt;addWidget(m_autoCloseIdleDaemon);\n    connect(m_autoCloseIdleDaemon,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::autoCloseIdleDaemonChanged);\n}\n\nvoid GeneralConf::initAutostart()\n{\n    m_autostart = new QCheckBox(tr(\"Launch in background at startup\"), this);\n    m_autostart-&gt;setToolTip(tr(\n      \"Launch Flameshot daemon (background process) when computer is booted\"));\n    m_scrollAreaLayout-&gt;addWidget(m_autostart);\n\n    connect(\n      m_autostart, &amp;QCheckBox::clicked, this, &amp;GeneralConf::autostartChanged);\n}\n\nvoid GeneralConf::initShowStartupLaunchMessage()\n{\n    m_showStartupLaunchMessage =\n      new QCheckBox(tr(\"Show welcome message on launch\"), this);\n    ConfigHandler config;\n    m_showStartupLaunchMessage-&gt;setToolTip(\n      tr(\"Show the welcome message box in the middle of the screen while \"\n         \"taking a screenshot\"));\n    m_scrollAreaLayout-&gt;addWidget(m_showStartupLaunchMessage);\n\n    connect(m_showStartupLaunchMessage, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setShowStartupLaunchMessage(checked);\n    });\n}\n\nvoid GeneralConf::initPredefinedColorPaletteLarge()\n{\n    m_predefinedColorPaletteLarge =\n      new QCheckBox(tr(\"Use large predefined color palette\"), this);\n    m_predefinedColorPaletteLarge-&gt;setToolTip(\n      tr(\"Use a large predefined color palette\"));\n    m_scrollAreaLayout-&gt;addWidget(m_predefinedColorPaletteLarge);\n\n    connect(\n      m_predefinedColorPaletteLarge, &amp;QCheckBox::clicked, [](bool checked) {\n          ConfigHandler().setPredefinedColorPaletteLarge(checked);\n      });\n}\nvoid GeneralConf::initCopyOnDoubleClick()\n{\n    m_copyOnDoubleClick = new QCheckBox(tr(\"Copy on double click\"), this);\n    m_copyOnDoubleClick-&gt;setToolTip(\n      tr(\"Enable Copy to clipboard on Double Click\"));\n    m_scrollAreaLayout-&gt;addWidget(m_copyOnDoubleClick);\n\n    connect(m_copyOnDoubleClick, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setCopyOnDoubleClick(checked);\n    });\n}\n\nvoid GeneralConf::initCopyAndCloseAfterUpload()\n{\n    m_copyURLAfterUpload = new QCheckBox(tr(\"Copy URL after upload\"), this);\n    m_copyURLAfterUpload-&gt;setToolTip(\n      tr(\"Copy URL after uploading was successful\"));\n    m_scrollAreaLayout-&gt;addWidget(m_copyURLAfterUpload);\n\n    connect(m_copyURLAfterUpload, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setCopyURLAfterUpload(checked);\n    });\n}\n\nvoid GeneralConf::initSaveAfterCopy()\n{\n    m_saveAfterCopy = new QCheckBox(tr(\"Save image after copy\"), this);\n    m_saveAfterCopy-&gt;setToolTip(\n      tr(\"After copying the screenshot, save it to a file as well\"));\n    m_scrollAreaLayout-&gt;addWidget(m_saveAfterCopy);\n    connect(m_saveAfterCopy,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::saveAfterCopyChanged);\n\n    auto* box = new QGroupBox(tr(\"Save Path\"));\n    box-&gt;setFlat(true);\n    m_layout-&gt;addWidget(box);\n\n    auto* vboxLayout = new QVBoxLayout();\n    box-&gt;setLayout(vboxLayout);\n\n    auto* pathLayout = new QHBoxLayout();\n\n    QString path = ConfigHandler().savePath();\n    m_savePath = new QLineEdit(path, this);\n    m_savePath-&gt;setDisabled(true);\n    QString foreground = this-&gt;palette().windowText().color().name();\n    m_savePath-&gt;setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground));\n    pathLayout-&gt;addWidget(m_savePath);\n\n    m_changeSaveButton = new QPushButton(tr(\"Change...\"), this);\n    pathLayout-&gt;addWidget(m_changeSaveButton);\n    connect(m_changeSaveButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;GeneralConf::changeSavePath);\n\n    m_screenshotPathFixedCheck =\n      new QCheckBox(tr(\"Use fixed path for screenshots to save\"), this);\n    connect(m_screenshotPathFixedCheck,\n            &amp;QCheckBox::toggled,\n            this,\n            &amp;GeneralConf::togglePathFixed);\n\n    vboxLayout-&gt;addLayout(pathLayout);\n    vboxLayout-&gt;addWidget(m_screenshotPathFixedCheck);\n\n    auto* extensionLayout = new QHBoxLayout();\n\n    extensionLayout-&gt;addWidget(\n      new QLabel(tr(\"Preferred save file extension:\")));\n    m_setSaveAsFileExtension = new QComboBox(this);\n\n    QStringList imageFormatList;\n    foreach (auto mimeType, QImageWriter::supportedImageFormats())\n        imageFormatList.append(mimeType);\n\n    m_setSaveAsFileExtension-&gt;addItems(imageFormatList);\n\n    int currentIndex =\n      m_setSaveAsFileExtension-&gt;findText(ConfigHandler().saveAsFileExtension());\n    m_setSaveAsFileExtension-&gt;setCurrentIndex(currentIndex);\n\n    connect(m_setSaveAsFileExtension,\n            &amp;QComboBox::currentTextChanged,\n            this,\n            &amp;GeneralConf::setSaveAsFileExtension);\n\n    extensionLayout-&gt;addWidget(m_setSaveAsFileExtension);\n    vboxLayout-&gt;addLayout(extensionLayout);\n}\n\nvoid GeneralConf::historyConfirmationToDelete(bool checked)\n{\n    ConfigHandler().setHistoryConfirmationToDelete(checked);\n}\n\nvoid GeneralConf::initUploadHistoryMax()\n{\n    auto* box = new QGroupBox(tr(\"Latest Uploads Max Size\"));\n    box-&gt;setFlat(true);\n    m_layout-&gt;addWidget(box);\n\n    auto* vboxLayout = new QVBoxLayout();\n    box-&gt;setLayout(vboxLayout);\n\n    m_uploadHistoryMax = new QSpinBox(this);\n    m_uploadHistoryMax-&gt;setMaximum(50);\n    QString foreground = this-&gt;palette().windowText().color().name();\n    m_uploadHistoryMax-&gt;setStyleSheet(\n      QStringLiteral(\"color: %1\").arg(foreground));\n\n    connect(m_uploadHistoryMax,\n            static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            &amp;GeneralConf::uploadHistoryMaxChanged);\n    vboxLayout-&gt;addWidget(m_uploadHistoryMax);\n}\n\nvoid GeneralConf::initUploadClientSecret()\n{\n    auto* box = new QGroupBox(tr(\"Imgur Application Client ID\"));\n    box-&gt;setFlat(true);\n    m_layout-&gt;addWidget(box);\n\n    auto* vboxLayout = new QVBoxLayout();\n    box-&gt;setLayout(vboxLayout);\n\n    m_uploadClientKey = new QLineEdit(this);\n    QString foreground = this-&gt;palette().windowText().color().name();\n    m_uploadClientKey-&gt;setStyleSheet(\n      QStringLiteral(\"color: %1\").arg(foreground));\n    m_uploadClientKey-&gt;setText(ConfigHandler().uploadClientSecret());\n    connect(m_uploadClientKey,\n            &amp;QLineEdit::editingFinished,\n            this,\n            &amp;GeneralConf::uploadClientKeyEdited);\n    vboxLayout-&gt;addWidget(m_uploadClientKey);\n}\n\nvoid GeneralConf::uploadClientKeyEdited()\n{\n    ConfigHandler().setUploadClientSecret(m_uploadClientKey-&gt;text());\n}\n\nvoid GeneralConf::uploadHistoryMaxChanged(int max)\n{\n    ConfigHandler().setUploadHistoryMax(max);\n}\n\nvoid GeneralConf::initUndoLimit()\n{\n    auto* box = new QGroupBox(tr(\"Undo limit\"));\n    box-&gt;setFlat(true);\n    m_layout-&gt;addWidget(box);\n\n    auto* vboxLayout = new QVBoxLayout();\n    box-&gt;setLayout(vboxLayout);\n\n    m_undoLimit = new QSpinBox(this);\n    m_undoLimit-&gt;setMinimum(1);\n    m_undoLimit-&gt;setMaximum(999);\n    QString foreground = this-&gt;palette().windowText().color().name();\n    m_undoLimit-&gt;setStyleSheet(QStringLiteral(\"color: %1\").arg(foreground));\n\n    connect(m_undoLimit,\n            static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            &amp;GeneralConf::undoLimit);\n\n    vboxLayout-&gt;addWidget(m_undoLimit);\n}\n\nvoid GeneralConf::undoLimit(int limit)\n{\n    ConfigHandler().setUndoLimit(limit);\n}\n\nvoid GeneralConf::initUseJpgForClipboard()\n{\n    m_useJpgForClipboard =\n      new QCheckBox(tr(\"Use JPG format for clipboard (PNG default)\"), this);\n    m_useJpgForClipboard-&gt;setToolTip(\n      tr(\"Use lossy JPG format for clipboard (lossless PNG default)\"));\n    m_scrollAreaLayout-&gt;addWidget(m_useJpgForClipboard);\n\n#if defined(Q_OS_MACOS)\n    // FIXME - temporary fix to disable option for MacOS\n    m_useJpgForClipboard-&gt;hide();\n#endif\n    connect(m_useJpgForClipboard,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;GeneralConf::useJpgForClipboardChanged);\n}\n\nvoid GeneralConf::saveAfterCopyChanged(bool checked)\n{\n    ConfigHandler().setSaveAfterCopy(checked);\n}\n\nvoid GeneralConf::changeSavePath()\n{\n    QString path = ConfigHandler().savePath();\n    path = chooseFolder(path);\n    if (!path.isEmpty()) {\n        m_savePath-&gt;setText(path);\n        ConfigHandler().setSavePath(path);\n    }\n}\n\nvoid GeneralConf::initCopyPathAfterSave()\n{\n    m_copyPathAfterSave = new QCheckBox(tr(\"Copy file path after save\"), this);\n    m_copyPathAfterSave-&gt;setToolTip(tr(\"Copy the file path to clipboard after \"\n                                       \"the file is saved\"));\n    m_scrollAreaLayout-&gt;addWidget(m_copyPathAfterSave);\n    connect(m_copyPathAfterSave, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setCopyPathAfterSave(checked);\n    });\n}\n\nvoid GeneralConf::initAntialiasingPinZoom()\n{\n    m_antialiasingPinZoom =\n      new QCheckBox(tr(\"Anti-aliasing image when zoom the pinned image\"), this);\n    m_antialiasingPinZoom-&gt;setToolTip(\n      tr(\"After zooming the pinned image, should the image get smoothened or \"\n         \"stay pixelated\"));\n    m_scrollAreaLayout-&gt;addWidget(m_antialiasingPinZoom);\n    connect(m_antialiasingPinZoom, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setAntialiasingPinZoom(checked);\n    });\n}\n\nvoid GeneralConf::initUploadWithoutConfirmation()\n{\n    m_uploadWithoutConfirmation =\n      new QCheckBox(tr(\"Upload image without confirmation\"), this);\n    m_uploadWithoutConfirmation-&gt;setToolTip(\n      tr(\"Upload image without confirmation\"));\n    m_scrollAreaLayout-&gt;addWidget(m_uploadWithoutConfirmation);\n    connect(m_uploadWithoutConfirmation, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setUploadWithoutConfirmation(checked);\n    });\n}\n\nconst QString GeneralConf::chooseFolder(const QString&amp; pathDefault)\n{\n    QString path;\n    if (pathDefault.isEmpty()) {\n        path =\n          QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);\n    }\n    path = QFileDialog::getExistingDirectory(\n      this,\n      tr(\"Choose a Folder\"),\n      path,\n      QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks);\n    if (path.isEmpty()) {\n        return path;\n    }\n\n    if (!QFileInfo(path).isWritable()) {\n        QMessageBox::about(\n          this, tr(\"Error\"), tr(\"Unable to write to directory.\"));\n        return QString();\n    }\n\n    return path;\n}\n\nvoid GeneralConf::initShowMagnifier()\n{\n    m_showMagnifier = new QCheckBox(tr(\"Show magnifier\"), this);\n    m_showMagnifier-&gt;setToolTip(tr(\"Enable a magnifier while selecting the \"\n                                   \"screenshot area\"));\n\n    m_scrollAreaLayout-&gt;addWidget(m_showMagnifier);\n    connect(m_showMagnifier, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setShowMagnifier(checked);\n    });\n}\n\nvoid GeneralConf::initSquareMagnifier()\n{\n    m_squareMagnifier = new QCheckBox(tr(\"Square shaped magnifier\"), this);\n    m_squareMagnifier-&gt;setToolTip(tr(\"Make the magnifier to be square-shaped\"));\n    m_scrollAreaLayout-&gt;addWidget(m_squareMagnifier);\n    connect(m_squareMagnifier, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setSquareMagnifier(checked);\n    });\n}\n\nvoid GeneralConf::initShowSelectionGeometry()\n{\n    auto* tobox = new QHBoxLayout();\n\n    int timeout =\n      ConfigHandler().value(\"showSelectionGeometryHideTime\").toInt();\n    m_xywhTimeout = new QSpinBox();\n    m_xywhTimeout-&gt;setRange(0, INT_MAX);\n    m_xywhTimeout-&gt;setToolTip(\n      tr(\"Milliseconds before geometry display hides; 0 means do not hide\"));\n    m_xywhTimeout-&gt;setValue(timeout);\n    tobox-&gt;addWidget(m_xywhTimeout);\n    tobox-&gt;addWidget(new QLabel(tr(\"Set geometry display timeout (ms)\")));\n\n    m_scrollAreaLayout-&gt;addLayout(tobox);\n    connect(m_xywhTimeout,\n            static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            &amp;GeneralConf::setSelGeoHideTime);\n\n    auto* box = new QGroupBox(tr(\"Selection Geometry Display\"));\n    box-&gt;setFlat(true);\n    m_layout-&gt;addWidget(box);\n\n    auto* vboxLayout = new QVBoxLayout();\n    box-&gt;setLayout(vboxLayout);\n    auto* selGeoLayout = new QHBoxLayout();\n    selGeoLayout-&gt;addWidget(new QLabel(tr(\"Display Location\")));\n    m_selectGeometryLocation = new QComboBox(this);\n\n    m_selectGeometryLocation-&gt;addItem(tr(\"None\"), GeneralConf::xywh_none);\n    m_selectGeometryLocation-&gt;addItem(tr(\"Top Left\"),\n                                      GeneralConf::xywh_top_left);\n    m_selectGeometryLocation-&gt;addItem(tr(\"Top Right\"),\n                                      GeneralConf::xywh_top_right);\n    m_selectGeometryLocation-&gt;addItem(tr(\"Bottom Left\"),\n                                      GeneralConf::xywh_bottom_left);\n    m_selectGeometryLocation-&gt;addItem(tr(\"Bottom Right\"),\n                                      GeneralConf::xywh_bottom_right);\n    m_selectGeometryLocation-&gt;addItem(tr(\"Center\"), GeneralConf::xywh_center);\n\n    // pick up int from config and use findData\n    int pos = ConfigHandler().value(\"showSelectionGeometry\").toInt();\n    m_selectGeometryLocation-&gt;setCurrentIndex(\n      m_selectGeometryLocation-&gt;findData(pos));\n\n    connect(\n      m_selectGeometryLocation,\n      static_cast&lt;void (QComboBox::*)(int)&gt;(&amp;QComboBox::currentIndexChanged),\n      this,\n      &amp;GeneralConf::setGeometryLocation);\n\n    selGeoLayout-&gt;addWidget(m_selectGeometryLocation);\n    vboxLayout-&gt;addLayout(selGeoLayout);\n    vboxLayout-&gt;addStretch();\n}\n\nvoid GeneralConf::initJpegQuality()\n{\n    auto* tobox = new QHBoxLayout();\n\n    int quality = ConfigHandler().value(\"jpegQuality\").toInt();\n    m_jpegQuality = new QSpinBox();\n    m_jpegQuality-&gt;setRange(0, 100);\n    m_jpegQuality-&gt;setToolTip(tr(\"Quality range of 0-100; Higher number is \"\n                                 \"better quality and larger file size\"));\n    m_jpegQuality-&gt;setValue(quality);\n    tobox-&gt;addWidget(m_jpegQuality);\n    tobox-&gt;addWidget(new QLabel(tr(\"JPEG Quality\")));\n\n    m_scrollAreaLayout-&gt;addLayout(tobox);\n    connect(m_jpegQuality,\n            static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            &amp;GeneralConf::setJpegQuality);\n}\n\nvoid GeneralConf::setSelGeoHideTime(int v)\n{\n    ConfigHandler().setValue(\"showSelectionGeometryHideTime\", v);\n}\n\nvoid GeneralConf::setJpegQuality(int v)\n{\n    ConfigHandler().setJpegQuality(v);\n}\n\nvoid GeneralConf::setGeometryLocation(int index)\n{\n    ConfigHandler().setValue(\"showSelectionGeometry\",\n                             m_selectGeometryLocation-&gt;itemData(index));\n}\n\nvoid GeneralConf::togglePathFixed()\n{\n    ConfigHandler().setSavePathFixed(m_screenshotPathFixedCheck-&gt;isChecked());\n}\n\nvoid GeneralConf::setSaveAsFileExtension(const QString&amp; extension)\n{\n    ConfigHandler().setSaveAsFileExtension(extension);\n}\n\nvoid GeneralConf::useJpgForClipboardChanged(bool checked)\n{\n    ConfigHandler().setUseJpgForClipboard(checked);\n}\n\n</code></pre>"},{"location":"flameshot/generalconf_8h/","title":"File generalconf.h","text":"<p>FileList &gt; config &gt; generalconf.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QScrollArea&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/generalconf_8h/#classes","title":"Classes","text":"Type Name class GeneralConf"},{"location":"flameshot/generalconf_8h_source/","title":"File generalconf.h","text":"<p>File List &gt; config &gt; generalconf.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QScrollArea&gt;\n#include &lt;QWidget&gt;\n\nclass QVBoxLayout;\nclass QCheckBox;\nclass QPushButton;\nclass QLabel;\nclass QLineEdit;\nclass QSpinBox;\nclass QComboBox;\n\nclass GeneralConf : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit GeneralConf(QWidget* parent = nullptr);\n    enum xywh_position\n    {\n        xywh_none = 0,\n        xywh_top_left = 1,\n        xywh_bottom_left = 2,\n        xywh_top_right = 3,\n        xywh_bottom_right = 4,\n        xywh_center = 5\n    };\n\npublic slots:\n    void updateComponents();\n\nprivate slots:\n    void showHelpChanged(bool checked);\n    void saveLastRegion(bool checked);\n    void showSidePanelButtonChanged(bool checked);\n    void showDesktopNotificationChanged(bool checked);\n#if !defined(DISABLE_UPDATE_CHECKER)\n    void checkForUpdatesChanged(bool checked);\n#endif\n    void allowMultipleGuiInstancesChanged(bool checked);\n    void autoCloseIdleDaemonChanged(bool checked);\n    void autostartChanged(bool checked);\n    void historyConfirmationToDelete(bool checked);\n    void uploadHistoryMaxChanged(int max);\n    void undoLimit(int limit);\n    void saveAfterCopyChanged(bool checked);\n    void changeSavePath();\n    void importConfiguration();\n    void exportFileConfiguration();\n    void resetConfiguration();\n    void togglePathFixed();\n    void uploadClientKeyEdited();\n    void useJpgForClipboardChanged(bool checked);\n    void setSaveAsFileExtension(const QString&amp; extension);\n    void setGeometryLocation(int index);\n    void setSelGeoHideTime(int v);\n    void setJpegQuality(int v);\n\nprivate:\n    const QString chooseFolder(const QString&amp; currentPath = \"\");\n\n    void initAllowMultipleGuiInstances();\n    void initAntialiasingPinZoom();\n    void initAutoCloseIdleDaemon();\n    void initAutostart();\n#if !defined(DISABLE_UPDATE_CHECKER)\n    void initCheckForUpdates();\n#endif\n    void initConfigButtons();\n    void initCopyAndCloseAfterUpload();\n    void initCopyOnDoubleClick();\n    void initCopyPathAfterSave();\n    void initHistoryConfirmationToDelete();\n    void initPredefinedColorPaletteLarge();\n    void initSaveAfterCopy();\n    void initScrollArea();\n    void initShowDesktopNotification();\n    void initShowHelp();\n    void initShowMagnifier();\n    void initShowSidePanelButton();\n    void initShowStartupLaunchMessage();\n    void initShowTrayIcon();\n    void initSquareMagnifier();\n    void initUndoLimit();\n    void initUploadWithoutConfirmation();\n    void initUseJpgForClipboard();\n    void initUploadHistoryMax();\n    void initUploadClientSecret();\n    void initSaveLastRegion();\n    void initShowSelectionGeometry();\n    void initJpegQuality();\n\n    void _updateComponents(bool allowEmptySavePath);\n\n    // class members\n    QVBoxLayout* m_layout;\n    QVBoxLayout* m_scrollAreaLayout;\n    QScrollArea* m_scrollArea;\n    QCheckBox* m_sysNotifications;\n    QCheckBox* m_showTray;\n    QCheckBox* m_helpMessage;\n    QCheckBox* m_sidePanelButton;\n#if !defined(DISABLE_UPDATE_CHECKER)\n    QCheckBox* m_checkForUpdates;\n#endif\n    QCheckBox* m_allowMultipleGuiInstances;\n    QCheckBox* m_autoCloseIdleDaemon;\n    QCheckBox* m_autostart;\n    QCheckBox* m_showStartupLaunchMessage;\n    QCheckBox* m_copyURLAfterUpload;\n    QCheckBox* m_copyPathAfterSave;\n    QCheckBox* m_antialiasingPinZoom;\n    QCheckBox* m_saveLastRegion;\n    QCheckBox* m_uploadWithoutConfirmation;\n    QPushButton* m_importButton;\n    QPushButton* m_exportButton;\n    QPushButton* m_resetButton;\n    QCheckBox* m_saveAfterCopy;\n    QLineEdit* m_savePath;\n    QLineEdit* m_uploadClientKey;\n    QPushButton* m_changeSaveButton;\n    QCheckBox* m_screenshotPathFixedCheck;\n    QCheckBox* m_historyConfirmationToDelete;\n    QCheckBox* m_useJpgForClipboard;\n    QSpinBox* m_uploadHistoryMax;\n    QSpinBox* m_undoLimit;\n    QComboBox* m_setSaveAsFileExtension;\n    QCheckBox* m_predefinedColorPaletteLarge;\n    QCheckBox* m_showMagnifier;\n    QCheckBox* m_squareMagnifier;\n    QCheckBox* m_copyOnDoubleClick;\n    QCheckBox* m_showSelectionGeometry;\n    QComboBox* m_selectGeometryLocation;\n    QSpinBox* m_xywhTimeout;\n    QSpinBox* m_jpegQuality;\n};\n\n</code></pre>"},{"location":"flameshot/setshortcutwidget_8cpp/","title":"File setshortcutwidget.cpp","text":"<p>FileList &gt; config &gt; setshortcutwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"setshortcutwidget.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QLayout&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> </ul>"},{"location":"flameshot/setshortcutwidget_8cpp_source/","title":"File setshortcutwidget.cpp","text":"<p>File List &gt; config &gt; setshortcutwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap &amp; Contributors\n\n#include \"setshortcutwidget.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QIcon&gt;\n#include &lt;QKeyEvent&gt;\n#include &lt;QLabel&gt;\n#include &lt;QLayout&gt;\n#include &lt;QPixmap&gt;\n\nSetShortcutDialog::SetShortcutDialog(QDialog* parent,\n                                     const QString&amp; shortcutName)\n  : QDialog(parent)\n{\n    setWindowFlags(windowFlags() &amp; ~Qt::WindowContextHelpButtonHint);\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    setWindowTitle(tr(\"Set Shortcut\"));\n    m_ks = QKeySequence();\n\n    m_layout = new QVBoxLayout(this);\n    m_layout-&gt;setAlignment(Qt::AlignHCenter);\n\n    auto* infoTop = new QLabel(tr(\"Enter new shortcut to change \"));\n    infoTop-&gt;setMargin(10);\n    infoTop-&gt;setAlignment(Qt::AlignCenter);\n    m_layout-&gt;addWidget(infoTop);\n\n    auto* infoIcon = new QLabel();\n    infoIcon-&gt;setAlignment(Qt::AlignCenter);\n    infoIcon-&gt;setPixmap(QPixmap(\":/img/app/keyboard.svg\"));\n    m_layout-&gt;addWidget(infoIcon);\n\n    m_layout-&gt;addWidget(infoIcon);\n\n    QString msg = \"\";\n#if defined(Q_OS_MAC)\n    msg = tr(\n      \"Press Esc to cancel or \u2318+Backspace to disable the keyboard shortcut.\");\n#else\n    msg =\n      tr(\"Press Esc to cancel or Backspace to disable the keyboard shortcut.\");\n#endif\n    if (shortcutName == \"TAKE_SCREENSHOT\" ||\n        shortcutName == \"SCREENSHOT_HISTORY\") {\n        msg +=\n          \"\\n\" + tr(\"Flameshot must be restarted for changes to take effect.\");\n    }\n    auto* infoBottom = new QLabel(msg);\n    infoBottom-&gt;setMargin(10);\n    infoBottom-&gt;setAlignment(Qt::AlignCenter);\n    m_layout-&gt;addWidget(infoBottom);\n}\n\nconst QKeySequence&amp; SetShortcutDialog::shortcut()\n{\n    return m_ks;\n}\n\nvoid SetShortcutDialog::keyPressEvent(QKeyEvent* ke)\n{\n    if (ke-&gt;modifiers() &amp; Qt::ShiftModifier) {\n        m_modifier += \"Shift+\";\n    }\n    if (ke-&gt;modifiers() &amp; Qt::ControlModifier) {\n        m_modifier += \"Ctrl+\";\n    }\n    if (ke-&gt;modifiers() &amp; Qt::AltModifier) {\n        m_modifier += \"Alt+\";\n    }\n    if (ke-&gt;modifiers() &amp; Qt::MetaModifier) {\n        m_modifier += \"Meta+\";\n    }\n\n    QString key = QKeySequence(ke-&gt;key()).toString();\n    m_ks = QKeySequence(m_modifier + key);\n}\n\nvoid SetShortcutDialog::keyReleaseEvent(QKeyEvent* event)\n{\n    if (m_ks == QKeySequence(Qt::Key_Escape)) {\n        reject();\n    }\n    accept();\n}\n\n</code></pre>"},{"location":"flameshot/setshortcutwidget_8h/","title":"File setshortcutwidget.h","text":"<p>FileList &gt; config &gt; setshortcutwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QDialog&gt;</code></li> <li><code>#include &lt;QKeySequence&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/setshortcutwidget_8h/#classes","title":"Classes","text":"Type Name class SetShortcutDialog"},{"location":"flameshot/setshortcutwidget_8h_source/","title":"File setshortcutwidget.h","text":"<p>File List &gt; config &gt; setshortcutwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap &amp; Contributors\n\n#ifndef SETSHORTCUTWIDGET_H\n#define SETSHORTCUTWIDGET_H\n\n#include &lt;QDialog&gt;\n#include &lt;QKeySequence&gt;\n#include &lt;QObject&gt;\n\nclass QVBoxLayout;\n\nclass SetShortcutDialog : public QDialog\n{\n    Q_OBJECT\npublic:\n    explicit SetShortcutDialog(QDialog* parent = nullptr,\n                               const QString&amp; shortcutName = \"\");\n    const QKeySequence&amp; shortcut();\n\npublic:\n    void keyPressEvent(QKeyEvent*);\n    void keyReleaseEvent(QKeyEvent* event);\n\nsignals:\n\nprivate:\n    QVBoxLayout* m_layout;\n    QString m_modifier;\n    QKeySequence m_ks;\n};\n\n#endif // SETSHORTCUTWIDGET_H\n\n</code></pre>"},{"location":"flameshot/shortcutswidget_8cpp/","title":"File shortcutswidget.cpp","text":"<p>FileList &gt; config &gt; shortcutswidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"shortcutswidget.h\"</code></li> <li><code>#include \"capturetool.h\"</code></li> <li><code>#include \"setshortcutwidget.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"toolfactory.h\"</code></li> <li><code>#include &lt;QHeaderView&gt;</code></li> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QStringList&gt;</code></li> <li><code>#include &lt;QTableWidget&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> <li><code>#include &lt;QCursor&gt;</code></li> <li><code>#include &lt;QRect&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/shortcutswidget_8cpp_source/","title":"File shortcutswidget.cpp","text":"<p>File List &gt; config &gt; shortcutswidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap &amp; Contributors\n\n#include \"shortcutswidget.h\"\n#include \"capturetool.h\"\n#include \"setshortcutwidget.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"toolfactory.h\"\n#include &lt;QHeaderView&gt;\n#include &lt;QIcon&gt;\n#include &lt;QKeyEvent&gt;\n#include &lt;QLabel&gt;\n#include &lt;QStringList&gt;\n#include &lt;QTableWidget&gt;\n#include &lt;QVBoxLayout&gt;\n#include &lt;QVector&gt;\n\n#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0))\n#include &lt;QCursor&gt;\n#include &lt;QRect&gt;\n#include &lt;QScreen&gt;\n#endif\n\nShortcutsWidget::ShortcutsWidget(QWidget* parent)\n  : QWidget(parent)\n{\n    setAttribute(Qt::WA_DeleteOnClose);\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    setWindowTitle(tr(\"Hot Keys\"));\n\n#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0))\n    QRect position = frameGeometry();\n    QScreen* screen = QGuiAppCurrentScreen().currentScreen();\n    position.moveCenter(screen-&gt;availableGeometry().center());\n    move(position.topLeft());\n#endif\n\n    m_layout = new QVBoxLayout(this);\n    m_layout-&gt;setAlignment(Qt::AlignHCenter | Qt::AlignVCenter);\n\n    initInfoTable();\n    connect(ConfigHandler::getInstance(),\n            &amp;ConfigHandler::fileChanged,\n            this,\n            &amp;ShortcutsWidget::populateInfoTable);\n    show();\n}\n\nvoid ShortcutsWidget::initInfoTable()\n{\n    m_table = new QTableWidget(this);\n    m_table-&gt;setToolTip(tr(\"Available shortcuts in the screen capture mode.\"));\n\n    m_layout-&gt;addWidget(m_table);\n\n    m_table-&gt;setColumnCount(2);\n    m_table-&gt;setSelectionMode(QAbstractItemView::NoSelection);\n    m_table-&gt;setFocusPolicy(Qt::NoFocus);\n    m_table-&gt;verticalHeader()-&gt;hide();\n\n    // header creation\n    QStringList names;\n    names &lt;&lt; tr(\"Description\") &lt;&lt; tr(\"Key\");\n    m_table-&gt;setHorizontalHeaderLabels(names);\n    connect(m_table,\n            &amp;QTableWidget::cellClicked,\n            this,\n            &amp;ShortcutsWidget::onShortcutCellClicked);\n\n    // populate with dynamic data\n    populateInfoTable();\n\n    // adjust size\n    m_table-&gt;horizontalHeader()-&gt;setMinimumSectionSize(200);\n    m_table-&gt;horizontalHeader()-&gt;setSectionResizeMode(0, QHeaderView::Stretch);\n    m_table-&gt;horizontalHeader()-&gt;setSizePolicy(QSizePolicy::Expanding,\n                                               QSizePolicy::Expanding);\n    m_table-&gt;resizeColumnsToContents();\n    m_table-&gt;resizeRowsToContents();\n}\n\nvoid ShortcutsWidget::populateInfoTable()\n{\n    loadShortcuts();\n    m_table-&gt;setRowCount(m_shortcuts.size());\n\n    // add content\n    for (int i = 0; i &lt; m_shortcuts.size(); ++i) {\n        const auto current_shortcut = m_shortcuts.at(i);\n        const auto identifier = current_shortcut.at(0);\n        const auto description = current_shortcut.at(1);\n        const auto key_sequence = current_shortcut.at(2);\n        m_table-&gt;setItem(i, 0, new QTableWidgetItem(description));\n\n#if defined(Q_OS_MACOS)\n        auto* item = new QTableWidgetItem(nativeOSHotKeyText(key_sequence));\n#else\n        QTableWidgetItem* item = new QTableWidgetItem(key_sequence);\n#endif\n        item-&gt;setTextAlignment(Qt::AlignCenter);\n        m_table-&gt;setItem(i, 1, item);\n\n        if (identifier.isEmpty()) {\n            QFont font;\n            font.setBold(true);\n            item-&gt;setFont(font);\n            item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEnabled);\n            m_table-&gt;item(i, 1)-&gt;setFont(font);\n        }\n    }\n\n    // Read-only table items\n    for (int x = 0; x &lt; m_table-&gt;rowCount(); ++x) {\n        for (int y = 0; y &lt; m_table-&gt;columnCount(); ++y) {\n            QTableWidgetItem* item = m_table-&gt;item(x, y);\n            item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEditable);\n        }\n    }\n}\n\nvoid ShortcutsWidget::onShortcutCellClicked(int row, int col)\n{\n    if (col == 1) {\n        // Ignore non-changable shortcuts\n        if (Qt::ItemIsEnabled !=\n            (Qt::ItemIsEnabled &amp; m_table-&gt;item(row, col)-&gt;flags())) {\n            return;\n        }\n\n        QString shortcutName = m_shortcuts.at(row).at(0);\n        auto* setShortcutDialog = new SetShortcutDialog(nullptr, shortcutName);\n        if (0 != setShortcutDialog-&gt;exec()) {\n            QKeySequence shortcutValue = setShortcutDialog-&gt;shortcut();\n\n            // set no shortcut is Backspace\n#if defined(Q_OS_MACOS)\n            if (shortcutValue == QKeySequence(Qt::CTRL + Qt::Key_Backspace)) {\n                shortcutValue = QKeySequence(\"\");\n            }\n#else\n            if (shortcutValue == QKeySequence(Qt::Key_Backspace)) {\n                shortcutValue = QKeySequence(\"\");\n            }\n#endif\n            if (m_config.setShortcut(shortcutName, shortcutValue.toString())) {\n                populateInfoTable();\n            }\n        }\n        delete setShortcutDialog;\n    }\n}\n\nvoid ShortcutsWidget::loadShortcuts()\n{\n    m_shortcuts.clear();\n    auto buttonTypes = CaptureToolButton::getIterableButtonTypes();\n\n    // get shortcuts names from capture buttons\n    for (const CaptureTool::Type&amp; t : buttonTypes) {\n        CaptureTool* tool = ToolFactory().CreateTool(t);\n        QString shortcutName = QVariant::fromValue(t).toString();\n        appendShortcut(shortcutName, tool-&gt;description());\n        if (shortcutName == \"TYPE_COPY\") {\n            if (m_config.copyOnDoubleClick()) {\n                m_shortcuts &lt;&lt; (QStringList() &lt;&lt; \"\" &lt;&lt; tool-&gt;description()\n                                              &lt;&lt; tr(\"Left Double-click\"));\n            }\n        }\n        delete tool;\n    }\n\n    // additional tools that don't have their own buttons\n    appendShortcut(\"TYPE_TOGGLE_PANEL\", tr(\"Toggle side panel\"));\n    appendShortcut(\"TYPE_RESIZE_LEFT\", tr(\"Resize selection left 1px\"));\n    appendShortcut(\"TYPE_RESIZE_RIGHT\", tr(\"Resize selection right 1px\"));\n    appendShortcut(\"TYPE_RESIZE_UP\", tr(\"Resize selection up 1px\"));\n    appendShortcut(\"TYPE_RESIZE_DOWN\", tr(\"Resize selection down 1px\"));\n    appendShortcut(\"TYPE_SYM_RESIZE_LEFT\",\n                   tr(\"Symmetrically decrease width by 2px\"));\n    appendShortcut(\"TYPE_SYM_RESIZE_RIGHT\",\n                   tr(\"Symmetrically increase width by 2px\"));\n    appendShortcut(\"TYPE_SYM_RESIZE_UP\",\n                   tr(\"Symmetrically increase height by 2px\"));\n    appendShortcut(\"TYPE_SYM_RESIZE_DOWN\",\n                   tr(\"Symmetrically decrease height by 2px\"));\n    appendShortcut(\"TYPE_SELECT_ALL\", tr(\"Select entire screen\"));\n    appendShortcut(\"TYPE_MOVE_LEFT\", tr(\"Move selection left 1px\"));\n    appendShortcut(\"TYPE_MOVE_RIGHT\", tr(\"Move selection right 1px\"));\n    appendShortcut(\"TYPE_MOVE_UP\", tr(\"Move selection up 1px\"));\n    appendShortcut(\"TYPE_MOVE_DOWN\", tr(\"Move selection down 1px\"));\n    appendShortcut(\"TYPE_COMMIT_CURRENT_TOOL\", tr(\"Commit text in text area\"));\n    appendShortcut(\"TYPE_DELETE_CURRENT_TOOL\", tr(\"Delete current tool\"));\n\n    // non-editable shortcuts have an empty shortcut name\n\n    m_shortcuts &lt;&lt; (QStringList() &lt;&lt; \"\" &lt;&lt; QObject::tr(\"Quit capture\")\n                                  &lt;&lt; QKeySequence(Qt::Key_Escape).toString());\n\n    // Global hotkeys\n#if defined(Q_OS_MACOS)\n    appendShortcut(\"TAKE_SCREENSHOT\", tr(\"Capture screen\"));\n    appendShortcut(\"SCREENSHOT_HISTORY\", tr(\"Screenshot history\"));\n#elif defined(Q_OS_WIN)\n    m_shortcuts &lt;&lt; (QStringList() &lt;&lt; \"\" &lt;&lt; QObject::tr(\"Screenshot history\")\n                                  &lt;&lt; \"Shift+Print Screen\");\n    m_shortcuts &lt;&lt; (QStringList()\n                    &lt;&lt; \"\" &lt;&lt; QObject::tr(\"Capture screen\") &lt;&lt; \"Print Screen\");\n#else\n    // TODO - Linux doesn't support global shortcuts for (XServer and Wayland),\n    // possibly it will be solved in the QHotKey library later. So it is\n    // disabled for now.\n#endif\n    m_shortcuts &lt;&lt; (QStringList()\n                    &lt;&lt; \"\" &lt;&lt; QObject::tr(\"Show color picker\") &lt;&lt; \"Right Click\");\n    m_shortcuts &lt;&lt; (QStringList() &lt;&lt; \"\" &lt;&lt; QObject::tr(\"Change the tool's size\")\n                                  &lt;&lt; \"Mouse Wheel\");\n}\n\nvoid ShortcutsWidget::appendShortcut(const QString&amp; shortcutName,\n                                     const QString&amp; description)\n{\n    QString shortcut = ConfigHandler().shortcut(shortcutName);\n    m_shortcuts &lt;&lt; (QStringList()\n                    &lt;&lt; shortcutName\n                    &lt;&lt; QObject::tr(description.toStdString().c_str())\n                    &lt;&lt; shortcut.replace(\"Return\", \"Enter\"));\n}\n\n#if defined(Q_OS_MACOS)\nconst QString&amp; ShortcutsWidget::nativeOSHotKeyText(const QString&amp; text)\n{\n    m_res = text;\n    m_res.replace(\"Ctrl+\", \"\u2318\");\n    m_res.replace(\"Alt+\", \"\u2325\");\n    m_res.replace(\"Meta+\", \"\u2303\");\n    m_res.replace(\"Shift+\", \"\u21e7\");\n    return m_res;\n}\n#endif\n\n</code></pre>"},{"location":"flameshot/shortcutswidget_8h/","title":"File shortcutswidget.h","text":"<p>FileList &gt; config &gt; shortcutswidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QStringList&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/shortcutswidget_8h/#classes","title":"Classes","text":"Type Name class ShortcutsWidget"},{"location":"flameshot/shortcutswidget_8h_source/","title":"File shortcutswidget.h","text":"<p>File List &gt; config &gt; shortcutswidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2020 Yurii Puchkov at Namecheap &amp; Contributors\n\n#ifndef HOTKEYSCONFIG_H\n#define HOTKEYSCONFIG_H\n\n#include \"src/utils/confighandler.h\"\n#include &lt;QStringList&gt;\n#include &lt;QVector&gt;\n#include &lt;QWidget&gt;\n\nclass SetShortcutDialog;\nclass QTableWidget;\nclass QVBoxLayout;\n\nclass ShortcutsWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit ShortcutsWidget(QWidget* parent = nullptr);\n\nprivate:\n    void initInfoTable();\n#if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) ||        \\\n     defined(Q_OS_MACX))\n    const QString&amp; nativeOSHotKeyText(const QString&amp; text);\n#endif\n\nprivate slots:\n    void populateInfoTable();\n    void onShortcutCellClicked(int, int);\n\nprivate:\n#if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) ||        \\\n     defined(Q_OS_MACX))\n    QString m_res;\n#endif\n    ConfigHandler m_config;\n    QTableWidget* m_table;\n    QVBoxLayout* m_layout;\n    QList&lt;QStringList&gt; m_shortcuts;\n\n    void loadShortcuts();\n    void appendShortcut(const QString&amp; shortcutName,\n                        const QString&amp; description);\n};\n\n#endif // HOTKEYSCONFIG_H\n\n</code></pre>"},{"location":"flameshot/strftimechooserwidget_8cpp/","title":"File strftimechooserwidget.cpp","text":"<p>FileList &gt; config &gt; strftimechooserwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"strftimechooserwidget.h\"</code></li> <li><code>#include &lt;QGridLayout&gt;</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> </ul>"},{"location":"flameshot/strftimechooserwidget_8cpp_source/","title":"File strftimechooserwidget.cpp","text":"<p>File List &gt; config &gt; strftimechooserwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"strftimechooserwidget.h\"\n#include &lt;QGridLayout&gt;\n#include &lt;QMap&gt;\n#include &lt;QPushButton&gt;\n\nStrftimeChooserWidget::StrftimeChooserWidget(QWidget* parent)\n  : QWidget(parent)\n{\n    auto* layout = new QGridLayout(this);\n    auto k = m_buttonData.keys();\n    int middle = k.length() / 2;\n    // add the buttons in 2 columns (they need to be even)\n    for (int i = 0; i &lt; 2; i++) {\n        for (int j = 0; j &lt; middle; j++) {\n            QString key = k.last();\n            k.pop_back();\n            QString variable = m_buttonData.value(key);\n            auto* button = new QPushButton(this);\n            button-&gt;setText(tr(key.toStdString().data()));\n            button-&gt;setToolTip(variable);\n            button-&gt;setSizePolicy(QSizePolicy::Expanding,\n                                  QSizePolicy::Expanding);\n            button-&gt;setMinimumHeight(25);\n            layout-&gt;addWidget(button, j, i);\n            connect(button, &amp;QPushButton::clicked, this, [variable, this]() {\n                emit variableEmitted(variable);\n            });\n        }\n    }\n    setLayout(layout);\n}\n\nQMap&lt;QString, QString&gt; StrftimeChooserWidget::m_buttonData{\n    { QT_TR_NOOP(\"Century (00-99)\"), \"%C\" },\n    { QT_TR_NOOP(\"Year (00-99)\"), \"%y\" },\n    { QT_TR_NOOP(\"Year (2000)\"), \"%Y\" },\n#ifndef Q_OS_WIN\n    // TODO - fix localized names on windows (ex. Cyrillic)\n    { QT_TR_NOOP(\"Month Name (jan)\"), \"%b\" },\n    { QT_TR_NOOP(\"Month Name (january)\"), \"%B\" },\n#endif\n    { QT_TR_NOOP(\"Month (01-12)\"), \"%m\" },\n    { QT_TR_NOOP(\"Week Day (1-7)\"), \"%u\" },\n    { QT_TR_NOOP(\"Week (01-53)\"), \"%V\" },\n#ifndef Q_OS_WIN\n    // TODO - fix localized names on windows (ex. Cyrillic)\n    { QT_TR_NOOP(\"Day Name (mon)\"), \"%a\" },\n    { QT_TR_NOOP(\"Day Name (monday)\"), \"%A\" },\n#endif\n    { QT_TR_NOOP(\"Day (01-31)\"), \"%d\" },\n    { QT_TR_NOOP(\"Day of Month (1-31)\"), \"%e\" },\n    { QT_TR_NOOP(\"Day (001-366)\"), \"%j\" },\n#ifndef Q_OS_WIN\n    // TODO - fix localized names on windows (ex. Cyrillic)\n    { QT_TR_NOOP(\"Time (%H-%M-%S)\"), \"%T\" },\n    { QT_TR_NOOP(\"Time (%H-%M)\"), \"%R\" },\n#endif\n    { QT_TR_NOOP(\"Hour (00-23)\"), \"%H\" },\n    { QT_TR_NOOP(\"Hour (01-12)\"), \"%I\" },\n    { QT_TR_NOOP(\"Minute (00-59)\"), \"%M\" },\n    { QT_TR_NOOP(\"Second (00-59)\"), \"%S\" },\n#ifndef Q_OS_WIN\n    // TODO - fix localized names on windows (ex. Cyrillic)\n    { QT_TR_NOOP(\"Full Date (%m/%d/%y)\"), \"%D\" },\n#endif\n    { QT_TR_NOOP(\"Full Date (%Y-%m-%d)\"), \"%F\" },\n};\n\n</code></pre>"},{"location":"flameshot/strftimechooserwidget_8h/","title":"File strftimechooserwidget.h","text":"<p>FileList &gt; config &gt; strftimechooserwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/strftimechooserwidget_8h/#classes","title":"Classes","text":"Type Name class StrftimeChooserWidget"},{"location":"flameshot/strftimechooserwidget_8h_source/","title":"File strftimechooserwidget.h","text":"<p>File List &gt; config &gt; strftimechooserwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass StrftimeChooserWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit StrftimeChooserWidget(QWidget* parent = nullptr);\n\nsignals:\n    void variableEmitted(const QString&amp;);\n\nprivate:\n    static QMap&lt;QString, QString&gt; m_buttonData;\n};\n\n</code></pre>"},{"location":"flameshot/styleoverride_8cpp/","title":"File styleoverride.cpp","text":"<p>FileList &gt; config &gt; styleoverride.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"styleoverride.h\"</code></li> </ul>"},{"location":"flameshot/styleoverride_8cpp_source/","title":"File styleoverride.cpp","text":"<p>File List &gt; config &gt; styleoverride.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2020 Jeremy Borgman &lt;borgman.jeremy@pm.me&gt;\n//\n// Created by jeremy on 9/24/20.\n\n#include \"styleoverride.h\"\n\nint StyleOverride::styleHint(StyleHint hint,\n                             const QStyleOption* option,\n                             const QWidget* widget,\n                             QStyleHintReturn* returnData) const\n{\n    if (hint == SH_ToolTip_WakeUpDelay) {\n        return 600;\n    } else {\n        return baseStyle()-&gt;styleHint(hint, option, widget, returnData);\n    }\n}\n\n</code></pre>"},{"location":"flameshot/styleoverride_8h/","title":"File styleoverride.h","text":"<p>FileList &gt; config &gt; styleoverride.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QProxyStyle&gt;</code></li> </ul>"},{"location":"flameshot/styleoverride_8h/#classes","title":"Classes","text":"Type Name class StyleOverride"},{"location":"flameshot/styleoverride_8h_source/","title":"File styleoverride.h","text":"<p>File List &gt; config &gt; styleoverride.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2020 Jeremy Borgman &lt;borgman.jeremy@pm.me&gt;\n//\n// Created by jeremy on 9/24/20.\n\n#ifndef FLAMESHOT_STYLEOVERRIDE_H\n#define FLAMESHOT_STYLEOVERRIDE_H\n\n#include &lt;QObject&gt;\n#include &lt;QProxyStyle&gt;\n\nclass StyleOverride : public QProxyStyle\n{\n    Q_OBJECT\npublic:\n    int styleHint(StyleHint hint,\n                  const QStyleOption* option = Q_NULLPTR,\n                  const QWidget* widget = Q_NULLPTR,\n                  QStyleHintReturn* returnData = Q_NULLPTR) const;\n};\n\n#endif // FLAMESHOT_STYLEOVERRIDE_H\n\n</code></pre>"},{"location":"flameshot/uicoloreditor_8cpp/","title":"File uicoloreditor.cpp","text":"<p>FileList &gt; config &gt; uicoloreditor.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"uicoloreditor.h\"</code></li> <li><code>#include \"clickablelabel.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QComboBox&gt;</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QSpacerItem&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/uicoloreditor_8cpp_source/","title":"File uicoloreditor.cpp","text":"<p>File List &gt; config &gt; uicoloreditor.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"uicoloreditor.h\"\n#include \"clickablelabel.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QApplication&gt;\n#include &lt;QComboBox&gt;\n#include &lt;QHBoxLayout&gt;\n#include &lt;QMap&gt;\n#include &lt;QSpacerItem&gt;\n#include &lt;QVBoxLayout&gt;\n\nUIcolorEditor::UIcolorEditor(QWidget* parent)\n  : QWidget(parent)\n{\n    setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n    m_hLayout = new QHBoxLayout;\n    m_vLayout = new QVBoxLayout;\n\n    const int space = QApplication::fontMetrics().lineSpacing();\n    m_hLayout-&gt;addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));\n    m_vLayout-&gt;setAlignment(Qt::AlignVCenter);\n\n    initButtons();\n    initColorWheel();\n\n    m_vLayout-&gt;addSpacing(space);\n    m_hLayout-&gt;addLayout(m_vLayout);\n    m_hLayout-&gt;addItem(new QSpacerItem(space, space, QSizePolicy::Expanding));\n    setLayout(m_hLayout);\n    updateComponents();\n}\n\nvoid UIcolorEditor::updateComponents()\n{\n    ConfigHandler config;\n    m_uiColor = config.uiColor();\n    m_contrastColor = config.contrastUiColor();\n    m_buttonContrast-&gt;setColor(m_contrastColor);\n    m_buttonMainColor-&gt;setColor(m_uiColor);\n    if (m_lastButtonPressed == m_buttonMainColor) {\n        m_colorWheel-&gt;setColor(m_uiColor);\n    } else {\n        m_colorWheel-&gt;setColor(m_contrastColor);\n    }\n}\n\n// updateUIcolor updates the appearance of the buttons\nvoid UIcolorEditor::updateUIcolor()\n{\n    ConfigHandler config;\n    if (m_lastButtonPressed == m_buttonMainColor) {\n        config.setUiColor(m_uiColor);\n    } else {\n        config.setContrastUiColor(m_contrastColor);\n    }\n}\n\n// updateLocalColor updates the local button\nvoid UIcolorEditor::updateLocalColor(const QColor c)\n{\n    if (m_lastButtonPressed == m_buttonMainColor) {\n        m_uiColor = c;\n    } else {\n        m_contrastColor = c;\n    }\n    m_lastButtonPressed-&gt;setColor(c);\n}\n\nvoid UIcolorEditor::initColorWheel()\n{\n    m_colorWheel = new color_widgets::ColorWheel(this);\n    connect(m_colorWheel,\n            &amp;color_widgets::ColorWheel::colorSelected,\n            this,\n            &amp;UIcolorEditor::updateUIcolor);\n    connect(m_colorWheel,\n            &amp;color_widgets::ColorWheel::colorChanged,\n            this,\n            &amp;UIcolorEditor::updateLocalColor);\n\n    const int size = GlobalValues::buttonBaseSize() * 3;\n    m_colorWheel-&gt;setMinimumSize(size, size);\n    m_colorWheel-&gt;setMaximumSize(size * 2, size * 2);\n    m_colorWheel-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n    m_colorWheel-&gt;setToolTip(tr(\"Change the color moving the selectors and see\"\n                                \" the changes in the preview buttons.\"));\n\n    m_hLayout-&gt;addWidget(m_colorWheel);\n}\n\nvoid UIcolorEditor::initButtons()\n{\n    const int extraSize = GlobalValues::buttonBaseSize() / 3;\n    int frameSize = GlobalValues::buttonBaseSize() + extraSize;\n\n    m_vLayout-&gt;addWidget(new QLabel(tr(\"Select a Button to modify it\"), this));\n\n    auto* frame = new QGroupBox();\n    frame-&gt;setFixedSize(frameSize, frameSize);\n\n    m_buttonMainColor = new CaptureToolButton(m_buttonIconType, frame);\n    m_buttonMainColor-&gt;move(m_buttonMainColor-&gt;x() + extraSize / 2,\n                            m_buttonMainColor-&gt;y() + extraSize / 2);\n    auto* h1 = new QHBoxLayout();\n    h1-&gt;addWidget(frame);\n    m_labelMain = new ClickableLabel(tr(\"Main Color\"), this);\n    h1-&gt;addWidget(m_labelMain);\n    m_vLayout-&gt;addLayout(h1);\n\n    m_buttonMainColor-&gt;setToolTip(tr(\"Click on this button to set the edition\"\n                                     \" mode of the main color.\"));\n\n    auto* frame2 = new QGroupBox();\n    m_buttonContrast = new CaptureToolButton(m_buttonIconType, frame2);\n    m_buttonContrast-&gt;move(m_buttonContrast-&gt;x() + extraSize / 2,\n                           m_buttonContrast-&gt;y() + extraSize / 2);\n\n    auto* h2 = new QHBoxLayout();\n    h2-&gt;addWidget(frame2);\n    frame2-&gt;setFixedSize(frameSize, frameSize);\n    m_labelContrast = new ClickableLabel(tr(\"Contrast Color\"), this);\n    m_labelContrast-&gt;setStyleSheet(QStringLiteral(\"color : gray\"));\n    h2-&gt;addWidget(m_labelContrast);\n    m_vLayout-&gt;addLayout(h2);\n\n    m_buttonContrast-&gt;setToolTip(tr(\"Click on this button to set the edition\"\n                                    \" mode of the contrast color.\"));\n\n    connect(m_buttonMainColor,\n            &amp;CaptureToolButton::pressedButtonLeftClick,\n            this,\n            &amp;UIcolorEditor::changeLastButton);\n    connect(m_buttonContrast,\n            &amp;CaptureToolButton::pressedButtonLeftClick,\n            this,\n            &amp;UIcolorEditor::changeLastButton);\n    // clicking the labels changes the button too\n    connect(m_labelMain, &amp;ClickableLabel::clicked, this, [this] {\n        changeLastButton(m_buttonMainColor);\n    });\n    connect(m_labelContrast, &amp;ClickableLabel::clicked, this, [this] {\n        changeLastButton(m_buttonContrast);\n    });\n    m_lastButtonPressed = m_buttonMainColor;\n}\n\n// visual update for the selected button\nvoid UIcolorEditor::changeLastButton(CaptureToolButton* b)\n{\n    if (m_lastButtonPressed != b) {\n        m_lastButtonPressed = b;\n\n        QString offStyle(QStringLiteral(\"QLabel { color : gray; }\"));\n\n        if (b == m_buttonMainColor) {\n            m_colorWheel-&gt;setColor(m_uiColor);\n            m_labelContrast-&gt;setStyleSheet(offStyle);\n            m_labelMain-&gt;setStyleSheet(styleSheet());\n        } else {\n            m_colorWheel-&gt;setColor(m_contrastColor);\n            m_labelContrast-&gt;setStyleSheet(styleSheet());\n            m_labelMain-&gt;setStyleSheet(offStyle);\n        }\n        b-&gt;setIcon(b-&gt;icon());\n    }\n}\n\n</code></pre>"},{"location":"flameshot/uicoloreditor_8h/","title":"File uicoloreditor.h","text":"<p>FileList &gt; config &gt; uicoloreditor.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"QtColorWidgets/color_wheel.hpp\"</code></li> <li><code>#include \"src/widgets/capture/capturetoolbutton.h\"</code></li> <li><code>#include &lt;QGroupBox&gt;</code></li> </ul>"},{"location":"flameshot/uicoloreditor_8h/#classes","title":"Classes","text":"Type Name class UIcolorEditor"},{"location":"flameshot/uicoloreditor_8h_source/","title":"File uicoloreditor.h","text":"<p>File List &gt; config &gt; uicoloreditor.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"QtColorWidgets/color_wheel.hpp\"\n#include \"src/widgets/capture/capturetoolbutton.h\"\n#include &lt;QGroupBox&gt;\n\nclass QVBoxLayout;\nclass QHBoxLayout;\nclass CaptureToolButton;\nclass ClickableLabel;\n\nclass UIcolorEditor : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit UIcolorEditor(QWidget* parent = nullptr);\n\npublic slots:\n    void updateComponents();\n\nprivate slots:\n    void updateUIcolor();\n    void updateLocalColor(const QColor);\n    void changeLastButton(CaptureToolButton*);\n\nprivate:\n    QColor m_uiColor, m_contrastColor;\n    CaptureToolButton* m_buttonMainColor;\n    ClickableLabel* m_labelMain;\n    CaptureToolButton* m_buttonContrast;\n    ClickableLabel* m_labelContrast;\n    CaptureToolButton* m_lastButtonPressed;\n    color_widgets::ColorWheel* m_colorWheel;\n\n    static const CaptureTool::Type m_buttonIconType = CaptureTool::TYPE_CIRCLE;\n\n    QHBoxLayout* m_hLayout;\n    QVBoxLayout* m_vLayout;\n\n    void initColorWheel();\n    void initButtons();\n};\n\n</code></pre>"},{"location":"flameshot/visualseditor_8cpp/","title":"File visualseditor.cpp","text":"<p>FileList &gt; config &gt; visualseditor.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"visualseditor.h\"</code></li> <li><code>#include \"src/config/buttonlistview.h\"</code></li> <li><code>#include \"src/config/colorpickereditor.h\"</code></li> <li><code>#include \"src/config/extendedslider.h\"</code></li> <li><code>#include \"src/config/uicoloreditor.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> </ul>"},{"location":"flameshot/visualseditor_8cpp_source/","title":"File visualseditor.cpp","text":"<p>File List &gt; config &gt; visualseditor.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"visualseditor.h\"\n#include \"src/config/buttonlistview.h\"\n#include \"src/config/colorpickereditor.h\"\n#include \"src/config/extendedslider.h\"\n#include \"src/config/uicoloreditor.h\"\n#include \"src/utils/confighandler.h\"\n#include &lt;QHBoxLayout&gt;\n#include &lt;QLabel&gt;\n\nVisualsEditor::VisualsEditor(QWidget* parent)\n  : QWidget(parent)\n{\n    m_layout = new QVBoxLayout();\n    setLayout(m_layout);\n    initWidgets();\n}\n\nvoid VisualsEditor::updateComponents()\n{\n    m_buttonList-&gt;updateComponents();\n    m_colorEditor-&gt;updateComponents();\n    int opacity = ConfigHandler().contrastOpacity();\n    m_opacitySlider-&gt;setMapedValue(0, opacity, 255);\n}\n\nvoid VisualsEditor::initOpacitySlider()\n{\n    m_opacitySlider = new ExtendedSlider();\n    m_opacitySlider-&gt;setFocusPolicy(Qt::NoFocus);\n    m_opacitySlider-&gt;setOrientation(Qt::Horizontal);\n    m_opacitySlider-&gt;setRange(0, 100);\n    auto* localLayout = new QHBoxLayout();\n    localLayout-&gt;addWidget(new QLabel(QStringLiteral(\"0%\")));\n    localLayout-&gt;addWidget(m_opacitySlider);\n    localLayout-&gt;addWidget(new QLabel(QStringLiteral(\"100%\")));\n\n    auto* label = new QLabel();\n    QString labelMsg = tr(\"Opacity of area outside selection:\") + \" %1%\";\n    ExtendedSlider* opacitySlider = m_opacitySlider;\n    connect(m_opacitySlider,\n            &amp;ExtendedSlider::valueChanged,\n            this,\n            [labelMsg, label, opacitySlider](int val) {\n                label-&gt;setText(labelMsg.arg(val));\n                ConfigHandler().setContrastOpacity(\n                  opacitySlider-&gt;mappedValue(0, 255));\n            });\n    m_layout-&gt;addWidget(label);\n    m_layout-&gt;addLayout(localLayout);\n\n    int opacity = ConfigHandler().contrastOpacity();\n    m_opacitySlider-&gt;setMapedValue(0, opacity, 255);\n}\n\nvoid VisualsEditor::initWidgets()\n{\n    m_tabWidget = new QTabWidget();\n    m_layout-&gt;addWidget(m_tabWidget);\n\n    m_colorEditor = new UIcolorEditor();\n    m_colorEditorTab = new QWidget();\n    auto* colorEditorLayout = new QVBoxLayout(m_colorEditorTab);\n    m_colorEditorTab-&gt;setLayout(colorEditorLayout);\n    colorEditorLayout-&gt;addWidget(m_colorEditor);\n    m_tabWidget-&gt;addTab(m_colorEditorTab, tr(\"UI Color Editor\"));\n\n    m_colorpickerEditor = new ColorPickerEditor();\n    m_colorpickerEditorTab = new QWidget();\n    auto* colorpickerEditorLayout = new QVBoxLayout(m_colorpickerEditorTab);\n    colorpickerEditorLayout-&gt;addWidget(m_colorpickerEditor);\n    m_tabWidget-&gt;addTab(m_colorpickerEditorTab, tr(\"Colorpicker Editor\"));\n\n    initOpacitySlider();\n\n    auto* boxButtons = new QGroupBox();\n    boxButtons-&gt;setTitle(tr(\"Button Selection\"));\n    auto* listLayout = new QVBoxLayout(boxButtons);\n    m_buttonList = new ButtonListView();\n    m_layout-&gt;addWidget(boxButtons);\n    listLayout-&gt;addWidget(m_buttonList);\n\n    auto* setAllButtons = new QPushButton(tr(\"Select All\"));\n    connect(setAllButtons,\n            &amp;QPushButton::clicked,\n            m_buttonList,\n            &amp;ButtonListView::selectAll);\n    listLayout-&gt;addWidget(setAllButtons);\n}\n\n</code></pre>"},{"location":"flameshot/visualseditor_8h/","title":"File visualseditor.h","text":"<p>FileList &gt; config &gt; visualseditor.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QTabWidget&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/visualseditor_8h/#classes","title":"Classes","text":"Type Name class VisualsEditor"},{"location":"flameshot/visualseditor_8h_source/","title":"File visualseditor.h","text":"<p>File List &gt; config &gt; visualseditor.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QTabWidget&gt;\n#include &lt;QWidget&gt;\n\nclass ExtendedSlider;\nclass QVBoxLayout;\nclass ButtonListView;\nclass UIcolorEditor;\nclass ColorPickerEditor;\n\nclass VisualsEditor : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit VisualsEditor(QWidget* parent = nullptr);\n\npublic slots:\n    void updateComponents();\n\nprivate:\n    QVBoxLayout* m_layout;\n\n    QTabWidget* m_tabWidget;\n\n    UIcolorEditor* m_colorEditor;\n    QWidget* m_colorEditorTab;\n\n    ColorPickerEditor* m_colorpickerEditor;\n    QWidget* m_colorpickerEditorTab;\n\n    ButtonListView* m_buttonList;\n    ExtendedSlider* m_opacitySlider;\n\n    void initWidgets();\n    void initOpacitySlider();\n};\n\n</code></pre>"},{"location":"flameshot/dir_aebb8dcc11953d78e620bbef0b9e2183/","title":"Dir core","text":"<p>FileList &gt; core</p>"},{"location":"flameshot/dir_aebb8dcc11953d78e620bbef0b9e2183/#files","title":"Files","text":"Type Name file capturerequest.cpp file capturerequest.h file flameshot.cpp file flameshot.h file flameshotdaemon.cpp file flameshotdaemon.h file flameshotdbusadapter.cpp file flameshotdbusadapter.h file globalshortcutfilter.cpp file globalshortcutfilter.h file qguiappcurrentscreen.cpp file qguiappcurrentscreen.h"},{"location":"flameshot/capturerequest_8cpp/","title":"File capturerequest.cpp","text":"<p>FileList &gt; core &gt; capturerequest.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturerequest.h\"</code></li> <li><code>#include \"confighandler.h\"</code></li> <li><code>#include \"src/config/cacheutils.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QClipboard&gt;</code></li> <li><code>#include &lt;QDateTime&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"flameshot/capturerequest_8cpp_source/","title":"File capturerequest.cpp","text":"<p>File List &gt; core &gt; capturerequest.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"capturerequest.h\"\n#include \"confighandler.h\"\n#include \"src/config/cacheutils.h\"\n#include &lt;QApplication&gt;\n#include &lt;QClipboard&gt;\n#include &lt;QDateTime&gt;\n#include &lt;stdexcept&gt;\n#include &lt;utility&gt;\n\nCaptureRequest::CaptureRequest(CaptureRequest::CaptureMode mode,\n                               const uint delay,\n                               QVariant data,\n                               CaptureRequest::ExportTask tasks)\n  : m_mode(mode)\n  , m_delay(delay)\n  , m_tasks(tasks)\n  , m_data(std::move(data))\n{\n\n    ConfigHandler config;\n    if (m_mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE &amp;&amp;\n        config.saveLastRegion()) {\n        setInitialSelection(getLastRegion());\n    }\n}\n\nCaptureRequest::CaptureMode CaptureRequest::captureMode() const\n{\n    return m_mode;\n}\n\nuint CaptureRequest::delay() const\n{\n    return m_delay;\n}\n\nQString CaptureRequest::path() const\n{\n    return m_path;\n}\n\nQVariant CaptureRequest::data() const\n{\n    return m_data;\n}\n\nCaptureRequest::ExportTask CaptureRequest::tasks() const\n{\n    return m_tasks;\n}\n\nQRect CaptureRequest::initialSelection() const\n{\n    return m_initialSelection;\n}\n\nvoid CaptureRequest::addTask(CaptureRequest::ExportTask task)\n{\n    if (task == SAVE) {\n        throw std::logic_error(\"SAVE task must be added using addSaveTask\");\n    }\n    m_tasks |= task;\n}\n\nvoid CaptureRequest::removeTask(ExportTask task)\n{\n    ((int&amp;)m_tasks) &amp;= ~task;\n}\n\nvoid CaptureRequest::addSaveTask(const QString&amp; path)\n{\n    m_tasks |= SAVE;\n    m_path = path;\n}\n\nvoid CaptureRequest::addPinTask(const QRect&amp; pinWindowGeometry)\n{\n    m_tasks |= PIN;\n    m_pinWindowGeometry = pinWindowGeometry;\n}\n\nvoid CaptureRequest::setInitialSelection(const QRect&amp; selection)\n{\n    m_initialSelection = selection;\n}\n\n</code></pre>"},{"location":"flameshot/capturerequest_8h/","title":"File capturerequest.h","text":"<p>FileList &gt; core &gt; capturerequest.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;QVariant&gt;</code></li> </ul>"},{"location":"flameshot/capturerequest_8h/#classes","title":"Classes","text":"Type Name class CaptureRequest"},{"location":"flameshot/capturerequest_8h/#public-types","title":"Public Types","text":"Type Name typedef CaptureRequest::ExportTask eTask"},{"location":"flameshot/capturerequest_8h/#public-functions","title":"Public Functions","text":"Type Name eTask operator&amp; (const eTask &amp; a, const eTask &amp; b)  eTask operator| (const eTask &amp; a, const eTask &amp; b)  eTask &amp; operator|= (eTask &amp; a, const eTask &amp; b)"},{"location":"flameshot/capturerequest_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/capturerequest_8h/#typedef-etask","title":"typedef eTask","text":"<pre><code>using eTask =  CaptureRequest::ExportTask;\n</code></pre>"},{"location":"flameshot/capturerequest_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/capturerequest_8h/#function-operator","title":"function operator&amp;","text":"<pre><code>inline eTask operator&amp; (\n    const eTask &amp; a,\n    const eTask &amp; b\n) \n</code></pre>"},{"location":"flameshot/capturerequest_8h/#function-operator_1","title":"function operator|","text":"<pre><code>inline eTask operator| (\n    const eTask &amp; a,\n    const eTask &amp; b\n) \n</code></pre>"},{"location":"flameshot/capturerequest_8h/#function-operator_2","title":"function operator|=","text":"<pre><code>inline eTask &amp; operator|= (\n    eTask &amp; a,\n    const eTask &amp; b\n) \n</code></pre>"},{"location":"flameshot/capturerequest_8h_source/","title":"File capturerequest.h","text":"<p>File List &gt; core &gt; capturerequest.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QPixmap&gt;\n#include &lt;QString&gt;\n#include &lt;QVariant&gt;\n\nclass CaptureRequest\n{\npublic:\n    enum CaptureMode\n    {\n        FULLSCREEN_MODE,\n        GRAPHICAL_MODE,\n        SCREEN_MODE,\n    };\n\n    enum ExportTask\n    {\n        NO_TASK = 0,\n        COPY = 1,\n        SAVE = 2,\n        PRINT_RAW = 4,\n        PRINT_GEOMETRY = 8,\n        PIN = 16,\n        UPLOAD = 32,\n        ACCEPT_ON_SELECT = 64,\n    };\n\n    CaptureRequest(CaptureMode mode,\n                   const uint delay = 0,\n                   QVariant data = QVariant(),\n                   ExportTask tasks = NO_TASK);\n\n    void setStaticID(uint id);\n\n    uint id() const;\n    uint delay() const;\n    QString path() const;\n    QVariant data() const;\n    CaptureMode captureMode() const;\n    ExportTask tasks() const;\n    QRect initialSelection() const;\n\n    void addTask(ExportTask task);\n    void removeTask(ExportTask task);\n    void addSaveTask(const QString&amp; path = QString());\n    void addPinTask(const QRect&amp; pinWindowGeometry);\n    void setInitialSelection(const QRect&amp; selection);\n\nprivate:\n    CaptureMode m_mode;\n    uint m_delay;\n    QString m_path;\n    ExportTask m_tasks;\n    QVariant m_data;\n    QRect m_pinWindowGeometry, m_initialSelection;\n\n    CaptureRequest() {}\n};\n\nusing eTask = CaptureRequest::ExportTask;\n\ninline eTask operator|(const eTask&amp; a, const eTask&amp; b)\n{\n    return static_cast&lt;eTask&gt;(static_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b));\n}\n\ninline eTask operator&amp;(const eTask&amp; a, const eTask&amp; b)\n{\n    return static_cast&lt;eTask&gt;(static_cast&lt;int&gt;(a) &amp; static_cast&lt;int&gt;(b));\n}\n\ninline eTask&amp; operator|=(eTask&amp; a, const eTask&amp; b)\n{\n    a = static_cast&lt;eTask&gt;(static_cast&lt;int&gt;(a) | static_cast&lt;int&gt;(b));\n    return a;\n}\n\n</code></pre>"},{"location":"flameshot/flameshot_8cpp/","title":"File flameshot.cpp","text":"<p>FileList &gt; core &gt; flameshot.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"flameshot.h\"</code></li> <li><code>#include \"flameshotdaemon.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"screenshotsaver.h\"</code></li> <li><code>#include \"src/config/configresolver.h\"</code></li> <li><code>#include \"src/config/configwindow.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/tools/imgupload/imguploadermanager.h\"</code></li> <li><code>#include \"src/tools/imgupload/storages/imguploaderbase.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/screengrabber.h\"</code></li> <li><code>#include \"src/widgets/capture/capturewidget.h\"</code></li> <li><code>#include \"src/widgets/capturelauncher.h\"</code></li> <li><code>#include \"src/widgets/imguploaddialog.h\"</code></li> <li><code>#include \"src/widgets/infowindow.h\"</code></li> <li><code>#include \"src/widgets/uploadhistory.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QBuffer&gt;</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QDesktopServices&gt;</code></li> <li><code>#include &lt;QDesktopWidget&gt;</code></li> <li><code>#include &lt;QFile&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QThread&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;QVersionNumber&gt;</code></li> </ul>"},{"location":"flameshot/flameshot_8cpp_source/","title":"File flameshot.cpp","text":"<p>File List &gt; core &gt; flameshot.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"flameshot.h\"\n#include \"flameshotdaemon.h\"\n#if defined(Q_OS_MACOS)\n#include \"external/QHotkey/QHotkey\"\n#endif\n\n#include \"abstractlogger.h\"\n#include \"screenshotsaver.h\"\n#include \"src/config/configresolver.h\"\n#include \"src/config/configwindow.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/tools/imgupload/imguploadermanager.h\"\n#include \"src/tools/imgupload/storages/imguploaderbase.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/screengrabber.h\"\n#include \"src/widgets/capture/capturewidget.h\"\n#include \"src/widgets/capturelauncher.h\"\n#include \"src/widgets/imguploaddialog.h\"\n#include \"src/widgets/infowindow.h\"\n#include \"src/widgets/uploadhistory.h\"\n#include &lt;QApplication&gt;\n#include &lt;QBuffer&gt;\n#include &lt;QDebug&gt;\n#include &lt;QDesktopServices&gt;\n#include &lt;QDesktopWidget&gt;\n#include &lt;QFile&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QThread&gt;\n#include &lt;QTimer&gt;\n#include &lt;QUrl&gt;\n#include &lt;QVersionNumber&gt;\n\n#if defined(Q_OS_MACOS)\n#include &lt;QScreen&gt;\n#endif\n\nFlameshot::Flameshot()\n  : m_captureWindow(nullptr)\n  , m_haveExternalWidget(false)\n#if defined(Q_OS_MACOS)\n  , m_HotkeyScreenshotCapture(nullptr)\n  , m_HotkeyScreenshotHistory(nullptr)\n#endif\n{\n    QString StyleSheet = CaptureButton::globalStyleSheet();\n    qApp-&gt;setStyleSheet(StyleSheet);\n\n#if defined(Q_OS_MACOS)\n    // Try to take a test screenshot, MacOS will request a \"Screen Recording\"\n    // permissions on the first run. Otherwise it will be hidden under the\n    // CaptureWidget\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    currentScreen-&gt;grabWindow(QApplication::desktop()-&gt;winId(), 0, 0, 1, 1);\n\n    // set global shortcuts for MacOS\n    m_HotkeyScreenshotCapture = new QHotkey(\n      QKeySequence(ConfigHandler().shortcut(\"TAKE_SCREENSHOT\")), true, this);\n    QObject::connect(m_HotkeyScreenshotCapture,\n                     &amp;QHotkey::activated,\n                     qApp,\n                     [this]() { gui(); });\n    m_HotkeyScreenshotHistory = new QHotkey(\n      QKeySequence(ConfigHandler().shortcut(\"SCREENSHOT_HISTORY\")), true, this);\n    QObject::connect(m_HotkeyScreenshotHistory,\n                     &amp;QHotkey::activated,\n                     qApp,\n                     [this]() { history(); });\n#endif\n}\n\nFlameshot* Flameshot::instance()\n{\n    static Flameshot c;\n    return &amp;c;\n}\n\nCaptureWidget* Flameshot::gui(const CaptureRequest&amp; req)\n{\n    if (!resolveAnyConfigErrors()) {\n        return nullptr;\n    }\n\n#if defined(Q_OS_MACOS)\n    // This is required on MacOS because of Mission Control. If you'll switch to\n    // another Desktop you cannot take a new screenshot from the tray, you have\n    // to switch back to the Flameshot Desktop manually. It is not obvious and a\n    // large number of users are confused and report a bug.\n    if (m_captureWindow != nullptr) {\n        m_captureWindow-&gt;close();\n        delete m_captureWindow;\n        m_captureWindow = nullptr;\n    }\n#endif\n\n    if (nullptr == m_captureWindow) {\n        // TODO is this unnecessary now?\n        int timeout = 5000; // 5 seconds\n        const int delay = 100;\n        QWidget* modalWidget = nullptr;\n        for (; timeout &gt;= 0; timeout -= delay) {\n            modalWidget = qApp-&gt;activeModalWidget();\n            if (nullptr == modalWidget) {\n                break;\n            }\n            modalWidget-&gt;close();\n            modalWidget-&gt;deleteLater();\n            QThread::msleep(delay);\n        }\n        if (0 == timeout) {\n            QMessageBox::warning(\n              nullptr, tr(\"Error\"), tr(\"Unable to close active modal widgets\"));\n            return nullptr;\n        }\n\n        m_captureWindow = new CaptureWidget(req);\n\n#ifdef Q_OS_WIN\n        m_captureWindow-&gt;show();\n#elif defined(Q_OS_MACOS)\n        // In \"Emulate fullscreen mode\"\n        m_captureWindow-&gt;showFullScreen();\n        m_captureWindow-&gt;activateWindow();\n        m_captureWindow-&gt;raise();\n#else\n        m_captureWindow-&gt;showFullScreen();\n//        m_captureWindow-&gt;show(); // For CaptureWidget Debugging under Linux\n#endif\n        return m_captureWindow;\n    } else {\n        emit captureFailed();\n        return nullptr;\n    }\n}\n\nvoid Flameshot::screen(CaptureRequest req, const int screenNumber)\n{\n    if (!resolveAnyConfigErrors()) {\n        return;\n    }\n\n    bool ok = true;\n    QScreen* screen;\n\n    if (screenNumber &lt; 0) {\n        QPoint globalCursorPos = QCursor::pos();\n        screen = qApp-&gt;screenAt(globalCursorPos);\n    } else if (screenNumber &gt;= qApp-&gt;screens().count()) {\n        AbstractLogger() &lt;&lt; QObject::tr(\n          \"Requested screen exceeds screen count\");\n        emit captureFailed();\n        return;\n    } else {\n        screen = qApp-&gt;screens()[screenNumber];\n    }\n    QPixmap p(ScreenGrabber().grabScreen(screen, ok));\n    if (ok) {\n        QRect geometry = ScreenGrabber().screenGeometry(screen);\n        QRect region = req.initialSelection();\n        if (region.isNull()) {\n            region = ScreenGrabber().screenGeometry(screen);\n        } else {\n            QRect screenGeom = ScreenGrabber().screenGeometry(screen);\n            screenGeom.moveTopLeft({ 0, 0 });\n            region = region.intersected(screenGeom);\n            p = p.copy(region);\n        }\n        if (req.tasks() &amp; CaptureRequest::PIN) {\n            // change geometry for pin task\n            req.addPinTask(region);\n        }\n        exportCapture(p, geometry, req);\n    } else {\n        emit captureFailed();\n    }\n}\n\nvoid Flameshot::full(const CaptureRequest&amp; req)\n{\n    if (!resolveAnyConfigErrors()) {\n        return;\n    }\n\n    bool ok = true;\n    QPixmap p(ScreenGrabber().grabEntireDesktop(ok));\n    QRect region = req.initialSelection();\n    if (!region.isNull()) {\n        p = p.copy(region);\n    }\n    if (ok) {\n        QRect selection; // `flameshot full` does not support --selection\n        exportCapture(p, selection, req);\n    } else {\n        emit captureFailed();\n    }\n}\n\nvoid Flameshot::launcher()\n{\n    if (!resolveAnyConfigErrors()) {\n        return;\n    }\n\n    if (m_launcherWindow == nullptr) {\n        m_launcherWindow = new CaptureLauncher();\n    }\n    m_launcherWindow-&gt;show();\n#if defined(Q_OS_MACOS)\n    m_launcherWindow-&gt;activateWindow();\n    m_launcherWindow-&gt;raise();\n#endif\n}\n\nvoid Flameshot::config()\n{\n    if (!resolveAnyConfigErrors()) {\n        return;\n    }\n\n    if (m_configWindow == nullptr) {\n        m_configWindow = new ConfigWindow();\n        m_configWindow-&gt;show();\n#if defined(Q_OS_MACOS)\n        m_configWindow-&gt;activateWindow();\n        m_configWindow-&gt;raise();\n#endif\n    }\n}\n\nvoid Flameshot::info()\n{\n    if (m_infoWindow == nullptr) {\n        m_infoWindow = new InfoWindow();\n#if defined(Q_OS_MACOS)\n        m_infoWindow-&gt;activateWindow();\n        m_infoWindow-&gt;raise();\n#endif\n    }\n}\n\nvoid Flameshot::history()\n{\n    static UploadHistory* historyWidget = nullptr;\n    if (historyWidget == nullptr) {\n        historyWidget = new UploadHistory;\n        historyWidget-&gt;loadHistory();\n        connect(historyWidget, &amp;QObject::destroyed, this, []() {\n            historyWidget = nullptr;\n        });\n    }\n    historyWidget-&gt;show();\n\n#if defined(Q_OS_MACOS)\n    historyWidget-&gt;activateWindow();\n    historyWidget-&gt;raise();\n#endif\n}\n\nvoid Flameshot::openSavePath()\n{\n    QString savePath = ConfigHandler().savePath();\n    if (!savePath.isEmpty()) {\n        QDesktopServices::openUrl(QUrl::fromLocalFile(savePath));\n    }\n}\n\nQVersionNumber Flameshot::getVersion()\n{\n    return QVersionNumber::fromString(\n      QStringLiteral(APP_VERSION).replace(\"v\", \"\"));\n}\n\nvoid Flameshot::setOrigin(Origin origin)\n{\n    m_origin = origin;\n}\n\nFlameshot::Origin Flameshot::origin()\n{\n    return m_origin;\n}\n\nbool Flameshot::resolveAnyConfigErrors()\n{\n    bool resolved = true;\n    ConfigHandler confighandler;\n    if (!confighandler.checkUnrecognizedSettings() ||\n        !confighandler.checkSemantics()) {\n        auto* resolver = new ConfigResolver();\n        QObject::connect(\n          resolver, &amp;ConfigResolver::rejected, [resolver, &amp;resolved]() {\n              resolved = false;\n              resolver-&gt;deleteLater();\n              if (origin() == CLI) {\n                  exit(1);\n              }\n          });\n        QObject::connect(\n          resolver, &amp;ConfigResolver::accepted, [resolver, &amp;resolved]() {\n              resolved = true;\n              resolver-&gt;close();\n              resolver-&gt;deleteLater();\n              // Ensure that the dialog is closed before starting capture\n              qApp-&gt;processEvents();\n          });\n        resolver-&gt;exec();\n        qApp-&gt;processEvents();\n    }\n    return resolved;\n}\n\nvoid Flameshot::requestCapture(const CaptureRequest&amp; request)\n{\n    if (!resolveAnyConfigErrors()) {\n        return;\n    }\n\n    switch (request.captureMode()) {\n        case CaptureRequest::FULLSCREEN_MODE:\n            QTimer::singleShot(request.delay(),\n                               [this, request] { full(request); });\n            break;\n        case CaptureRequest::SCREEN_MODE: {\n            int&amp;&amp; number = request.data().toInt();\n            QTimer::singleShot(request.delay(), [this, request, number]() {\n                screen(request, number);\n            });\n            break;\n        }\n        case CaptureRequest::GRAPHICAL_MODE: {\n            QTimer::singleShot(\n              request.delay(), this, [this, request]() { gui(request); });\n            break;\n        }\n        default:\n            emit captureFailed();\n            break;\n    }\n}\n\nvoid Flameshot::exportCapture(const QPixmap&amp; capture,\n                              QRect&amp; selection,\n                              const CaptureRequest&amp; req)\n{\n    using CR = CaptureRequest;\n    int tasks = req.tasks(), mode = req.captureMode();\n    QString path = req.path();\n\n    if (tasks &amp; CR::PRINT_GEOMETRY) {\n        QByteArray byteArray;\n        QBuffer buffer(&amp;byteArray);\n        QTextStream(stdout)\n          &lt;&lt; selection.width() &lt;&lt; \"x\" &lt;&lt; selection.height() &lt;&lt; \"+\"\n          &lt;&lt; selection.x() &lt;&lt; \"+\" &lt;&lt; selection.y() &lt;&lt; \"\\n\";\n    }\n\n    if (tasks &amp; CR::PRINT_RAW) {\n        QByteArray byteArray;\n        QBuffer buffer(&amp;byteArray);\n        capture.save(&amp;buffer, \"PNG\");\n        QFile file;\n        file.open(stdout, QIODevice::WriteOnly);\n\n        file.write(byteArray);\n        file.close();\n    }\n\n    if (tasks &amp; CR::SAVE) {\n        if (req.path().isEmpty()) {\n            saveToFilesystemGUI(capture);\n        } else {\n            saveToFilesystem(capture, path);\n        }\n    }\n\n    if (tasks &amp; CR::COPY) {\n        FlameshotDaemon::copyToClipboard(capture);\n    }\n\n    if (tasks &amp; CR::PIN) {\n        FlameshotDaemon::createPin(capture, selection);\n        if (mode == CR::SCREEN_MODE || mode == CR::FULLSCREEN_MODE) {\n            AbstractLogger::info()\n              &lt;&lt; QObject::tr(\"Full screen screenshot pinned to screen\");\n        }\n    }\n\n    if (tasks &amp; CR::UPLOAD) {\n        if (!ConfigHandler().uploadWithoutConfirmation()) {\n            auto* dialog = new ImgUploadDialog();\n            if (dialog-&gt;exec() == QDialog::Rejected) {\n                return;\n            }\n        }\n\n        ImgUploaderBase* widget = ImgUploaderManager().uploader(capture);\n        widget-&gt;show();\n        widget-&gt;activateWindow();\n        // NOTE: lambda can't capture 'this' because it might be destroyed later\n        CR::ExportTask tasks = tasks;\n        QObject::connect(\n          widget, &amp;ImgUploaderBase::uploadOk, [=](const QUrl&amp; url) {\n              if (ConfigHandler().copyURLAfterUpload()) {\n                  if (!(tasks &amp; CR::COPY)) {\n                      FlameshotDaemon::copyToClipboard(\n                        url.toString(), tr(\"URL copied to clipboard.\"));\n                  }\n                  widget-&gt;showPostUploadDialog();\n              }\n          });\n    }\n\n    if (!(tasks &amp; CR::UPLOAD)) {\n        emit captureTaken(capture);\n    }\n}\n\nvoid Flameshot::setExternalWidget(bool b)\n{\n    m_haveExternalWidget = b;\n}\nbool Flameshot::haveExternalWidget()\n{\n    return m_haveExternalWidget;\n}\n\n// STATIC ATTRIBUTES\nFlameshot::Origin Flameshot::m_origin = Flameshot::DAEMON;\n\n</code></pre>"},{"location":"flameshot/flameshot_8h/","title":"File flameshot.h","text":"<p>FileList &gt; core &gt; flameshot.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/core/capturerequest.h\"</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QVersionNumber&gt;</code></li> </ul>"},{"location":"flameshot/flameshot_8h/#classes","title":"Classes","text":"Type Name class Flameshot"},{"location":"flameshot/flameshot_8h_source/","title":"File flameshot.h","text":"<p>File List &gt; core &gt; flameshot.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/core/capturerequest.h\"\n#include &lt;QObject&gt;\n#include &lt;QPointer&gt;\n#include &lt;QVersionNumber&gt;\n\nclass CaptureWidget;\nclass ConfigWindow;\nclass InfoWindow;\nclass CaptureLauncher;\nclass UploadHistory;\n#if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) ||        \\\n     defined(Q_OS_MACX))\nclass QHotkey;\n#endif\n\nclass Flameshot : public QObject\n{\n    Q_OBJECT\n\npublic:\n    enum Origin\n    {\n        CLI,\n        DAEMON\n    };\n\n    static Flameshot* instance();\n\npublic slots:\n    CaptureWidget* gui(\n      const CaptureRequest&amp; req = CaptureRequest::GRAPHICAL_MODE);\n    void screen(CaptureRequest req, int const screenNumber = -1);\n    void full(const CaptureRequest&amp; req);\n    void launcher();\n    void config();\n\n    void info();\n    void history();\n\n    void openSavePath();\n\n    QVersionNumber getVersion();\n\npublic:\n    static void setOrigin(Origin origin);\n    static Origin origin();\n    void setExternalWidget(bool b);\n    bool haveExternalWidget();\n\nsignals:\n    void captureTaken(QPixmap p);\n    void captureFailed();\n\npublic slots:\n    void requestCapture(const CaptureRequest&amp; request);\n    void exportCapture(const QPixmap&amp; p,\n                       QRect&amp; selection,\n                       const CaptureRequest&amp; req);\n\nprivate:\n    Flameshot();\n    bool resolveAnyConfigErrors();\n\n    // class members\n    static Origin m_origin;\n    bool m_haveExternalWidget;\n\n    QPointer&lt;CaptureWidget&gt; m_captureWindow;\n    QPointer&lt;InfoWindow&gt; m_infoWindow;\n    QPointer&lt;CaptureLauncher&gt; m_launcherWindow;\n    QPointer&lt;ConfigWindow&gt; m_configWindow;\n\n#if (defined(Q_OS_MAC) || defined(Q_OS_MAC64) || defined(Q_OS_MACOS) ||        \\\n     defined(Q_OS_MACX))\n    QHotkey* m_HotkeyScreenshotCapture;\n    QHotkey* m_HotkeyScreenshotHistory;\n#endif\n};\n\n</code></pre>"},{"location":"flameshot/flameshotdaemon_8cpp/","title":"File flameshotdaemon.cpp","text":"<p>FileList &gt; core &gt; flameshotdaemon.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"flameshotdaemon.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"confighandler.h\"</code></li> <li><code>#include \"flameshot.h\"</code></li> <li><code>#include \"pinwidget.h\"</code></li> <li><code>#include \"screenshotsaver.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"src/widgets/capture/capturewidget.h\"</code></li> <li><code>#include \"src/widgets/trayicon.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QClipboard&gt;</code></li> <li><code>#include &lt;QDBusConnection&gt;</code></li> <li><code>#include &lt;QDBusMessage&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QRect&gt;</code></li> <li><code>#include &lt;QDesktopServices&gt;</code></li> <li><code>#include &lt;QJsonDocument&gt;</code></li> <li><code>#include &lt;QJsonObject&gt;</code></li> <li><code>#include &lt;QNetworkAccessManager&gt;</code></li> <li><code>#include &lt;QNetworkReply&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QUrl&gt;</code></li> </ul>"},{"location":"flameshot/flameshotdaemon_8cpp_source/","title":"File flameshotdaemon.cpp","text":"<p>File List &gt; core &gt; flameshotdaemon.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"flameshotdaemon.h\"\n\n#include \"abstractlogger.h\"\n#include \"confighandler.h\"\n#include \"flameshot.h\"\n#include \"pinwidget.h\"\n#include \"screenshotsaver.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"src/widgets/capture/capturewidget.h\"\n#include \"src/widgets/trayicon.h\"\n#include &lt;QApplication&gt;\n#include &lt;QClipboard&gt;\n#include &lt;QDBusConnection&gt;\n#include &lt;QDBusMessage&gt;\n#include &lt;QPixmap&gt;\n#include &lt;QRect&gt;\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n#include &lt;QDesktopServices&gt;\n#include &lt;QJsonDocument&gt;\n#include &lt;QJsonObject&gt;\n#include &lt;QNetworkAccessManager&gt;\n#include &lt;QNetworkReply&gt;\n#include &lt;QTimer&gt;\n#include &lt;QUrl&gt;\n#endif\n\n#ifdef Q_OS_WIN\n#include \"src/core/globalshortcutfilter.h\"\n#endif\n\nFlameshotDaemon::FlameshotDaemon()\n  : m_persist(false)\n  , m_hostingClipboard(false)\n  , m_clipboardSignalBlocked(false)\n  , m_trayIcon(nullptr)\n#if !defined(DISABLE_UPDATE_CHECKER)\n  , m_networkCheckUpdates(nullptr)\n  , m_showCheckAppUpdateStatus(false)\n  , m_appLatestVersion(QStringLiteral(APP_VERSION).replace(\"v\", \"\"))\n#endif\n{\n    connect(\n      QApplication::clipboard(), &amp;QClipboard::dataChanged, this, [this]() {\n          if (!m_hostingClipboard || m_clipboardSignalBlocked) {\n              m_clipboardSignalBlocked = false;\n              return;\n          }\n          m_hostingClipboard = false;\n          quitIfIdle();\n      });\n#ifdef Q_OS_WIN\n    m_persist = true;\n#else\n    m_persist = !ConfigHandler().autoCloseIdleDaemon();\n    connect(ConfigHandler::getInstance(),\n            &amp;ConfigHandler::fileChanged,\n            this,\n            [this]() {\n                ConfigHandler config;\n                enableTrayIcon(!config.disabledTrayIcon());\n                m_persist = !config.autoCloseIdleDaemon();\n            });\n#endif\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n    if (ConfigHandler().checkForUpdates()) {\n        getLatestAvailableVersion();\n    }\n#endif\n}\n\nvoid FlameshotDaemon::start()\n{\n    if (!m_instance) {\n        m_instance = new FlameshotDaemon();\n        // Tray icon needs FlameshotDaemon::instance() to be non-null\n        m_instance-&gt;initTrayIcon();\n        qApp-&gt;setQuitOnLastWindowClosed(false);\n    }\n}\n\nvoid FlameshotDaemon::createPin(const QPixmap&amp; capture, QRect geometry)\n{\n    if (instance()) {\n        instance()-&gt;attachPin(capture, geometry);\n        return;\n    }\n\n    QByteArray data;\n    QDataStream stream(&amp;data, QIODevice::WriteOnly);\n    stream &lt;&lt; capture;\n    stream &lt;&lt; geometry;\n    QDBusMessage m = createMethodCall(QStringLiteral(\"attachPin\"));\n    m &lt;&lt; data;\n    call(m);\n}\n\nvoid FlameshotDaemon::copyToClipboard(const QPixmap&amp; capture)\n{\n    if (instance()) {\n        instance()-&gt;attachScreenshotToClipboard(capture);\n        return;\n    }\n\n    QDBusMessage m =\n      createMethodCall(QStringLiteral(\"attachScreenshotToClipboard\"));\n\n    QByteArray data;\n    QDataStream stream(&amp;data, QIODevice::WriteOnly);\n    stream &lt;&lt; capture;\n\n    m &lt;&lt; data;\n    call(m);\n}\n\nvoid FlameshotDaemon::copyToClipboard(const QString&amp; text,\n                                      const QString&amp; notification)\n{\n    if (instance()) {\n        instance()-&gt;attachTextToClipboard(text, notification);\n        return;\n    }\n    auto m = createMethodCall(QStringLiteral(\"attachTextToClipboard\"));\n\n    m &lt;&lt; text &lt;&lt; notification;\n\n    QDBusConnection sessionBus = QDBusConnection::sessionBus();\n    checkDBusConnection(sessionBus);\n    sessionBus.call(m);\n}\n\nbool FlameshotDaemon::isThisInstanceHostingWidgets()\n{\n    return instance() &amp;&amp; !instance()-&gt;m_widgets.isEmpty();\n}\n\nvoid FlameshotDaemon::sendTrayNotification(const QString&amp; text,\n                                           const QString&amp; title,\n                                           const int timeout)\n{\n    if (m_trayIcon) {\n        m_trayIcon-&gt;showMessage(\n          title, text, QIcon(GlobalValues::iconPath()), timeout);\n    }\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nvoid FlameshotDaemon::showUpdateNotificationIfAvailable(CaptureWidget* widget)\n{\n    if (!m_appLatestUrl.isEmpty() &amp;&amp;\n        ConfigHandler().ignoreUpdateToVersion().compare(m_appLatestVersion) &lt;\n          0) {\n        widget-&gt;showAppUpdateNotification(m_appLatestVersion, m_appLatestUrl);\n    }\n}\n\nvoid FlameshotDaemon::getLatestAvailableVersion()\n{\n    // This features is required for MacOS and Windows user and for Linux users\n    // who installed Flameshot not from the repository.\n    QNetworkRequest requestCheckUpdates(QUrl(FLAMESHOT_APP_VERSION_URL));\n    if (nullptr == m_networkCheckUpdates) {\n        m_networkCheckUpdates = new QNetworkAccessManager(this);\n        connect(m_networkCheckUpdates,\n                &amp;QNetworkAccessManager::finished,\n                this,\n                &amp;FlameshotDaemon::handleReplyCheckUpdates);\n    }\n    m_networkCheckUpdates-&gt;get(requestCheckUpdates);\n\n    // check for updates each 24 hours\n    QTimer::singleShot(1000 * 60 * 60 * 24, [this]() {\n        if (ConfigHandler().checkForUpdates()) {\n            this-&gt;getLatestAvailableVersion();\n        }\n    });\n}\n\nvoid FlameshotDaemon::checkForUpdates()\n{\n    if (m_appLatestUrl.isEmpty()) {\n        m_showCheckAppUpdateStatus = true;\n        getLatestAvailableVersion();\n    } else {\n        QDesktopServices::openUrl(QUrl(m_appLatestUrl));\n    }\n}\n#endif\n\nFlameshotDaemon* FlameshotDaemon::instance()\n{\n    // Because we don't use DBus on MacOS, each instance of flameshot is its own\n    // mini-daemon, responsible for hosting its own persistent widgets (e.g.\n    // pins).\n#if defined(Q_OS_MACOS)\n    start();\n#endif\n    return m_instance;\n}\n\nvoid FlameshotDaemon::quitIfIdle()\n{\n    if (m_persist) {\n        return;\n    }\n    if (!m_hostingClipboard &amp;&amp; m_widgets.isEmpty()) {\n        qApp-&gt;exit(0);\n    }\n}\n\n// SERVICE METHODS\n\nvoid FlameshotDaemon::attachPin(const QPixmap&amp; pixmap, QRect geometry)\n{\n    auto* pinWidget = new PinWidget(pixmap, geometry);\n    m_widgets.append(pinWidget);\n    connect(pinWidget, &amp;QObject::destroyed, this, [=]() {\n        m_widgets.removeOne(pinWidget);\n        quitIfIdle();\n    });\n\n    pinWidget-&gt;show();\n    pinWidget-&gt;activateWindow();\n}\n\nvoid FlameshotDaemon::attachScreenshotToClipboard(const QPixmap&amp; pixmap)\n{\n    m_hostingClipboard = true;\n    QClipboard* clipboard = QApplication::clipboard();\n    clipboard-&gt;blockSignals(true);\n    // This variable is necessary because the signal doesn't get blocked on\n    // windows for some reason\n    m_clipboardSignalBlocked = true;\n    saveToClipboard(pixmap);\n    clipboard-&gt;blockSignals(false);\n}\n\n// D-BUS ADAPTER METHODS\n\nvoid FlameshotDaemon::attachPin(const QByteArray&amp; data)\n{\n    QDataStream stream(data);\n    QPixmap pixmap;\n    QRect geometry;\n\n    stream &gt;&gt; pixmap;\n    stream &gt;&gt; geometry;\n\n    attachPin(pixmap, geometry);\n}\n\nvoid FlameshotDaemon::attachScreenshotToClipboard(const QByteArray&amp; screenshot)\n{\n    QDataStream stream(screenshot);\n    QPixmap p;\n    stream &gt;&gt; p;\n\n    attachScreenshotToClipboard(p);\n}\n\nvoid FlameshotDaemon::attachTextToClipboard(const QString&amp; text,\n                                            const QString&amp; notification)\n{\n    // Must send notification before clipboard modification on linux\n    if (!notification.isEmpty()) {\n        AbstractLogger::info() &lt;&lt; notification;\n    }\n\n    m_hostingClipboard = true;\n    QClipboard* clipboard = QApplication::clipboard();\n\n    clipboard-&gt;blockSignals(true);\n    // This variable is necessary because the signal doesn't get blocked on\n    // windows for some reason\n    m_clipboardSignalBlocked = true;\n    clipboard-&gt;setText(text);\n    clipboard-&gt;blockSignals(false);\n}\n\nvoid FlameshotDaemon::initTrayIcon()\n{\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    if (!ConfigHandler().disabledTrayIcon()) {\n        enableTrayIcon(true);\n    }\n#elif defined(Q_OS_WIN)\n    enableTrayIcon(true);\n\n    GlobalShortcutFilter* nativeFilter = new GlobalShortcutFilter(this);\n    qApp-&gt;installNativeEventFilter(nativeFilter);\n    connect(nativeFilter, &amp;GlobalShortcutFilter::printPressed, this, [this]() {\n        Flameshot::instance()-&gt;gui();\n    });\n#endif\n}\n\nvoid FlameshotDaemon::enableTrayIcon(bool enable)\n{\n    if (enable) {\n        if (m_trayIcon == nullptr) {\n            m_trayIcon = new TrayIcon();\n        } else {\n            m_trayIcon-&gt;show();\n            return;\n        }\n    } else if (m_trayIcon) {\n        m_trayIcon-&gt;hide();\n    }\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nvoid FlameshotDaemon::handleReplyCheckUpdates(QNetworkReply* reply)\n{\n    if (!ConfigHandler().checkForUpdates()) {\n        return;\n    }\n    if (reply-&gt;error() == QNetworkReply::NoError) {\n        QJsonDocument response = QJsonDocument::fromJson(reply-&gt;readAll());\n        QJsonObject json = response.object();\n        m_appLatestVersion = json[\"tag_name\"].toString().replace(\"v\", \"\");\n\n        QVersionNumber appLatestVersion =\n          QVersionNumber::fromString(m_appLatestVersion);\n        if (Flameshot::instance()-&gt;getVersion() &lt; appLatestVersion) {\n            emit newVersionAvailable(appLatestVersion);\n            m_appLatestUrl = json[\"html_url\"].toString();\n            QString newVersion =\n              tr(\"New version %1 is available\").arg(m_appLatestVersion);\n            if (m_showCheckAppUpdateStatus) {\n                sendTrayNotification(newVersion, \"Flameshot\");\n                QDesktopServices::openUrl(QUrl(m_appLatestUrl));\n            }\n        } else if (m_showCheckAppUpdateStatus) {\n            sendTrayNotification(tr(\"You have the latest version\"),\n                                 \"Flameshot\");\n        }\n    } else {\n        qWarning() &lt;&lt; \"Failed to get information about the latest version. \"\n                   &lt;&lt; reply-&gt;errorString();\n        if (m_showCheckAppUpdateStatus) {\n            if (FlameshotDaemon::instance()) {\n                FlameshotDaemon::instance()-&gt;sendTrayNotification(\n                  tr(\"Failed to get information about the latest version.\"),\n                  \"Flameshot\");\n            }\n        }\n    }\n    m_showCheckAppUpdateStatus = false;\n}\n#endif\n\nQDBusMessage FlameshotDaemon::createMethodCall(const QString&amp; method)\n{\n    QDBusMessage m =\n      QDBusMessage::createMethodCall(QStringLiteral(\"org.flameshot.Flameshot\"),\n                                     QStringLiteral(\"/\"),\n                                     QLatin1String(\"\"),\n                                     method);\n    return m;\n}\n\nvoid FlameshotDaemon::checkDBusConnection(const QDBusConnection&amp; connection)\n{\n    if (!connection.isConnected()) {\n        AbstractLogger::error() &lt;&lt; tr(\"Unable to connect via DBus\");\n        qApp-&gt;exit(1);\n    }\n}\n\nvoid FlameshotDaemon::call(const QDBusMessage&amp; m)\n{\n    QDBusConnection sessionBus = QDBusConnection::sessionBus();\n    checkDBusConnection(sessionBus);\n    sessionBus.call(m);\n}\n\n// STATIC ATTRIBUTES\nFlameshotDaemon* FlameshotDaemon::m_instance = nullptr;\n\n</code></pre>"},{"location":"flameshot/flameshotdaemon_8h/","title":"File flameshotdaemon.h","text":"<p>FileList &gt; core &gt; flameshotdaemon.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QByteArray&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QtDBus/QDBusAbstractAdaptor&gt;</code></li> </ul>"},{"location":"flameshot/flameshotdaemon_8h/#classes","title":"Classes","text":"Type Name class FlameshotDaemon"},{"location":"flameshot/flameshotdaemon_8h_source/","title":"File flameshotdaemon.h","text":"<p>File List &gt; core &gt; flameshotdaemon.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#pragma once\n\n#include &lt;QByteArray&gt;\n#include &lt;QObject&gt;\n#include &lt;QtDBus/QDBusAbstractAdaptor&gt;\n\nclass QPixmap;\nclass QRect;\nclass QDBusMessage;\nclass QDBusConnection;\nclass TrayIcon;\nclass CaptureWidget;\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nclass QNetworkAccessManager;\nclass QNetworkReply;\nclass QVersionNumber;\n#endif\n\nclass FlameshotDaemon : public QObject\n{\n    Q_OBJECT\npublic:\n    static void start();\n    static FlameshotDaemon* instance();\n    static void createPin(const QPixmap&amp; capture, QRect geometry);\n    static void copyToClipboard(const QPixmap&amp; capture);\n    static void copyToClipboard(const QString&amp; text,\n                                const QString&amp; notification = \"\");\n    static bool isThisInstanceHostingWidgets();\n\n    void sendTrayNotification(\n      const QString&amp; text,\n      const QString&amp; title = QStringLiteral(\"Flameshot Info\"),\n      const int timeout = 5000);\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n    void showUpdateNotificationIfAvailable(CaptureWidget* widget);\n\npublic slots:\n    void checkForUpdates();\n    void getLatestAvailableVersion();\n\nprivate slots:\n    void handleReplyCheckUpdates(QNetworkReply* reply);\n\nsignals:\n    void newVersionAvailable(QVersionNumber version);\n#endif\n\nprivate:\n    FlameshotDaemon();\n    void quitIfIdle();\n    void attachPin(const QPixmap&amp; pixmap, QRect geometry);\n    void attachScreenshotToClipboard(const QPixmap&amp; pixmap);\n\n    void attachPin(const QByteArray&amp; data);\n    void attachScreenshotToClipboard(const QByteArray&amp; screenshot);\n    void attachTextToClipboard(const QString&amp; text,\n                               const QString&amp; notification);\n\n    void initTrayIcon();\n    void enableTrayIcon(bool enable);\n\nprivate:\n    static QDBusMessage createMethodCall(const QString&amp; method);\n    static void checkDBusConnection(const QDBusConnection&amp; connection);\n    static void call(const QDBusMessage&amp; m);\n\n    bool m_persist;\n    bool m_hostingClipboard;\n    bool m_clipboardSignalBlocked;\n    QList&lt;QWidget*&gt; m_widgets;\n    TrayIcon* m_trayIcon;\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n    QString m_appLatestUrl;\n    QString m_appLatestVersion;\n    bool m_showCheckAppUpdateStatus;\n    QNetworkAccessManager* m_networkCheckUpdates;\n#endif\n\n    static FlameshotDaemon* m_instance;\n\n    friend class FlameshotDBusAdapter;\n};\n\n</code></pre>"},{"location":"flameshot/flameshotdbusadapter_8cpp/","title":"File flameshotdbusadapter.cpp","text":"<p>FileList &gt; core &gt; flameshotdbusadapter.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"flameshotdbusadapter.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> </ul>"},{"location":"flameshot/flameshotdbusadapter_8cpp_source/","title":"File flameshotdbusadapter.cpp","text":"<p>File List &gt; core &gt; flameshotdbusadapter.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"flameshotdbusadapter.h\"\n#include \"src/core/flameshotdaemon.h\"\n\nFlameshotDBusAdapter::FlameshotDBusAdapter(QObject* parent)\n  : QDBusAbstractAdaptor(parent)\n{}\n\nFlameshotDBusAdapter::~FlameshotDBusAdapter() = default;\n\nvoid FlameshotDBusAdapter::attachScreenshotToClipboard(const QByteArray&amp; data)\n{\n    FlameshotDaemon::instance()-&gt;attachScreenshotToClipboard(data);\n}\n\nvoid FlameshotDBusAdapter::attachTextToClipboard(const QString&amp; text,\n                                                 const QString&amp; notification)\n{\n    FlameshotDaemon::instance()-&gt;attachTextToClipboard(text, notification);\n}\n\nvoid FlameshotDBusAdapter::attachPin(const QByteArray&amp; data)\n{\n    FlameshotDaemon::instance()-&gt;attachPin(data);\n}\n\n</code></pre>"},{"location":"flameshot/flameshotdbusadapter_8h/","title":"File flameshotdbusadapter.h","text":"<p>FileList &gt; core &gt; flameshotdbusadapter.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QtDBus/QDBusAbstractAdaptor&gt;</code></li> </ul>"},{"location":"flameshot/flameshotdbusadapter_8h/#classes","title":"Classes","text":"Type Name class FlameshotDBusAdapter"},{"location":"flameshot/flameshotdbusadapter_8h_source/","title":"File flameshotdbusadapter.h","text":"<p>File List &gt; core &gt; flameshotdbusadapter.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QtDBus/QDBusAbstractAdaptor&gt;\n\nclass FlameshotDBusAdapter : public QDBusAbstractAdaptor\n{\n    Q_OBJECT\n    Q_CLASSINFO(\"D-Bus Interface\", \"org.flameshot.Flameshot\")\n\npublic:\n    explicit FlameshotDBusAdapter(QObject* parent = nullptr);\n    virtual ~FlameshotDBusAdapter();\n\npublic slots:\n    Q_NOREPLY void attachScreenshotToClipboard(const QByteArray&amp; data);\n    Q_NOREPLY void attachTextToClipboard(const QString&amp; text,\n                                         const QString&amp; notification);\n    Q_NOREPLY void attachPin(const QByteArray&amp; data);\n};\n\n</code></pre>"},{"location":"flameshot/globalshortcutfilter_8cpp/","title":"File globalshortcutfilter.cpp","text":"<p>FileList &gt; core &gt; globalshortcutfilter.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"globalshortcutfilter.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include &lt;qt_windows.h&gt;</code></li> </ul>"},{"location":"flameshot/globalshortcutfilter_8cpp_source/","title":"File globalshortcutfilter.cpp","text":"<p>File List &gt; core &gt; globalshortcutfilter.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"globalshortcutfilter.h\"\n#include \"src/core/flameshot.h\"\n#include &lt;qt_windows.h&gt;\n\nGlobalShortcutFilter::GlobalShortcutFilter(QObject* parent)\n  : QObject(parent)\n{\n    // Forced Print Screen\n    if (RegisterHotKey(NULL, 1, 0, VK_SNAPSHOT)) {\n        // ok - capture screen\n    }\n\n    if (RegisterHotKey(NULL, 2, MOD_SHIFT, VK_SNAPSHOT)) {\n        // ok - show screenshots history\n    }\n}\n\nbool GlobalShortcutFilter::nativeEventFilter(const QByteArray&amp; eventType,\n                                             void* message,\n                                             long* result)\n{\n    Q_UNUSED(eventType)\n    Q_UNUSED(result)\n\n    MSG* msg = static_cast&lt;MSG*&gt;(message);\n    if (msg-&gt;message == WM_HOTKEY) {\n        // TODO: this is just a temporal workwrround, proper global\n        // support would need custom shortcuts defined by the user.\n        const quint32 keycode = HIWORD(msg-&gt;lParam);\n        const quint32 modifiers = LOWORD(msg-&gt;lParam);\n\n        // Show screenshots history\n        if (VK_SNAPSHOT == keycode &amp;&amp; MOD_SHIFT == modifiers) {\n            Flameshot::instance()-&gt;history();\n        }\n\n        // Capture screen\n        if (VK_SNAPSHOT == keycode &amp;&amp; 0 == modifiers) {\n            Flameshot::instance()-&gt;requestCapture(\n              CaptureRequest(CaptureRequest::GRAPHICAL_MODE));\n        }\n\n        return true;\n    }\n    return false;\n}\n\n</code></pre>"},{"location":"flameshot/globalshortcutfilter_8h/","title":"File globalshortcutfilter.h","text":"<p>FileList &gt; core &gt; globalshortcutfilter.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QAbstractNativeEventFilter&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/globalshortcutfilter_8h/#classes","title":"Classes","text":"Type Name class GlobalShortcutFilter"},{"location":"flameshot/globalshortcutfilter_8h_source/","title":"File globalshortcutfilter.h","text":"<p>File List &gt; core &gt; globalshortcutfilter.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QAbstractNativeEventFilter&gt;\n#include &lt;QObject&gt;\n\nclass GlobalShortcutFilter\n  : public QObject\n  , public QAbstractNativeEventFilter\n{\n    Q_OBJECT\npublic:\n    explicit GlobalShortcutFilter(QObject* parent = nullptr);\n\n    bool nativeEventFilter(const QByteArray&amp; eventType,\n                           void* message,\n                           long* result);\n\nsignals:\n    void printPressed();\n\nprivate:\n    quint32 getNativeModifier(Qt::KeyboardModifiers modifiers);\n    quint32 nativeKeycode(Qt::Key key);\n    bool registerShortcut(quint32 nativeKey, quint32 nativeMods);\n    bool unregisterShortcut(quint32 nativeKey, quint32 nativeMods);\n};\n\n</code></pre>"},{"location":"flameshot/qguiappcurrentscreen_8cpp/","title":"File qguiappcurrentscreen.cpp","text":"<p>FileList &gt; core &gt; qguiappcurrentscreen.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"qguiappcurrentscreen.h\"</code></li> <li><code>#include &lt;QCursor&gt;</code></li> <li><code>#include &lt;QDesktopWidget&gt;</code></li> <li><code>#include &lt;QGuiApplication&gt;</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/qguiappcurrentscreen_8cpp_source/","title":"File qguiappcurrentscreen.cpp","text":"<p>File List &gt; core &gt; qguiappcurrentscreen.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Yuriy Puchkov &lt;yuriy.puchkov@namecheap.com&gt;\n\n#include \"qguiappcurrentscreen.h\"\n#include &lt;QCursor&gt;\n#include &lt;QDesktopWidget&gt;\n#include &lt;QGuiApplication&gt;\n#include &lt;QPoint&gt;\n#include &lt;QScreen&gt;\n\nQGuiAppCurrentScreen::QGuiAppCurrentScreen()\n{\n    m_currentScreen = nullptr;\n}\n\nQScreen* QGuiAppCurrentScreen::currentScreen()\n{\n    return currentScreen(QCursor::pos());\n}\n\nQScreen* QGuiAppCurrentScreen::currentScreen(const QPoint&amp; pos)\n{\n    m_currentScreen = screenAt(pos);\n#if defined(Q_OS_MACOS)\n    // On the MacOS if mouse position is at the edge of bottom or right sides\n    // qGuiApp-&gt;screenAt will return nullptr, so we need to try to find current\n    // screen by moving 1 pixel inside to the current desktop area\n    if (!m_currentScreen &amp;&amp; pos.x() &gt; 0) {\n        QPoint posCorrected(pos.x() - 1, pos.y());\n        m_currentScreen = screenAt(posCorrected);\n    }\n    if (!m_currentScreen &amp;&amp; pos.y() &gt; 0) {\n        QPoint posCorrected(pos.x(), pos.y() - 1);\n        m_currentScreen = screenAt(posCorrected);\n    }\n    if (!m_currentScreen &amp;&amp; pos.x() &gt; 0 &amp;&amp; pos.y() &gt; 0) {\n        QPoint posCorrected(pos.x() - 1, pos.y() - 1);\n        m_currentScreen = screenAt(posCorrected);\n    }\n#endif\n    if (!m_currentScreen) {\n        qCritical(\"Unable to get current screen, starting to use primary \"\n                  \"screen. It may be a cause of logical error and working with \"\n                  \"a wrong screen.\");\n        m_currentScreen = qGuiApp-&gt;primaryScreen();\n    }\n    return m_currentScreen;\n}\n\nQScreen* QGuiAppCurrentScreen::screenAt(const QPoint&amp; pos)\n{\n#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0))\n    m_currentScreen = qGuiApp-&gt;screenAt(pos);\n#else\n    for (QScreen* const screen : QGuiApplication::screens()) {\n        m_currentScreen = screen;\n        if (screen-&gt;geometry().contains(pos)) {\n            break;\n        }\n    }\n#endif\n    return m_currentScreen;\n}\n\n</code></pre>"},{"location":"flameshot/qguiappcurrentscreen_8h/","title":"File qguiappcurrentscreen.h","text":"<p>FileList &gt; core &gt; qguiappcurrentscreen.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QPoint&gt;</code></li> </ul>"},{"location":"flameshot/qguiappcurrentscreen_8h/#classes","title":"Classes","text":"Type Name class QGuiAppCurrentScreen"},{"location":"flameshot/qguiappcurrentscreen_8h_source/","title":"File qguiappcurrentscreen.h","text":"<p>File List &gt; core &gt; qguiappcurrentscreen.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Yuriy Puchkov &lt;yuriy.puchkov@namecheap.com&gt;\n\n#ifndef FLAMESHOT_QGUIAPPCURRENTSCREEN_H\n#define FLAMESHOT_QGUIAPPCURRENTSCREEN_H\n\n#include &lt;QPoint&gt;\n\nclass QScreen;\n\nclass QGuiAppCurrentScreen\n{\npublic:\n    explicit QGuiAppCurrentScreen();\n    QScreen* currentScreen();\n    QScreen* currentScreen(const QPoint&amp; pos);\n\nprivate:\n    QScreen* screenAt(const QPoint&amp; pos);\n\n    // class members\nprivate:\n    QScreen* m_currentScreen;\n};\n\n#endif // FLAMESHOT_QGUIAPPCURRENTSCREEN_H\n\n</code></pre>"},{"location":"flameshot/main_8cpp/","title":"File main.cpp","text":"<p>FileList &gt; src &gt; main.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"singleapplication.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/cli/commandlineparser.h\"</code></li> <li><code>#include \"src/config/cacheutils.h\"</code></li> <li><code>#include \"src/config/styleoverride.h\"</code></li> <li><code>#include \"src/core/capturerequest.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/filenamehandler.h\"</code></li> <li><code>#include \"src/utils/pathinfo.h\"</code></li> <li><code>#include \"src/utils/valuehandler.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QLibraryInfo&gt;</code></li> <li><code>#include &lt;QSharedMemory&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QTranslator&gt;</code></li> </ul>"},{"location":"flameshot/main_8cpp/#public-attributes","title":"Public Attributes","text":"Type Name QTranslator qtTranslator QTranslator translator"},{"location":"flameshot/main_8cpp/#public-functions","title":"Public Functions","text":"Type Name void configureApp (bool gui)  QSharedMemory * guiMutexLock ()  int main (int argc, char * argv)  void reinitializeAsQApplication (int &amp; argc, char * argv) Recreate the application as a QApplication. void requestCaptureAndWait (const CaptureRequest &amp; req)"},{"location":"flameshot/main_8cpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/main_8cpp/#variable-qttranslator","title":"variable qtTranslator","text":"<pre><code>QTranslator qtTranslator;\n</code></pre>"},{"location":"flameshot/main_8cpp/#variable-translator","title":"variable translator","text":"<pre><code>QTranslator translator;\n</code></pre>"},{"location":"flameshot/main_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/main_8cpp/#function-configureapp","title":"function configureApp","text":"<pre><code>void configureApp (\n    bool gui\n) \n</code></pre>"},{"location":"flameshot/main_8cpp/#function-guimutexlock","title":"function guiMutexLock","text":"<pre><code>QSharedMemory * guiMutexLock () \n</code></pre>"},{"location":"flameshot/main_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    char * argv\n) \n</code></pre>"},{"location":"flameshot/main_8cpp/#function-reinitializeasqapplication","title":"function reinitializeAsQApplication","text":"<pre><code>void reinitializeAsQApplication (\n    int &amp; argc,\n    char * argv\n) \n</code></pre>"},{"location":"flameshot/main_8cpp/#function-requestcaptureandwait","title":"function requestCaptureAndWait","text":"<pre><code>void requestCaptureAndWait (\n    const CaptureRequest &amp; req\n) \n</code></pre>"},{"location":"flameshot/main_8cpp_source/","title":"File main.cpp","text":"<p>File List &gt; src &gt; main.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#ifndef USE_EXTERNAL_SINGLEAPPLICATION\n#include \"singleapplication.h\"\n#else\n#include \"QtSolutions/qtsingleapplication.h\"\n#endif\n\n#include \"abstractlogger.h\"\n#include \"src/cli/commandlineparser.h\"\n#include \"src/config/cacheutils.h\"\n#include \"src/config/styleoverride.h\"\n#include \"src/core/capturerequest.h\"\n#include \"src/core/flameshot.h\"\n#include \"src/core/flameshotdaemon.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/filenamehandler.h\"\n#include \"src/utils/pathinfo.h\"\n#include \"src/utils/valuehandler.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDir&gt;\n#include &lt;QLibraryInfo&gt;\n#include &lt;QSharedMemory&gt;\n#include &lt;QTimer&gt;\n#include &lt;QTranslator&gt;\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n#include \"abstractlogger.h\"\n#include \"src/core/flameshotdbusadapter.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDBusConnection&gt;\n#include &lt;QDBusMessage&gt;\n#include &lt;desktopinfo.h&gt;\n#endif\n\n#ifdef Q_OS_LINUX\n// source: https://github.com/ksnip/ksnip/issues/416\nvoid wayland_hacks()\n{\n    // Workaround to https://github.com/ksnip/ksnip/issues/416\n    DesktopInfo info;\n    if (info.windowManager() == DesktopInfo::GNOME) {\n        qputenv(\"QT_QPA_PLATFORM\", \"xcb\");\n    }\n}\n#endif\n\nvoid requestCaptureAndWait(const CaptureRequest&amp; req)\n{\n    Flameshot* flameshot = Flameshot::instance();\n    flameshot-&gt;requestCapture(req);\n    QObject::connect(flameshot, &amp;Flameshot::captureTaken, [&amp;](const QPixmap&amp;) {\n#if defined(Q_OS_MACOS)\n        // Only useful on MacOS because each instance hosts its own widgets\n        if (!FlameshotDaemon::isThisInstanceHostingWidgets()) {\n            qApp-&gt;exit(0);\n        }\n#else\n        // if this instance is not daemon, make sure it exit after caputre finish\n        if (FlameshotDaemon::instance() == nullptr &amp;&amp; !Flameshot::instance()-&gt;haveExternalWidget()) {\n            qApp-&gt;exit(0);\n        }\n#endif\n    });\n    QObject::connect(flameshot, &amp;Flameshot::captureFailed, []() {\n        AbstractLogger::info() &lt;&lt; \"Screenshot aborted.\";\n        qApp-&gt;exit(1);\n    });\n    qApp-&gt;exec();\n}\n\nQSharedMemory* guiMutexLock()\n{\n    QString key = \"org.flameshot.Flameshot-\" APP_VERSION;\n    auto* shm = new QSharedMemory(key);\n#ifdef Q_OS_UNIX\n    // Destroy shared memory if the last instance crashed on Unix\n    shm-&gt;attach();\n    delete shm;\n    shm = new QSharedMemory(key);\n#endif\n    if (!shm-&gt;create(1)) {\n        return nullptr;\n    }\n    return shm;\n}\n\nQTranslator translator, qtTranslator;\n\nvoid configureApp(bool gui)\n{\n    if (gui) {\n        QApplication::setStyle(new StyleOverride);\n    }\n\n    // Configure translations\n    for (const QString&amp; path : PathInfo::translationsPaths()) {\n        bool match = translator.load(QLocale(),\n                                     QStringLiteral(\"Internationalization\"),\n                                     QStringLiteral(\"_\"),\n                                     path);\n        if (match) {\n            break;\n        }\n    }\n\n    qtTranslator.load(QLocale::system(),\n                      \"qt\",\n                      \"_\",\n                      QLibraryInfo::location(QLibraryInfo::TranslationsPath));\n\n    auto app = QCoreApplication::instance();\n    app-&gt;installTranslator(&amp;translator);\n    app-&gt;installTranslator(&amp;qtTranslator);\n    app-&gt;setAttribute(Qt::AA_DontCreateNativeWidgetSiblings, true);\n}\n\n// TODO find a way so we don't have to do this\nvoid reinitializeAsQApplication(int&amp; argc, char* argv[])\n{\n    delete QCoreApplication::instance();\n    new QApplication(argc, argv);\n    configureApp(true);\n}\n\nint main(int argc, char* argv[])\n{\n#ifdef Q_OS_LINUX\n    wayland_hacks();\n#endif\n\n    // required for the button serialization\n    // TODO: change to QVector in v1.0\n    qRegisterMetaTypeStreamOperators&lt;QList&lt;int&gt;&gt;(\"QList&lt;int&gt;\");\n    QCoreApplication::setApplicationVersion(APP_VERSION);\n    QCoreApplication::setApplicationName(QStringLiteral(\"flameshot\"));\n    QCoreApplication::setOrganizationName(QStringLiteral(\"flameshot\"));\n\n    // no arguments, just launch Flameshot\n    if (argc == 1) {\n#ifndef USE_EXTERNAL_SINGLEAPPLICATION\n        SingleApplication app(argc, argv);\n#else\n        QtSingleApplication app(argc, argv);\n#endif\n        configureApp(true);\n        auto c = Flameshot::instance();\n        FlameshotDaemon::start();\n\n#if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN))\n        new FlameshotDBusAdapter(c);\n        QDBusConnection dbus = QDBusConnection::sessionBus();\n        if (!dbus.isConnected()) {\n            AbstractLogger::error()\n              &lt;&lt; QObject::tr(\"Unable to connect via DBus\");\n        }\n        dbus.registerObject(QStringLiteral(\"/\"), c);\n        dbus.registerService(QStringLiteral(\"org.flameshot.Flameshot\"));\n#endif\n        return qApp-&gt;exec();\n    }\n\n#if !defined(Q_OS_WIN)\n    /*--------------|\n     * CLI parsing  |\n     * ------------*/\n    new QCoreApplication(argc, argv);\n    configureApp(false);\n    CommandLineParser parser;\n    // Add description\n    parser.setDescription(\n      QObject::tr(\"Powerful yet simple to use screenshot software.\"));\n    parser.setGeneralErrorMessage(QObject::tr(\"See\") + \" flameshot --help.\");\n    // Arguments\n    CommandArgument fullArgument(\n      QStringLiteral(\"full\"),\n      QObject::tr(\"Capture screenshot of all monitors at the same time.\"));\n    CommandArgument launcherArgument(QStringLiteral(\"launcher\"),\n                                     QObject::tr(\"Open the capture launcher.\"));\n    CommandArgument guiArgument(\n      QStringLiteral(\"gui\"),\n      QObject::tr(\"Start a manual capture in GUI mode.\"));\n    CommandArgument configArgument(QStringLiteral(\"config\"),\n                                   QObject::tr(\"Configure\") + \" flameshot.\");\n    CommandArgument screenArgument(\n      QStringLiteral(\"screen\"),\n      QObject::tr(\"Capture a screenshot of the specified monitor.\"));\n\n    // Options\n    CommandOption pathOption(\n      { \"p\", \"path\" },\n      QObject::tr(\"Existing directory or new file to save to\"),\n      QStringLiteral(\"path\"));\n    CommandOption clipboardOption(\n      { \"c\", \"clipboard\" }, QObject::tr(\"Save the capture to the clipboard\"));\n    CommandOption pinOption(\"pin\",\n                            QObject::tr(\"Pin the capture to the screen\"));\n    CommandOption uploadOption({ \"u\", \"upload\" },\n                               QObject::tr(\"Upload screenshot\"));\n    CommandOption delayOption({ \"d\", \"delay\" },\n                              QObject::tr(\"Delay time in milliseconds\"),\n                              QStringLiteral(\"milliseconds\"));\n\n    CommandOption useLastRegionOption(\n      \"last-region\",\n      QObject::tr(\"Repeat screenshot with previously selected region\"));\n\n    CommandOption regionOption(\"region\",\n                               QObject::tr(\"Screenshot region to select\"),\n                               QStringLiteral(\"WxH+X+Y or string\"));\n    CommandOption filenameOption({ \"f\", \"filename\" },\n                                 QObject::tr(\"Set the filename pattern\"),\n                                 QStringLiteral(\"pattern\"));\n    CommandOption acceptOnSelectOption(\n      { \"s\", \"accept-on-select\" },\n      QObject::tr(\"Accept capture as soon as a selection is made\"));\n    CommandOption trayOption({ \"t\", \"trayicon\" },\n                             QObject::tr(\"Enable or disable the trayicon\"),\n                             QStringLiteral(\"bool\"));\n    CommandOption autostartOption(\n      { \"a\", \"autostart\" },\n      QObject::tr(\"Enable or disable run at startup\"),\n      QStringLiteral(\"bool\"));\n    CommandOption checkOption(\n      \"check\", QObject::tr(\"Check the configuration for errors\"));\n    CommandOption showHelpOption(\n      { \"s\", \"showhelp\" },\n      QObject::tr(\"Show the help message in the capture mode\"),\n      QStringLiteral(\"bool\"));\n    CommandOption mainColorOption({ \"m\", \"maincolor\" },\n                                  QObject::tr(\"Define the main UI color\"),\n                                  QStringLiteral(\"color-code\"));\n    CommandOption contrastColorOption(\n      { \"k\", \"contrastcolor\" },\n      QObject::tr(\"Define the contrast UI color\"),\n      QStringLiteral(\"color-code\"));\n    CommandOption rawImageOption({ \"r\", \"raw\" },\n                                 QObject::tr(\"Print raw PNG capture\"));\n    CommandOption selectionOption(\n      { \"g\", \"print-geometry\" },\n      QObject::tr(\"Print geometry of the selection in the format WxH+X+Y. Does \"\n                  \"nothing if raw is specified\"));\n    CommandOption screenNumberOption(\n      { \"n\", \"number\" },\n      QObject::tr(\"Define the screen to capture (starting from 0)\") + \",\\n\" +\n        QObject::tr(\"default: screen containing the cursor\"),\n      QObject::tr(\"Screen number\"),\n      QStringLiteral(\"-1\"));\n\n    // Add checkers\n    auto colorChecker = [](const QString&amp; colorCode) -&gt; bool {\n        QColor parsedColor(colorCode);\n        return parsedColor.isValid() &amp;&amp; parsedColor.alphaF() == 1.0;\n    };\n    QString colorErr =\n      QObject::tr(\"Invalid color, \"\n                  \"this flag supports the following formats:\\n\"\n                  \"- #RGB (each of R, G, and B is a single hex digit)\\n\"\n                  \"- #RRGGBB\\n- #RRRGGGBBB\\n\"\n                  \"- #RRRRGGGGBBBB\\n\"\n                  \"- Named colors like 'blue' or 'red'\\n\"\n                  \"You may need to escape the '#' sign as in '\\\\#FFF'\");\n\n    const QString delayErr =\n      QObject::tr(\"Invalid delay, it must be a number greater than 0\");\n    const QString numberErr =\n      QObject::tr(\"Invalid screen number, it must be non negative\");\n    const QString regionErr = QObject::tr(\n      \"Invalid region, use 'WxH+X+Y' or 'all' or 'screen0/screen1/...'.\");\n    auto numericChecker = [](const QString&amp; delayValue) -&gt; bool {\n        bool ok;\n        int value = delayValue.toInt(&amp;ok);\n        return ok &amp;&amp; value &gt;= 0;\n    };\n    auto regionChecker = [](const QString&amp; region) -&gt; bool {\n        Region valueHandler;\n        return valueHandler.check(region);\n    };\n\n    const QString pathErr =\n      QObject::tr(\"Invalid path, must be an existing directory or a new file \"\n                  \"in an existing directory\");\n    auto pathChecker = [pathErr](const QString&amp; pathValue) -&gt; bool {\n        QFileInfo fileInfo(pathValue);\n        if (fileInfo.isDir() || fileInfo.dir().exists()) {\n            return true;\n        } else {\n            AbstractLogger::error() &lt;&lt; QObject::tr(pathErr.toLatin1().data());\n            return false;\n        }\n    };\n\n    const QString booleanErr =\n      QObject::tr(\"Invalid value, it must be defined as 'true' or 'false'\");\n    auto booleanChecker = [](const QString&amp; value) -&gt; bool {\n        return value == QLatin1String(\"true\") ||\n               value == QLatin1String(\"false\");\n    };\n\n    contrastColorOption.addChecker(colorChecker, colorErr);\n    mainColorOption.addChecker(colorChecker, colorErr);\n    delayOption.addChecker(numericChecker, delayErr);\n    regionOption.addChecker(regionChecker, regionErr);\n    useLastRegionOption.addChecker(booleanChecker, booleanErr);\n    pathOption.addChecker(pathChecker, pathErr);\n    trayOption.addChecker(booleanChecker, booleanErr);\n    autostartOption.addChecker(booleanChecker, booleanErr);\n    showHelpOption.addChecker(booleanChecker, booleanErr);\n    screenNumberOption.addChecker(numericChecker, numberErr);\n\n    // Relationships\n    parser.AddArgument(guiArgument);\n    parser.AddArgument(screenArgument);\n    parser.AddArgument(fullArgument);\n    parser.AddArgument(launcherArgument);\n    parser.AddArgument(configArgument);\n    auto helpOption = parser.addHelpOption();\n    auto versionOption = parser.addVersionOption();\n    parser.AddOptions({ pathOption,\n                        clipboardOption,\n                        delayOption,\n                        regionOption,\n                        useLastRegionOption,\n                        rawImageOption,\n                        selectionOption,\n                        uploadOption,\n                        pinOption,\n                        acceptOnSelectOption },\n                      guiArgument);\n    parser.AddOptions({ screenNumberOption,\n                        clipboardOption,\n                        pathOption,\n                        delayOption,\n                        regionOption,\n                        rawImageOption,\n                        uploadOption,\n                        pinOption },\n                      screenArgument);\n    parser.AddOptions({ pathOption,\n                        clipboardOption,\n                        delayOption,\n                        regionOption,\n                        rawImageOption,\n                        uploadOption },\n                      fullArgument);\n    parser.AddOptions({ autostartOption,\n                        filenameOption,\n                        trayOption,\n                        showHelpOption,\n                        mainColorOption,\n                        contrastColorOption,\n                        checkOption },\n                      configArgument);\n    // Parse\n    if (!parser.parse(qApp-&gt;arguments())) {\n        goto finish;\n    }\n\n    // PROCESS DATA\n    //--------------\n    Flameshot::setOrigin(Flameshot::CLI);\n    if (parser.isSet(helpOption) || parser.isSet(versionOption)) {\n    } else if (parser.isSet(launcherArgument)) { // LAUNCHER\n        reinitializeAsQApplication(argc, argv);\n        Flameshot* flameshot = Flameshot::instance();\n        flameshot-&gt;launcher();\n        qApp-&gt;exec();\n    } else if (parser.isSet(guiArgument)) { // GUI\n        reinitializeAsQApplication(argc, argv);\n        // Prevent multiple instances of 'flameshot gui' from running if not\n        // configured to do so.\n        if (!ConfigHandler().allowMultipleGuiInstances()) {\n            auto* mutex = guiMutexLock();\n            if (!mutex) {\n                return 1;\n            }\n            QObject::connect(\n              qApp, &amp;QCoreApplication::aboutToQuit, qApp, [mutex]() {\n                  mutex-&gt;detach();\n                  delete mutex;\n              });\n        }\n\n        // Option values\n        QString path = parser.value(pathOption);\n        if (!path.isEmpty()) {\n            path = QDir(path).absolutePath();\n        }\n        int delay = parser.value(delayOption).toInt();\n        QString region = parser.value(regionOption);\n        bool useLastRegion = parser.isSet(useLastRegionOption);\n        bool clipboard = parser.isSet(clipboardOption);\n        bool raw = parser.isSet(rawImageOption);\n        bool printGeometry = parser.isSet(selectionOption);\n        bool pin = parser.isSet(pinOption);\n        bool upload = parser.isSet(uploadOption);\n        bool acceptOnSelect = parser.isSet(acceptOnSelectOption);\n        CaptureRequest req(CaptureRequest::GRAPHICAL_MODE, delay, path);\n        if (!region.isEmpty()) {\n            auto selectionRegion = Region().value(region).toRect();\n            req.setInitialSelection(selectionRegion);\n        } else if (useLastRegion) {\n            req.setInitialSelection(getLastRegion());\n        }\n        if (clipboard) {\n            req.addTask(CaptureRequest::COPY);\n        }\n        if (raw) {\n            req.addTask(CaptureRequest::PRINT_RAW);\n        }\n        if (!path.isEmpty()) {\n            req.addSaveTask(path);\n        }\n        if (printGeometry) {\n            req.addTask(CaptureRequest::PRINT_GEOMETRY);\n        }\n        if (pin) {\n            req.addTask(CaptureRequest::PIN);\n        }\n        if (upload) {\n            req.addTask(CaptureRequest::UPLOAD);\n        }\n        if (acceptOnSelect) {\n            req.addTask(CaptureRequest::ACCEPT_ON_SELECT);\n            if (!clipboard &amp;&amp; !raw &amp;&amp; path.isEmpty() &amp;&amp; !printGeometry &amp;&amp;\n                !pin &amp;&amp; !upload) {\n                req.addSaveTask();\n            }\n        }\n        requestCaptureAndWait(req);\n    } else if (parser.isSet(fullArgument)) { // FULL\n        reinitializeAsQApplication(argc, argv);\n\n        // Option values\n        QString path = parser.value(pathOption);\n        if (!path.isEmpty()) {\n            path = QDir(path).absolutePath();\n        }\n        int delay = parser.value(delayOption).toInt();\n        QString region = parser.value(regionOption);\n        bool clipboard = parser.isSet(clipboardOption);\n        bool raw = parser.isSet(rawImageOption);\n        bool upload = parser.isSet(uploadOption);\n        // Not a valid command\n\n        CaptureRequest req(CaptureRequest::FULLSCREEN_MODE, delay);\n        if (!region.isEmpty()) {\n            req.setInitialSelection(Region().value(region).toRect());\n        }\n        if (clipboard) {\n            req.addTask(CaptureRequest::COPY);\n        }\n        if (!path.isEmpty()) {\n            req.addSaveTask(path);\n        }\n        if (raw) {\n            req.addTask(CaptureRequest::PRINT_RAW);\n        }\n        if (upload) {\n            req.addTask(CaptureRequest::UPLOAD);\n        }\n        if (!clipboard &amp;&amp; path.isEmpty() &amp;&amp; !raw &amp;&amp; !upload) {\n            req.addSaveTask();\n        }\n        requestCaptureAndWait(req);\n    } else if (parser.isSet(screenArgument)) { // SCREEN\n        reinitializeAsQApplication(argc, argv);\n\n        QString numberStr = parser.value(screenNumberOption);\n        // Option values\n        int screenNumber =\n          numberStr.startsWith(QLatin1String(\"-\")) ? -1 : numberStr.toInt();\n        QString path = parser.value(pathOption);\n        if (!path.isEmpty()) {\n            path = QDir(path).absolutePath();\n        }\n        int delay = parser.value(delayOption).toInt();\n        QString region = parser.value(regionOption);\n        bool clipboard = parser.isSet(clipboardOption);\n        bool raw = parser.isSet(rawImageOption);\n        bool pin = parser.isSet(pinOption);\n        bool upload = parser.isSet(uploadOption);\n\n        CaptureRequest req(CaptureRequest::SCREEN_MODE, delay, screenNumber);\n        if (!region.isEmpty()) {\n            if (region.startsWith(\"screen\")) {\n                AbstractLogger::error()\n                  &lt;&lt; \"The 'screen' command does not support \"\n                     \"'--region screen&lt;N&gt;'.\\n\"\n                     \"See flameshot --help.\\n\";\n                exit(1);\n            }\n            req.setInitialSelection(Region().value(region).toRect());\n        }\n        if (clipboard) {\n            req.addTask(CaptureRequest::COPY);\n        }\n        if (raw) {\n            req.addTask(CaptureRequest::PRINT_RAW);\n        }\n        if (!path.isEmpty()) {\n            req.addSaveTask(path);\n        }\n        if (pin) {\n            req.addTask(CaptureRequest::PIN);\n        }\n        if (upload) {\n            req.addTask(CaptureRequest::UPLOAD);\n        }\n\n        if (!clipboard &amp;&amp; !raw &amp;&amp; path.isEmpty() &amp;&amp; !pin &amp;&amp; !upload) {\n            req.addSaveTask();\n        }\n\n        requestCaptureAndWait(req);\n    } else if (parser.isSet(configArgument)) { // CONFIG\n        bool autostart = parser.isSet(autostartOption);\n        bool filename = parser.isSet(filenameOption);\n        bool tray = parser.isSet(trayOption);\n        bool mainColor = parser.isSet(mainColorOption);\n        bool contrastColor = parser.isSet(contrastColorOption);\n        bool check = parser.isSet(checkOption);\n        bool someFlagSet =\n          (filename || tray || mainColor || contrastColor || check);\n        if (check) {\n            AbstractLogger err = AbstractLogger::error(AbstractLogger::Stderr);\n            bool ok = ConfigHandler().checkForErrors(&amp;err);\n            if (ok) {\n                AbstractLogger::info()\n                  &lt;&lt; QStringLiteral(\"No errors detected.\\n\");\n                goto finish;\n            } else {\n                return 1;\n            }\n        }\n        if (!someFlagSet) {\n            // Open gui when no options are given\n            reinitializeAsQApplication(argc, argv);\n            QObject::connect(\n              qApp, &amp;QApplication::lastWindowClosed, qApp, &amp;QApplication::quit);\n            Flameshot::instance()-&gt;config();\n            qApp-&gt;exec();\n        } else {\n            ConfigHandler config;\n\n            if (autostart) {\n                config.setStartupLaunch(parser.value(autostartOption) ==\n                                        \"true\");\n            }\n            if (filename) {\n                QString newFilename(parser.value(filenameOption));\n                config.setFilenamePattern(newFilename);\n                FileNameHandler fh;\n                QTextStream(stdout)\n                  &lt;&lt; QStringLiteral(\"The new pattern is '%1'\\n\"\n                                    \"Parsed pattern example: %2\\n\")\n                       .arg(newFilename)\n                       .arg(fh.parsedPattern());\n            }\n            if (tray) {\n                config.setDisabledTrayIcon(parser.value(trayOption) == \"false\");\n            }\n            if (mainColor) {\n                // TODO use value handler\n                QString colorCode = parser.value(mainColorOption);\n                QColor parsedColor(colorCode);\n                config.setUiColor(parsedColor);\n            }\n            if (contrastColor) {\n                QString colorCode = parser.value(contrastColorOption);\n                QColor parsedColor(colorCode);\n                config.setContrastUiColor(parsedColor);\n            }\n        }\n    }\nfinish:\n\n#endif\n    return 0;\n}\n\n</code></pre>"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/","title":"Dir tools","text":"<p>FileList &gt; src &gt; tools</p>"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/#files","title":"Files","text":"Type Name file abstractactiontool.cpp file abstractactiontool.h file abstractpathtool.cpp file abstractpathtool.h file abstracttwopointtool.cpp file abstracttwopointtool.h file capturecontext.cpp file capturecontext.h file toolfactory.cpp file toolfactory.h"},{"location":"flameshot/dir_1563a38af0d3a5e4a6330d6d45e9792a/#directories","title":"Directories","text":"Type Name dir accept dir arrow dir circle dir circlecount dir copy dir exit dir imgupload dir invert dir launcher dir line dir marker dir move dir pencil dir pin dir pixelate dir rectangle dir redo dir save dir selection dir sizedecrease dir sizeincrease dir text dir undo"},{"location":"flameshot/abstractactiontool_8cpp/","title":"File abstractactiontool.cpp","text":"<p>FileList &gt; src &gt; tools &gt; abstractactiontool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/abstractactiontool_8cpp_source/","title":"File abstractactiontool.cpp","text":"<p>File List &gt; src &gt; tools &gt; abstractactiontool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"abstractactiontool.h\"\n\nAbstractActionTool::AbstractActionTool(QObject* parent)\n  : CaptureTool(parent)\n{}\n\nbool AbstractActionTool::isValid() const\n{\n    return true;\n}\n\nbool AbstractActionTool::isSelectable() const\n{\n    return false;\n}\n\nbool AbstractActionTool::showMousePreview() const\n{\n    return false;\n}\n\nQRect AbstractActionTool::boundingRect() const\n{\n    return {};\n}\n\nvoid AbstractActionTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(painter)\n    Q_UNUSED(pixmap)\n}\n\nvoid AbstractActionTool::paintMousePreview(QPainter&amp; painter,\n                                           const CaptureContext&amp; context)\n{\n    Q_UNUSED(painter)\n    Q_UNUSED(context)\n}\n\nvoid AbstractActionTool::drawEnd(const QPoint&amp; p)\n{\n    Q_UNUSED(p)\n}\n\nvoid AbstractActionTool::drawMove(const QPoint&amp; p)\n{\n    Q_UNUSED(p)\n}\n\nvoid AbstractActionTool::drawStart(const CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\nvoid AbstractActionTool::onColorChanged(const QColor&amp; c)\n{\n    Q_UNUSED(c)\n}\n\nvoid AbstractActionTool::onSizeChanged(int size)\n{\n    Q_UNUSED(size)\n}\n\n</code></pre>"},{"location":"flameshot/abstractactiontool_8h/","title":"File abstractactiontool.h","text":"<p>FileList &gt; src &gt; tools &gt; abstractactiontool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetool.h\"</code></li> </ul>"},{"location":"flameshot/abstractactiontool_8h/#classes","title":"Classes","text":"Type Name class AbstractActionTool"},{"location":"flameshot/abstractactiontool_8h_source/","title":"File abstractactiontool.h","text":"<p>File List &gt; src &gt; tools &gt; abstractactiontool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"capturetool.h\"\n\nclass AbstractActionTool : public CaptureTool\n{\n    Q_OBJECT\npublic:\n    explicit AbstractActionTool(QObject* parent = nullptr);\n\n    bool isValid() const override;\n    bool isSelectable() const override;\n    bool showMousePreview() const override;\n    QRect boundingRect() const override;\n\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\npublic slots:\n    void drawEnd(const QPoint&amp; p) override;\n    void drawMove(const QPoint&amp; p) override;\n    void drawStart(const CaptureContext&amp; context) override;\n    void onColorChanged(const QColor&amp; c) override;\n    void onSizeChanged(int size) override;\n};\n\n</code></pre>"},{"location":"flameshot/abstractpathtool_8cpp/","title":"File abstractpathtool.cpp","text":"<p>FileList &gt; src &gt; tools &gt; abstractpathtool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"abstractpathtool.h\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"flameshot/abstractpathtool_8cpp_source/","title":"File abstractpathtool.cpp","text":"<p>File List &gt; src &gt; tools &gt; abstractpathtool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"abstractpathtool.h\"\n#include &lt;cmath&gt;\n\nAbstractPathTool::AbstractPathTool(QObject* parent)\n  : CaptureTool(parent)\n  , m_thickness(1)\n  , m_padding(0)\n{}\n\nvoid AbstractPathTool::copyParams(const AbstractPathTool* from,\n                                  AbstractPathTool* to)\n{\n    to-&gt;m_color = from-&gt;m_color;\n    to-&gt;m_thickness = from-&gt;m_thickness;\n    to-&gt;m_padding = from-&gt;m_padding;\n    to-&gt;m_pos = from-&gt;m_pos;\n\n    to-&gt;m_points.clear();\n    for (auto point : from-&gt;m_points) {\n        to-&gt;m_points.append(point);\n    }\n}\n\nbool AbstractPathTool::isValid() const\n{\n    return m_points.length() &gt; 1;\n}\n\nbool AbstractPathTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nbool AbstractPathTool::isSelectable() const\n{\n    return true;\n}\n\nbool AbstractPathTool::showMousePreview() const\n{\n    return true;\n}\n\nQRect AbstractPathTool::mousePreviewRect(const CaptureContext&amp; context) const\n{\n    QRect rect(0, 0, context.toolSize + 2, context.toolSize + 2);\n    rect.moveCenter(context.mousePos);\n    return rect;\n}\n\nQRect AbstractPathTool::boundingRect() const\n{\n    if (m_points.isEmpty()) {\n        return {};\n    }\n    int min_x = m_points.at(0).x();\n    int min_y = m_points.at(0).y();\n    int max_x = m_points.at(0).x();\n    int max_y = m_points.at(0).y();\n    for (auto point : m_points) {\n        if (point.x() &lt; min_x) {\n            min_x = point.x();\n        }\n        if (point.y() &lt; min_y) {\n            min_y = point.y();\n        }\n        if (point.x() &gt; max_x) {\n            max_x = point.x();\n        }\n        if (point.y() &gt; max_y) {\n            max_y = point.y();\n        }\n    }\n\n    int offset =\n      m_thickness &lt;= 1 ? 1 : static_cast&lt;int&gt;(round(m_thickness * 0.7 + 0.5));\n    return QRect(min_x - offset,\n                 min_y - offset,\n                 std::abs(min_x - max_x) + offset * 2,\n                 std::abs(min_y - max_y) + offset * 2)\n      .normalized();\n}\n\nvoid AbstractPathTool::drawEnd(const QPoint&amp; p)\n{\n    Q_UNUSED(p)\n}\n\nvoid AbstractPathTool::drawMove(const QPoint&amp; p)\n{\n    addPoint(p);\n}\n\nvoid AbstractPathTool::onColorChanged(const QColor&amp; c)\n{\n    m_color = c;\n}\n\nvoid AbstractPathTool::onSizeChanged(int size)\n{\n    m_thickness = size;\n}\n\nvoid AbstractPathTool::addPoint(const QPoint&amp; point)\n{\n    if (m_pathArea.left() &gt; point.x()) {\n        m_pathArea.setLeft(point.x());\n    } else if (m_pathArea.right() &lt; point.x()) {\n        m_pathArea.setRight(point.x());\n    }\n    if (m_pathArea.top() &gt; point.y()) {\n        m_pathArea.setTop(point.y());\n    } else if (m_pathArea.bottom() &lt; point.y()) {\n        m_pathArea.setBottom(point.y());\n    }\n    m_points.append(point);\n}\n\nvoid AbstractPathTool::move(const QPoint&amp; mousePos)\n{\n    if (m_points.empty()) {\n        return;\n    }\n    QPoint basePos = *pos();\n    QPoint offset = mousePos - basePos;\n    for (auto&amp; m_point : m_points) {\n        m_point += offset;\n    }\n}\n\nconst QPoint* AbstractPathTool::pos()\n{\n    if (m_points.empty()) {\n        m_pos = QPoint();\n        return &amp;m_pos;\n    }\n    int x = m_points.at(0).x();\n    int y = m_points.at(0).y();\n    for (auto point : m_points) {\n        if (point.x() &lt; x) {\n            x = point.x();\n        }\n        if (point.y() &lt; y) {\n            y = point.y();\n        }\n    }\n    m_pos.setX(x);\n    m_pos.setY(y);\n    return &amp;m_pos;\n}\n\n</code></pre>"},{"location":"flameshot/abstractpathtool_8h/","title":"File abstractpathtool.h","text":"<p>FileList &gt; src &gt; tools &gt; abstractpathtool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetool.h\"</code></li> </ul>"},{"location":"flameshot/abstractpathtool_8h/#classes","title":"Classes","text":"Type Name class AbstractPathTool"},{"location":"flameshot/abstractpathtool_8h_source/","title":"File abstractpathtool.h","text":"<p>File List &gt; src &gt; tools &gt; abstractpathtool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"capturetool.h\"\n\nclass AbstractPathTool : public CaptureTool\n{\n    Q_OBJECT\npublic:\n    explicit AbstractPathTool(QObject* parent = nullptr);\n\n    bool isValid() const override;\n    bool closeOnButtonPressed() const override;\n    bool isSelectable() const override;\n    bool showMousePreview() const override;\n    QRect mousePreviewRect(const CaptureContext&amp; context) const override;\n    QRect boundingRect() const override;\n    void move(const QPoint&amp; mousePos) override;\n    const QPoint* pos() override;\n    int size() const override { return m_thickness; };\n\npublic slots:\n    void drawEnd(const QPoint&amp; p) override;\n    void drawMove(const QPoint&amp; p) override;\n    void onColorChanged(const QColor&amp; c) override;\n    void onSizeChanged(int size) override;\n\nprotected:\n    void copyParams(const AbstractPathTool* from, AbstractPathTool* to);\n    void addPoint(const QPoint&amp; point);\n\n    // class members\n    QRect m_pathArea;\n    QColor m_color;\n    QVector&lt;QPoint&gt; m_points;\n    // use m_padding to extend the area of the backup\n    int m_padding;\n    QPoint m_pos;\n\nprivate:\n    int m_thickness;\n};\n\n</code></pre>"},{"location":"flameshot/abstracttwopointtool_8cpp/","title":"File abstracttwopointtool.cpp","text":"<p>FileList &gt; src &gt; tools &gt; abstracttwopointtool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"abstracttwopointtool.h\"</code></li> <li><code>#include &lt;QCursor&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"flameshot/abstracttwopointtool_8cpp_source/","title":"File abstracttwopointtool.cpp","text":"<p>File List &gt; src &gt; tools &gt; abstracttwopointtool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"abstracttwopointtool.h\"\n#include &lt;QCursor&gt;\n#include &lt;QScreen&gt;\n#include &lt;cmath&gt;\n\nnamespace {\n\nconst double ADJ_UNIT = std::atan(1.0);\nconst int DIRS_NUMBER = 4;\n\nenum UNIT\n{\n    HORIZ_DIR = 0,\n    DIAG1_DIR = 1,\n    VERT_DIR = 2\n};\n\nconst double ADJ_DIAG_UNIT = 2 * ADJ_UNIT;\nconst int DIAG_DIRS_NUMBER = 2;\n\nenum DIAG_UNIT\n{\n    DIR1 = 0\n};\n\n}\n\nAbstractTwoPointTool::AbstractTwoPointTool(QObject* parent)\n  : CaptureTool(parent)\n  , m_thickness(1)\n  , m_padding(0)\n{}\n\nvoid AbstractTwoPointTool::copyParams(const AbstractTwoPointTool* from,\n                                      AbstractTwoPointTool* to)\n{\n    CaptureTool::copyParams(from, to);\n    to-&gt;m_points.first = from-&gt;m_points.first;\n    to-&gt;m_points.second = from-&gt;m_points.second;\n    to-&gt;m_color = from-&gt;m_color;\n    to-&gt;m_thickness = from-&gt;m_thickness;\n    to-&gt;m_padding = from-&gt;m_padding;\n    to-&gt;m_supportsOrthogonalAdj = from-&gt;m_supportsOrthogonalAdj;\n    to-&gt;m_supportsDiagonalAdj = from-&gt;m_supportsDiagonalAdj;\n}\n\nbool AbstractTwoPointTool::isValid() const\n{\n    return (m_points.first != m_points.second);\n}\n\nbool AbstractTwoPointTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nbool AbstractTwoPointTool::isSelectable() const\n{\n    return true;\n}\n\nbool AbstractTwoPointTool::showMousePreview() const\n{\n    return true;\n}\n\nQRect AbstractTwoPointTool::mousePreviewRect(\n  const CaptureContext&amp; context) const\n{\n    QRect rect(0, 0, context.toolSize + 2, context.toolSize + 2);\n    rect.moveCenter(context.mousePos);\n    return rect;\n}\n\nQRect AbstractTwoPointTool::boundingRect() const\n{\n    if (!isValid()) {\n        return {};\n    }\n    int offset =\n      m_thickness &lt;= 1 ? 1 : static_cast&lt;int&gt;(round(m_thickness * 0.7 + 0.5));\n    QRect rect =\n      QRect(std::min(m_points.first.x(), m_points.second.x()) - offset,\n            std::min(m_points.first.y(), m_points.second.y()) - offset,\n            std::abs(m_points.first.x() - m_points.second.x()) + offset * 2,\n            std::abs(m_points.first.y() - m_points.second.y()) + offset * 2);\n\n    return rect.normalized();\n}\n\nvoid AbstractTwoPointTool::drawEnd(const QPoint&amp; p)\n{\n    Q_UNUSED(p)\n}\n\nvoid AbstractTwoPointTool::drawMove(const QPoint&amp; p)\n{\n    m_points.second = p;\n}\n\nvoid AbstractTwoPointTool::drawMoveWithAdjustment(const QPoint&amp; p)\n{\n    m_points.second = m_points.first + adjustedVector(p - m_points.first);\n}\n\nvoid AbstractTwoPointTool::onColorChanged(const QColor&amp; c)\n{\n    m_color = c;\n}\n\nvoid AbstractTwoPointTool::onSizeChanged(int size)\n{\n    m_thickness = size;\n}\n\nvoid AbstractTwoPointTool::paintMousePreview(QPainter&amp; painter,\n                                             const CaptureContext&amp; context)\n{\n    painter.setPen(QPen(context.color, context.toolSize));\n    painter.drawLine(context.mousePos, context.mousePos);\n}\n\nvoid AbstractTwoPointTool::drawStart(const CaptureContext&amp; context)\n{\n    onColorChanged(context.color);\n    m_points.first = context.mousePos;\n    m_points.second = context.mousePos;\n    onSizeChanged(context.toolSize);\n}\n\nQPoint AbstractTwoPointTool::adjustedVector(QPoint v) const\n{\n    if (m_supportsOrthogonalAdj &amp;&amp; m_supportsDiagonalAdj) {\n        int dir = (static_cast&lt;int&gt;(round(atan2(-v.y(), v.x()) / ADJ_UNIT)) +\n                   DIRS_NUMBER) %\n                  DIRS_NUMBER;\n        if (dir == UNIT::HORIZ_DIR) {\n            v.setY(0);\n        } else if (dir == UNIT::VERT_DIR) {\n            v.setX(0);\n        } else if (dir == UNIT::DIAG1_DIR) {\n            int newX = (v.x() - v.y()) / 2;\n            int newY = -newX;\n            v.setX(newX);\n            v.setY(newY);\n        } else {\n            int newX = (v.x() + v.y()) / 2;\n            int newY = newX;\n            v.setX(newX);\n            v.setY(newY);\n        }\n    } else if (m_supportsDiagonalAdj) {\n        int dir =\n          (static_cast&lt;int&gt;(round((atan2(-v.y(), v.x()) - ADJ_DIAG_UNIT / 2) /\n                                  ADJ_DIAG_UNIT)) +\n           DIAG_DIRS_NUMBER) %\n          DIAG_DIRS_NUMBER;\n        if (dir == DIAG_UNIT::DIR1) {\n            int newX = (v.x() - v.y()) / 2;\n            int newY = -newX;\n            v.setX(newX);\n            v.setY(newY);\n        } else {\n            int newX = (v.x() + v.y()) / 2;\n            int newY = newX;\n            v.setX(newX);\n            v.setY(newY);\n        }\n    }\n    return v;\n}\n\nvoid AbstractTwoPointTool::move(const QPoint&amp; pos)\n{\n    QPoint offset = m_points.second - m_points.first;\n    m_points.first = pos;\n    m_points.second = m_points.first + offset;\n}\n\nconst QPoint* AbstractTwoPointTool::pos()\n{\n    return &amp;m_points.first;\n}\n\n</code></pre>"},{"location":"flameshot/abstracttwopointtool_8h/","title":"File abstracttwopointtool.h","text":"<p>FileList &gt; src &gt; tools &gt; abstracttwopointtool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetool.h\"</code></li> </ul>"},{"location":"flameshot/abstracttwopointtool_8h/#classes","title":"Classes","text":"Type Name class AbstractTwoPointTool"},{"location":"flameshot/abstracttwopointtool_8h_source/","title":"File abstracttwopointtool.h","text":"<p>File List &gt; src &gt; tools &gt; abstracttwopointtool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"capturetool.h\"\n\nclass AbstractTwoPointTool : public CaptureTool\n{\n    Q_OBJECT\npublic:\n    explicit AbstractTwoPointTool(QObject* parent = nullptr);\n\n    bool isValid() const override;\n    bool closeOnButtonPressed() const override;\n    bool isSelectable() const override;\n    bool showMousePreview() const override;\n    QRect mousePreviewRect(const CaptureContext&amp; context) const override;\n    QRect boundingRect() const override;\n    void move(const QPoint&amp; pos) override;\n    const QPoint* pos() override;\n    int size() const override { return m_thickness; };\n    const QColor&amp; color() { return m_color; };\n    const QPair&lt;QPoint, QPoint&gt; points() const { return m_points; };\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\npublic slots:\n    void drawEnd(const QPoint&amp; p) override;\n    void drawMove(const QPoint&amp; p) override;\n    void drawMoveWithAdjustment(const QPoint&amp; p) override;\n    void onColorChanged(const QColor&amp; c) override;\n    void onSizeChanged(int size) override;\n    virtual void drawStart(const CaptureContext&amp; context) override;\n\nprivate:\n    QPoint adjustedVector(QPoint v) const;\n\nprotected:\n    void copyParams(const AbstractTwoPointTool* from, AbstractTwoPointTool* to);\n    void setPadding(int padding) { m_padding = padding; };\n\nprivate:\n    // class members\n    int m_thickness;\n    int m_padding;\n    QColor m_color;\n    QPair&lt;QPoint, QPoint&gt; m_points;\n\nprotected:\n    // use m_padding to extend the area of the backup\n    bool m_supportsOrthogonalAdj = false;\n    bool m_supportsDiagonalAdj = false;\n};\n\n</code></pre>"},{"location":"flameshot/dir_d43dfd7d21bc513213a1e5551bc75fb6/","title":"Dir accept","text":"<p>FileList &gt; accept</p>"},{"location":"flameshot/dir_d43dfd7d21bc513213a1e5551bc75fb6/#files","title":"Files","text":"Type Name file accepttool.cpp file accepttool.h"},{"location":"flameshot/accepttool_8cpp/","title":"File accepttool.cpp","text":"<p>FileList &gt; accept &gt; accepttool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"accepttool.h\"</code></li> <li><code>#include \"src/utils/screenshotsaver.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QStyle&gt;</code></li> </ul>"},{"location":"flameshot/accepttool_8cpp_source/","title":"File accepttool.cpp","text":"<p>File List &gt; accept &gt; accepttool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"accepttool.h\"\n#include \"src/utils/screenshotsaver.h\"\n#include &lt;QApplication&gt;\n#include &lt;QPainter&gt;\n#include &lt;QStyle&gt;\n#if defined(Q_OS_MACOS)\n#include \"src/widgets/capture/capturewidget.h\"\n#include &lt;QWidget&gt;\n#endif\n\nAcceptTool::AcceptTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool AcceptTool::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon AcceptTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"accept.svg\");\n}\n\nQString AcceptTool::name() const\n{\n    return tr(\"Accept\");\n}\n\nCaptureTool::Type AcceptTool::type() const\n{\n    return CaptureTool::TYPE_ACCEPT;\n}\n\nQString AcceptTool::description() const\n{\n    return tr(\"Accept the capture\");\n}\n\nCaptureTool* AcceptTool::copy(QObject* parent)\n{\n    return new AcceptTool(parent);\n}\n\nvoid AcceptTool::pressed(CaptureContext&amp; context)\n{\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    if (context.request.tasks() &amp; CaptureRequest::PIN) {\n        QRect geometry = context.selection;\n        geometry.moveTopLeft(geometry.topLeft() + context.widgetOffset);\n        context.request.addTask(CaptureRequest::PIN);\n    }\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/accepttool_8h/","title":"File accepttool.h","text":"<p>FileList &gt; accept &gt; accepttool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/accepttool_8h/#classes","title":"Classes","text":"Type Name class AcceptTool"},{"location":"flameshot/accepttool_8h_source/","title":"File accepttool.h","text":"<p>File List &gt; accept &gt; accepttool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"abstractactiontool.h\"\n\nclass AcceptTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit AcceptTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_3269000d382afc6cc2ac04d1522956b4/","title":"Dir arrow","text":"<p>FileList &gt; arrow</p>"},{"location":"flameshot/dir_3269000d382afc6cc2ac04d1522956b4/#files","title":"Files","text":"Type Name file arrowtool.cpp file arrowtool.h"},{"location":"flameshot/arrowtool_8cpp/","title":"File arrowtool.cpp","text":"<p>FileList &gt; arrow &gt; arrowtool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"arrowtool.h\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"flameshot/arrowtool_8cpp_source/","title":"File arrowtool.cpp","text":"<p>File List &gt; arrow &gt; arrowtool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"arrowtool.h\"\n#include &lt;cmath&gt;\n\nnamespace {\nconst int ArrowWidth = 10;\nconst int ArrowHeight = 18;\n\nQPainterPath getArrowHead(QPoint p1, QPoint p2, const int thickness)\n{\n    QLineF base(p1, p2);\n    // Create the vector for the position of the base  of the arrowhead\n    QLineF temp(QPoint(0, 0), p2 - p1);\n    int val = ArrowHeight + thickness * 4;\n    if (base.length() &lt; (val - thickness * 2)) {\n        val = static_cast&lt;int&gt;(base.length() + thickness * 2);\n    }\n    temp.setLength(base.length() + thickness * 2 - val);\n    // Move across the line up to the head\n    QPointF bottomTranslation(temp.p2());\n\n    // Rotate base of the arrowhead\n    base.setLength(ArrowWidth + thickness * 2);\n    base.setAngle(base.angle() + 90);\n    // Move to the correct point\n    QPointF temp2 = p1 - base.p2();\n    // Center it\n    QPointF centerTranslation((temp2.x() / 2), (temp2.y() / 2));\n\n    base.translate(bottomTranslation);\n    base.translate(centerTranslation);\n\n    QPainterPath path;\n    path.moveTo(p2);\n    path.lineTo(base.p1());\n    path.lineTo(base.p2());\n    path.lineTo(p2);\n    return path;\n}\n\n// gets a shorter line to prevent overlap in the point of the arrow\nQLine getShorterLine(QPoint p1, QPoint p2, const int thickness)\n{\n    QLineF l(p1, p2);\n    int val = ArrowHeight + thickness * 4;\n    if (l.length() &lt; (val - thickness * 2)) {\n        // here should be 0, but then we lose \"angle\", so this is hack, but\n        // looks not very bad\n        val = thickness / 4;\n        l.setLength(val);\n    } else {\n        l.setLength(l.length() + thickness * 2 - val);\n    }\n    return l.toLine();\n}\n\n} // unnamed namespace\n\nArrowTool::ArrowTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{\n    setPadding(ArrowWidth / 2);\n    m_supportsOrthogonalAdj = true;\n    m_supportsDiagonalAdj = true;\n}\n\nQIcon ArrowTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"arrow-bottom-left.svg\");\n}\nQString ArrowTool::name() const\n{\n    return tr(\"Arrow\");\n}\n\nCaptureTool::Type ArrowTool::type() const\n{\n    return CaptureTool::TYPE_ARROW;\n}\n\nQString ArrowTool::description() const\n{\n    return tr(\"Set the Arrow as the paint tool\");\n}\n\nQRect ArrowTool::boundingRect() const\n{\n    if (!isValid()) {\n        return {};\n    }\n\n    int offset = size() &lt;= 1 ? 1 : static_cast&lt;int&gt;(round(size() / 2 + 0.5));\n\n    // get min and max arrow pos\n    int min_x = points().first.x();\n    int min_y = points().first.y();\n    int max_x = points().first.x();\n    int max_y = points().first.y();\n    for (int i = 0; i &lt; m_arrowPath.elementCount(); i++) {\n        QPointF pt = m_arrowPath.elementAt(i);\n        if (static_cast&lt;int&gt;(pt.x()) &lt; min_x) {\n            min_x = static_cast&lt;int&gt;(pt.x());\n        }\n        if (static_cast&lt;int&gt;(pt.y()) &lt; min_y) {\n            min_y = static_cast&lt;int&gt;(pt.y());\n        }\n        if (static_cast&lt;int&gt;(pt.x()) &gt; max_x) {\n            max_x = static_cast&lt;int&gt;(pt.x());\n        }\n        if (static_cast&lt;int&gt;(pt.y()) &gt; max_y) {\n            max_y = static_cast&lt;int&gt;(pt.y());\n        }\n    }\n\n    // get min and max line pos\n    int line_pos_min_x =\n      std::min(std::min(points().first.x(), points().second.x()), min_x);\n    int line_pos_min_y =\n      std::min(std::min(points().first.y(), points().second.y()), min_y);\n    int line_pos_max_x =\n      std::max(std::max(points().first.x(), points().second.x()), max_x);\n    int line_pos_max_y =\n      std::max(std::max(points().first.y(), points().second.y()), max_y);\n\n    QRect rect = QRect(line_pos_min_x - offset,\n                       line_pos_min_y - offset,\n                       line_pos_max_x - line_pos_min_x + offset * 2,\n                       line_pos_max_y - line_pos_min_y + offset * 2);\n\n    return rect.normalized();\n}\n\nCaptureTool* ArrowTool::copy(QObject* parent)\n{\n    auto* tool = new ArrowTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid ArrowTool::copyParams(const ArrowTool* from, ArrowTool* to)\n{\n    AbstractTwoPointTool::copyParams(from, to);\n    to-&gt;m_arrowPath = this-&gt;m_arrowPath;\n}\n\nvoid ArrowTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.setPen(QPen(color(), size()));\n    painter.drawLine(getShorterLine(points().first, points().second, size()));\n    m_arrowPath = getArrowHead(points().first, points().second, size());\n    painter.fillPath(m_arrowPath, QBrush(color()));\n}\n\nvoid ArrowTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/arrowtool_8h/","title":"File arrowtool.h","text":"<p>FileList &gt; arrow &gt; arrowtool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPainterPath&gt;</code></li> </ul>"},{"location":"flameshot/arrowtool_8h/#classes","title":"Classes","text":"Type Name class ArrowTool"},{"location":"flameshot/arrowtool_8h_source/","title":"File arrowtool.h","text":"<p>File List &gt; arrow &gt; arrowtool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n#include &lt;QPainter&gt;\n#include &lt;QPainterPath&gt;\n\nclass ArrowTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit ArrowTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n    QRect boundingRect() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n\nprotected:\n    void copyParams(const ArrowTool* from, ArrowTool* to);\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n\nprivate:\n    QPainterPath m_arrowPath;\n};\n\n</code></pre>"},{"location":"flameshot/capturecontext_8cpp/","title":"File capturecontext.cpp","text":"<p>FileList &gt; src &gt; tools &gt; capturecontext.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturecontext.h\"</code></li> <li><code>#include \"capturerequest.h\"</code></li> <li><code>#include \"flameshot.h\"</code></li> </ul>"},{"location":"flameshot/capturecontext_8cpp_source/","title":"File capturecontext.cpp","text":"<p>File List &gt; src &gt; tools &gt; capturecontext.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"capturecontext.h\"\n#include \"capturerequest.h\"\n#include \"flameshot.h\"\n\n// TODO rename\nQPixmap CaptureContext::selectedScreenshotArea() const\n{\n    if (selection.isNull()) {\n        return screenshot;\n    } else {\n        return screenshot.copy(selection);\n    }\n}\n\n</code></pre>"},{"location":"flameshot/capturecontext_8h/","title":"File capturecontext.h","text":"<p>FileList &gt; src &gt; tools &gt; capturecontext.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturerequest.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QRect&gt;</code></li> </ul>"},{"location":"flameshot/capturecontext_8h/#classes","title":"Classes","text":"Type Name struct CaptureContext"},{"location":"flameshot/capturecontext_8h_source/","title":"File capturecontext.h","text":"<p>File List &gt; src &gt; tools &gt; capturecontext.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"capturerequest.h\"\n#include &lt;QPainter&gt;\n#include &lt;QPixmap&gt;\n#include &lt;QPoint&gt;\n#include &lt;QRect&gt;\n\nstruct CaptureContext\n{\n    // screenshot with modifications\n    QPixmap screenshot;\n    // unmodified screenshot\n    QPixmap origScreenshot;\n    // Selection area\n    QRect selection;\n    // Selected tool color\n    QColor color;\n    // Path where the content has to be saved\n    QString savePath;\n    // Offset of the capture widget based on the system's screen (top-left)\n    QPoint widgetOffset;\n    // Mouse position inside the widget\n    QPoint mousePos;\n    // Size of the active tool\n    int toolSize;\n    // Current circle count\n    int circleCount;\n    // Mode of the capture widget\n    bool fullscreen;\n    CaptureRequest request = CaptureRequest::GRAPHICAL_MODE;\n\n    QPixmap selectedScreenshotArea() const;\n};\n\n</code></pre>"},{"location":"flameshot/dir_98f2a39c4a3830cd05b8a97635f25cec/","title":"Dir circle","text":"<p>FileList &gt; circle</p>"},{"location":"flameshot/dir_98f2a39c4a3830cd05b8a97635f25cec/#files","title":"Files","text":"Type Name file circletool.cpp file circletool.h"},{"location":"flameshot/circletool_8cpp/","title":"File circletool.cpp","text":"<p>FileList &gt; circle &gt; circletool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"circletool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/circletool_8cpp_source/","title":"File circletool.cpp","text":"<p>File List &gt; circle &gt; circletool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"circletool.h\"\n#include &lt;QPainter&gt;\n\nCircleTool::CircleTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{\n    m_supportsDiagonalAdj = true;\n}\n\nQIcon CircleTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"circle-outline.svg\");\n}\nQString CircleTool::name() const\n{\n    return tr(\"Circle\");\n}\n\nCaptureTool::Type CircleTool::type() const\n{\n    return CaptureTool::TYPE_CIRCLE;\n}\n\nQString CircleTool::description() const\n{\n    return tr(\"Set the Circle as the paint tool\");\n}\n\nCaptureTool* CircleTool::copy(QObject* parent)\n{\n    auto* tool = new CircleTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid CircleTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.setPen(QPen(color(), size()));\n    painter.drawEllipse(QRect(points().first, points().second));\n}\n\nvoid CircleTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/circletool_8h/","title":"File circletool.h","text":"<p>FileList &gt; circle &gt; circletool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/circletool_8h/#classes","title":"Classes","text":"Type Name class CircleTool"},{"location":"flameshot/circletool_8h_source/","title":"File circletool.h","text":"<p>File List &gt; circle &gt; circletool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass CircleTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit CircleTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_c88b4d2ebcdc55a35960885b013042e2/","title":"Dir circlecount","text":"<p>FileList &gt; circlecount</p>"},{"location":"flameshot/dir_c88b4d2ebcdc55a35960885b013042e2/#files","title":"Files","text":"Type Name file circlecounttool.cpp file circlecounttool.h"},{"location":"flameshot/circlecounttool_8cpp/","title":"File circlecounttool.cpp","text":"<p>FileList &gt; circlecount &gt; circlecounttool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"circlecounttool.h\"</code></li> <li><code>#include \"colorutils.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPainterPath&gt;</code></li> </ul>"},{"location":"flameshot/circlecounttool_8cpp/#macros","title":"Macros","text":"Type Name define PADDING_VALUE  2 define THICKNESS_OFFSET  15"},{"location":"flameshot/circlecounttool_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/circlecounttool_8cpp/#define-padding_value","title":"define PADDING_VALUE","text":"<pre><code>#define PADDING_VALUE 2\n</code></pre>"},{"location":"flameshot/circlecounttool_8cpp/#define-thickness_offset","title":"define THICKNESS_OFFSET","text":"<pre><code>#define THICKNESS_OFFSET 15\n</code></pre>"},{"location":"flameshot/circlecounttool_8cpp_source/","title":"File circlecounttool.cpp","text":"<p>File List &gt; circlecount &gt; circlecounttool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"circlecounttool.h\"\n#include \"colorutils.h\"\n#include &lt;QPainter&gt;\n#include &lt;QPainterPath&gt;\n\nnamespace {\n#define PADDING_VALUE 2\n#define THICKNESS_OFFSET 15\n}\n\nCircleCountTool::CircleCountTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n  , m_valid(false)\n{}\n\nQIcon CircleCountTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"circlecount-outline.svg\");\n}\n\nQString CircleCountTool::info()\n{\n    m_tempString = QString(\"%1 - %2\").arg(name()).arg(count());\n    return m_tempString;\n}\n\nbool CircleCountTool::isValid() const\n{\n    return m_valid;\n}\n\nQRect CircleCountTool::mousePreviewRect(const CaptureContext&amp; context) const\n{\n    int width = (context.toolSize + THICKNESS_OFFSET) * 2;\n    QRect rect(0, 0, width, width);\n    rect.moveCenter(context.mousePos);\n    return rect;\n}\n\nQRect CircleCountTool::boundingRect() const\n{\n    if (!isValid()) {\n        return {};\n    }\n    int bubble_size = size() + THICKNESS_OFFSET + PADDING_VALUE;\n\n    int line_pos_min_x =\n      std::min(points().first.x() - bubble_size, points().second.x());\n    int line_pos_min_y =\n      std::min(points().first.y() - bubble_size, points().second.y());\n    int line_pos_max_x =\n      std::max(points().first.x() + bubble_size, points().second.x());\n    int line_pos_max_y =\n      std::max(points().first.y() + bubble_size, points().second.y());\n\n    return { line_pos_min_x,\n             line_pos_min_y,\n             line_pos_max_x - line_pos_min_x,\n             line_pos_max_y - line_pos_min_y };\n}\n\nQString CircleCountTool::name() const\n{\n    return tr(\"Circle Counter\");\n}\n\nCaptureTool::Type CircleCountTool::type() const\n{\n    return CaptureTool::TYPE_CIRCLECOUNT;\n}\n\nvoid CircleCountTool::copyParams(const CircleCountTool* from,\n                                 CircleCountTool* to)\n{\n    AbstractTwoPointTool::copyParams(from, to);\n    to-&gt;setCount(from-&gt;count());\n    to-&gt;m_valid = from-&gt;m_valid;\n}\n\nQString CircleCountTool::description() const\n{\n    return tr(\"Add an autoincrementing counter bubble\");\n}\n\nCaptureTool* CircleCountTool::copy(QObject* parent)\n{\n    auto* tool = new CircleCountTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid CircleCountTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    // save current pen, brush, and font state\n    auto orig_pen = painter.pen();\n    auto orig_brush = painter.brush();\n    auto orig_font = painter.font();\n\n    QColor contrastColor =\n      ColorUtils::colorIsDark(color()) ? Qt::white : Qt::black;\n    QColor antiContrastColor =\n      ColorUtils::colorIsDark(color()) ? Qt::black : Qt::white;\n\n    int bubble_size = size() + THICKNESS_OFFSET;\n\n    QLineF line(points().first, points().second);\n    // if the mouse is outside of the bubble, draw the pointer\n    if (line.length() &gt; bubble_size) {\n        painter.setPen(QPen(color(), 0));\n        painter.setBrush(color());\n\n        int middleX = points().first.x();\n        int middleY = points().first.y();\n\n        QLineF normal = line.normalVector();\n        normal.setLength(bubble_size);\n        QPoint p1 = normal.p2().toPoint();\n        QPoint p2(middleX - (p1.x() - middleX), middleY - (p1.y() - middleY));\n\n        QPainterPath path;\n        path.moveTo(points().first);\n        path.lineTo(p1);\n        path.lineTo(points().second);\n        path.lineTo(p2);\n        path.lineTo(points().first);\n        painter.drawPath(path);\n    }\n\n    painter.setPen(contrastColor);\n    painter.setBrush(antiContrastColor);\n    painter.drawEllipse(\n      points().first, bubble_size + PADDING_VALUE, bubble_size + PADDING_VALUE);\n    painter.setBrush(color());\n    painter.drawEllipse(points().first, bubble_size, bubble_size);\n    QRect textRect = QRect(points().first.x() - bubble_size / 2,\n                           points().first.y() - bubble_size / 2,\n                           bubble_size,\n                           bubble_size);\n    auto new_font = orig_font;\n    auto fontSize = bubble_size;\n    new_font.setPixelSize(fontSize);\n    new_font.setBold(true);\n    painter.setFont(new_font);\n\n    // Draw bounding circle\n    QRect bRect =\n      painter.boundingRect(textRect, Qt::AlignCenter, QString::number(count()));\n\n    // Calculate font size\n    while (bRect.width() &gt; textRect.width()) {\n        fontSize--;\n        if (fontSize == 0) {\n            break;\n        }\n        new_font.setPixelSize(fontSize);\n        painter.setFont(new_font);\n        bRect = painter.boundingRect(\n          textRect, Qt::AlignCenter, QString::number(count()));\n    }\n\n    // Draw text\n    painter.setPen(contrastColor);\n    painter.drawText(textRect, Qt::AlignCenter, QString::number(count()));\n    // restore original font, brush, and pen\n    painter.setFont(orig_font);\n    painter.setBrush(orig_brush);\n    painter.setPen(orig_pen);\n}\n\nvoid CircleCountTool::paintMousePreview(QPainter&amp; painter,\n                                        const CaptureContext&amp; context)\n{\n    onSizeChanged(context.toolSize + PADDING_VALUE);\n\n    // Thickness for pen is *2 to range from radius to diameter to match the\n    // ellipse draw function\n    auto orig_pen = painter.pen();\n    auto orig_opacity = painter.opacity();\n    painter.setOpacity(0.35);\n    painter.setPen(QPen(context.color,\n                        (size() + THICKNESS_OFFSET) * 2,\n                        Qt::SolidLine,\n                        Qt::RoundCap));\n    painter.drawLine(context.mousePos,\n                     { context.mousePos.x() + 1, context.mousePos.y() + 1 });\n    painter.setOpacity(orig_opacity);\n    painter.setPen(orig_pen);\n}\n\nvoid CircleCountTool::drawStart(const CaptureContext&amp; context)\n{\n    AbstractTwoPointTool::drawStart(context);\n    m_valid = true;\n}\n\nvoid CircleCountTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/circlecounttool_8h/","title":"File circlecounttool.h","text":"<p>FileList &gt; circlecount &gt; circlecounttool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/circlecounttool_8h/#classes","title":"Classes","text":"Type Name class CircleCountTool"},{"location":"flameshot/circlecounttool_8h_source/","title":"File circlecounttool.h","text":"<p>File List &gt; circlecount &gt; circlecounttool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass CircleCountTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit CircleCountTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n    QString info() override;\n    bool isValid() const override;\n\n    QRect mousePreviewRect(const CaptureContext&amp; context) const override;\n    QRect boundingRect() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n    void copyParams(const CircleCountTool* from, CircleCountTool* to);\n\npublic slots:\n    void drawStart(const CaptureContext&amp; context) override;\n    void pressed(CaptureContext&amp; context) override;\n\nprivate:\n    QString m_tempString;\n    bool m_valid;\n};\n\n</code></pre>"},{"location":"flameshot/dir_ed36feeccfea7f6658339eb729ac3194/","title":"Dir copy","text":"<p>FileList &gt; copy</p>"},{"location":"flameshot/dir_ed36feeccfea7f6658339eb729ac3194/#files","title":"Files","text":"Type Name file copytool.cpp file copytool.h"},{"location":"flameshot/copytool_8cpp/","title":"File copytool.cpp","text":"<p>FileList &gt; copy &gt; copytool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"copytool.h\"</code></li> <li><code>#include \"src/utils/screenshotsaver.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/copytool_8cpp_source/","title":"File copytool.cpp","text":"<p>File List &gt; copy &gt; copytool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"copytool.h\"\n#include \"src/utils/screenshotsaver.h\"\n#include &lt;QPainter&gt;\n\nCopyTool::CopyTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool CopyTool::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon CopyTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"content-copy.svg\");\n}\nQString CopyTool::name() const\n{\n    return tr(\"Copy\");\n}\n\nCaptureTool::Type CopyTool::type() const\n{\n    return CaptureTool::TYPE_COPY;\n}\n\nQString CopyTool::description() const\n{\n    return tr(\"Copy selection to clipboard\");\n}\n\nCaptureTool* CopyTool::copy(QObject* parent)\n{\n    return new CopyTool(parent);\n}\n\nvoid CopyTool::pressed(CaptureContext&amp; context)\n{\n    emit requestAction(REQ_CLEAR_SELECTION);\n    context.request.addTask(CaptureRequest::COPY);\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/copytool_8h/","title":"File copytool.h","text":"<p>FileList &gt; copy &gt; copytool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/copytool_8h/#classes","title":"Classes","text":"Type Name class CopyTool"},{"location":"flameshot/copytool_8h_source/","title":"File copytool.h","text":"<p>File List &gt; copy &gt; copytool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass CopyTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit CopyTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_6080df60932419c2e0eb96a6bf9cd630/","title":"Dir exit","text":"<p>FileList &gt; exit</p>"},{"location":"flameshot/dir_6080df60932419c2e0eb96a6bf9cd630/#files","title":"Files","text":"Type Name file exittool.cpp file exittool.h"},{"location":"flameshot/exittool_8cpp/","title":"File exittool.cpp","text":"<p>FileList &gt; exit &gt; exittool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"exittool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/exittool_8cpp_source/","title":"File exittool.cpp","text":"<p>File List &gt; exit &gt; exittool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"exittool.h\"\n#include &lt;QPainter&gt;\n\nExitTool::ExitTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool ExitTool::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon ExitTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"close.svg\");\n}\nQString ExitTool::name() const\n{\n    return tr(\"Exit\");\n}\n\nCaptureTool::Type ExitTool::type() const\n{\n    return CaptureTool::TYPE_EXIT;\n}\n\nQString ExitTool::description() const\n{\n    return tr(\"Leave the capture screen\");\n}\n\nCaptureTool* ExitTool::copy(QObject* parent)\n{\n    return new ExitTool(parent);\n}\n\nvoid ExitTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/exittool_8h/","title":"File exittool.h","text":"<p>FileList &gt; exit &gt; exittool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/exittool_8h/#classes","title":"Classes","text":"Type Name class ExitTool"},{"location":"flameshot/exittool_8h_source/","title":"File exittool.h","text":"<p>File List &gt; exit &gt; exittool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass ExitTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit ExitTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n    // TODO create a new abstract class to get rid of such baggage\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/","title":"Dir imgupload","text":"<p>FileList &gt; imgupload</p>"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/#files","title":"Files","text":"Type Name file imguploadermanager.cpp file imguploadermanager.h file imguploadertool.cpp file imguploadertool.h"},{"location":"flameshot/dir_a67c722cf9bd9ce1079f0970c2db7c7c/#directories","title":"Directories","text":"Type Name dir storages"},{"location":"flameshot/imguploadermanager_8cpp/","title":"File imguploadermanager.cpp","text":"<p>FileList &gt; imgupload &gt; imguploadermanager.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"imguploadermanager.h\"</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> <li><code>#include \"storages/imgur/imguruploader.h\"</code></li> </ul>"},{"location":"flameshot/imguploadermanager_8cpp_source/","title":"File imguploadermanager.cpp","text":"<p>File List &gt; imgupload &gt; imguploadermanager.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: Yurii Puchkov &amp; Contributors\n//\n\n#include \"imguploadermanager.h\"\n#include &lt;QPixmap&gt;\n#include &lt;QWidget&gt;\n\n// TODO - remove this hard-code and create plugin manager in the future, you may\n// include other storage headers here\n#include \"storages/imgur/imguruploader.h\"\n\nImgUploaderManager::ImgUploaderManager(QObject* parent)\n  : QObject(parent)\n  , m_imgUploaderBase(nullptr)\n{\n    // TODO - implement ImgUploader for other Storages and selection among them\n    m_imgUploaderPlugin = IMG_UPLOADER_STORAGE_DEFAULT;\n    init();\n}\n\nvoid ImgUploaderManager::init()\n{\n    // TODO - implement ImgUploader for other Storages and selection among them,\n    // example:\n    // if (uploaderPlugin().compare(\"s3\") == 0) {\n    //    m_qstrUrl = ImgS3Settings().value(\"S3\", \"S3_URL\").toString();\n    //} else {\n    //    m_qstrUrl = \"https://imgur.com/\";\n    //    m_imgUploaderPlugin = \"imgur\";\n    //}\n    m_urlString = \"https://imgur.com/\";\n    m_imgUploaderPlugin = \"imgur\";\n}\n\nImgUploaderBase* ImgUploaderManager::uploader(const QPixmap&amp; capture,\n                                              QWidget* parent)\n{\n    // TODO - implement ImgUploader for other Storages and selection among them,\n    // example:\n    // if (uploaderPlugin().compare(\"s3\") == 0) {\n    //    m_imgUploaderBase =\n    //      (ImgUploaderBase*)(new ImgS3Uploader(capture, parent));\n    //} else {\n    //    m_imgUploaderBase =\n    //      (ImgUploaderBase*)(new ImgurUploader(capture, parent));\n    //}\n    m_imgUploaderBase = (ImgUploaderBase*)(new ImgurUploader(capture, parent));\n    if (m_imgUploaderBase &amp;&amp; !capture.isNull()) {\n        m_imgUploaderBase-&gt;upload();\n    }\n    return m_imgUploaderBase;\n}\n\nImgUploaderBase* ImgUploaderManager::uploader(const QString&amp; imgUploaderPlugin)\n{\n    m_imgUploaderPlugin = imgUploaderPlugin;\n    init();\n    return uploader(QPixmap());\n}\n\nconst QString&amp; ImgUploaderManager::uploaderPlugin()\n{\n    return m_imgUploaderPlugin;\n}\n\nconst QString&amp; ImgUploaderManager::url()\n{\n    return m_urlString;\n}\n\n</code></pre>"},{"location":"flameshot/imguploadermanager_8h/","title":"File imguploadermanager.h","text":"<p>FileList &gt; imgupload &gt; imguploadermanager.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/imgupload/storages/imguploaderbase.h\"</code></li> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/imguploadermanager_8h/#classes","title":"Classes","text":"Type Name class ImgUploaderManager"},{"location":"flameshot/imguploadermanager_8h/#macros","title":"Macros","text":"Type Name define IMG_UPLOADER_STORAGE_DEFAULT  \"imgur\""},{"location":"flameshot/imguploadermanager_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/imguploadermanager_8h/#define-img_uploader_storage_default","title":"define IMG_UPLOADER_STORAGE_DEFAULT","text":"<pre><code>#define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\"\n</code></pre>"},{"location":"flameshot/imguploadermanager_8h_source/","title":"File imguploadermanager.h","text":"<p>File List &gt; imgupload &gt; imguploadermanager.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: Yurii Puchkov &amp; Contributors\n//\n\n#ifndef FLAMESHOT_IMGUPLOADERMANAGER_H\n#define FLAMESHOT_IMGUPLOADERMANAGER_H\n\n#include \"src/tools/imgupload/storages/imguploaderbase.h\"\n#include &lt;QObject&gt;\n\n#define IMG_UPLOADER_STORAGE_DEFAULT \"imgur\"\n\nclass QPixmap;\nclass QWidget;\n\nclass ImgUploaderManager : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit ImgUploaderManager(QObject* parent = nullptr);\n\n    ImgUploaderBase* uploader(const QPixmap&amp; capture,\n                              QWidget* parent = nullptr);\n    ImgUploaderBase* uploader(const QString&amp; imgUploaderPlugin);\n\n    const QString&amp; url();\n    const QString&amp; uploaderPlugin();\n\nprivate:\n    void init();\n\nprivate:\n    ImgUploaderBase* m_imgUploaderBase;\n    QString m_urlString;\n    QString m_imgUploaderPlugin;\n};\n\n#endif // FLAMESHOT_IMGUPLOADERMANAGER_H\n\n</code></pre>"},{"location":"flameshot/imguploadertool_8cpp/","title":"File imguploadertool.cpp","text":"<p>FileList &gt; imgupload &gt; imguploadertool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"imguploadertool.h\"</code></li> </ul>"},{"location":"flameshot/imguploadertool_8cpp_source/","title":"File imguploadertool.cpp","text":"<p>File List &gt; imgupload &gt; imguploadertool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"imguploadertool.h\"\n\nImgUploaderTool::ImgUploaderTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool ImgUploaderTool::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon ImgUploaderTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor);\n    return QIcon(iconPath(background) + \"cloud-upload.svg\");\n}\n\nQString ImgUploaderTool::name() const\n{\n    return tr(\"Image Uploader\");\n}\n\nCaptureTool::Type ImgUploaderTool::type() const\n{\n    return CaptureTool::TYPE_IMAGEUPLOADER;\n}\n\nQString ImgUploaderTool::description() const\n{\n    return tr(\"Upload the selection\");\n}\n\nCaptureTool* ImgUploaderTool::copy(QObject* parent)\n{\n    return new ImgUploaderTool(parent);\n}\n\nvoid ImgUploaderTool::pressed(CaptureContext&amp; context)\n{\n    emit requestAction(REQ_CLEAR_SELECTION);\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    context.request.addTask(CaptureRequest::UPLOAD);\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/imguploadertool_8h/","title":"File imguploadertool.h","text":"<p>FileList &gt; imgupload &gt; imguploadertool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/imguploadertool_8h/#classes","title":"Classes","text":"Type Name class ImgUploaderTool"},{"location":"flameshot/imguploadertool_8h_source/","title":"File imguploadertool.h","text":"<p>File List &gt; imgupload &gt; imguploadertool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass ImgUploaderTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit ImgUploaderTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n\nprivate:\n    QPixmap capture;\n};\n\n</code></pre>"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/","title":"Dir storages","text":"<p>FileList &gt; imgupload &gt; storages</p>"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/#files","title":"Files","text":"Type Name file imguploaderbase.cpp file imguploaderbase.h"},{"location":"flameshot/dir_de2e3ad2c3ca1eb0feb1f0bfa3a80f3a/#directories","title":"Directories","text":"Type Name dir imgur"},{"location":"flameshot/imguploaderbase_8cpp/","title":"File imguploaderbase.cpp","text":"<p>FileList &gt; imgupload &gt; storages &gt; imguploaderbase.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"imguploaderbase.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"src/utils/history.h\"</code></li> <li><code>#include \"src/utils/screenshotsaver.h\"</code></li> <li><code>#include \"src/widgets/imagelabel.h\"</code></li> <li><code>#include \"src/widgets/loadspinner.h\"</code></li> <li><code>#include \"src/widgets/notificationwidget.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QClipboard&gt;</code></li> <li><code>#include &lt;QCursor&gt;</code></li> <li><code>#include &lt;QDesktopServices&gt;</code></li> <li><code>#include &lt;QDrag&gt;</code></li> <li><code>#include &lt;QGuiApplication&gt;</code></li> <li><code>#include &lt;QJsonDocument&gt;</code></li> <li><code>#include &lt;QJsonObject&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QMimeData&gt;</code></li> <li><code>#include &lt;QNetworkAccessManager&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QRect&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> <li><code>#include &lt;QShortcut&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QUrlQuery&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/imguploaderbase_8cpp_source/","title":"File imguploaderbase.cpp","text":"<p>File List &gt; imgupload &gt; storages &gt; imguploaderbase.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"imguploaderbase.h\"\n#include \"src/core/flameshotdaemon.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"src/utils/history.h\"\n#include \"src/utils/screenshotsaver.h\"\n#include \"src/widgets/imagelabel.h\"\n#include \"src/widgets/loadspinner.h\"\n#include \"src/widgets/notificationwidget.h\"\n#include &lt;QApplication&gt;\n// FIXME #include &lt;QBuffer&gt;\n#include &lt;QClipboard&gt;\n#include &lt;QCursor&gt;\n#include &lt;QDesktopServices&gt;\n#include &lt;QDrag&gt;\n#include &lt;QGuiApplication&gt;\n#include &lt;QJsonDocument&gt;\n#include &lt;QJsonObject&gt;\n#include &lt;QLabel&gt;\n#include &lt;QMimeData&gt;\n#include &lt;QNetworkAccessManager&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QRect&gt;\n#include &lt;QScreen&gt;\n#include &lt;QShortcut&gt;\n#include &lt;QTimer&gt;\n#include &lt;QUrlQuery&gt;\n#include &lt;QVBoxLayout&gt;\n\nImgUploaderBase::ImgUploaderBase(const QPixmap&amp; capture, QWidget* parent)\n  : QWidget(parent)\n  , m_pixmap(capture)\n{\n    setWindowTitle(tr(\"Upload image\"));\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n\n    QRect position = frameGeometry();\n    QScreen* screen = QGuiApplication::screenAt(QCursor::pos());\n    position.moveCenter(screen-&gt;availableGeometry().center());\n    move(position.topLeft());\n\n    m_spinner = new LoadSpinner(this);\n    m_spinner-&gt;setColor(ConfigHandler().uiColor());\n    m_spinner-&gt;start();\n\n    m_infoLabel = new QLabel(tr(\"Uploading Image\"));\n    m_infoLabel-&gt;setTextInteractionFlags(Qt::TextSelectableByMouse);\n    m_infoLabel-&gt;setCursor(QCursor(Qt::IBeamCursor));\n\n    m_vLayout = new QVBoxLayout();\n    setLayout(m_vLayout);\n    m_vLayout-&gt;addWidget(m_spinner, 0, Qt::AlignHCenter);\n    m_vLayout-&gt;addWidget(m_infoLabel);\n\n    setAttribute(Qt::WA_DeleteOnClose);\n}\n\nLoadSpinner* ImgUploaderBase::spinner()\n{\n    return m_spinner;\n}\n\nconst QUrl&amp; ImgUploaderBase::imageURL()\n{\n    return m_imageURL;\n}\n\nvoid ImgUploaderBase::setImageURL(const QUrl&amp; imageURL)\n{\n    m_imageURL = imageURL;\n}\n\nconst QPixmap&amp; ImgUploaderBase::pixmap()\n{\n    return m_pixmap;\n}\n\nvoid ImgUploaderBase::setPixmap(const QPixmap&amp; pixmap)\n{\n    m_pixmap = pixmap;\n}\n\nNotificationWidget* ImgUploaderBase::notification()\n{\n    return m_notification;\n}\n\nvoid ImgUploaderBase::setInfoLabelText(const QString&amp; text)\n{\n    m_infoLabel-&gt;setText(text);\n}\n\nvoid ImgUploaderBase::startDrag()\n{\n    auto* mimeData = new QMimeData;\n    mimeData-&gt;setUrls(QList&lt;QUrl&gt;{ m_imageURL });\n    mimeData-&gt;setImageData(m_pixmap);\n\n    auto* dragHandler = new QDrag(this);\n    dragHandler-&gt;setMimeData(mimeData);\n    dragHandler-&gt;setPixmap(m_pixmap.scaled(\n      256, 256, Qt::KeepAspectRatioByExpanding, Qt::SmoothTransformation));\n    dragHandler-&gt;exec();\n}\n\nvoid ImgUploaderBase::showPostUploadDialog()\n{\n    m_infoLabel-&gt;deleteLater();\n\n    m_notification = new NotificationWidget();\n    m_vLayout-&gt;addWidget(m_notification);\n\n    auto* imageLabel = new ImageLabel();\n    imageLabel-&gt;setScreenshot(m_pixmap);\n    imageLabel-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);\n    connect(imageLabel,\n            &amp;ImageLabel::dragInitiated,\n            this,\n            &amp;ImgUploaderBase::startDrag);\n    m_vLayout-&gt;addWidget(imageLabel);\n\n    m_hLayout = new QHBoxLayout();\n    m_vLayout-&gt;addLayout(m_hLayout);\n\n    m_copyUrlButton = new QPushButton(tr(\"Copy URL\"));\n    m_openUrlButton = new QPushButton(tr(\"Open URL\"));\n    m_openDeleteUrlButton = new QPushButton(tr(\"Delete image\"));\n    m_toClipboardButton = new QPushButton(tr(\"Image to Clipboard.\"));\n    m_saveToFilesystemButton = new QPushButton(tr(\"Save image\"));\n    m_hLayout-&gt;addWidget(m_copyUrlButton);\n    m_hLayout-&gt;addWidget(m_openUrlButton);\n    m_hLayout-&gt;addWidget(m_openDeleteUrlButton);\n    m_hLayout-&gt;addWidget(m_toClipboardButton);\n    m_hLayout-&gt;addWidget(m_saveToFilesystemButton);\n\n    connect(\n      m_copyUrlButton, &amp;QPushButton::clicked, this, &amp;ImgUploaderBase::copyURL);\n    connect(\n      m_openUrlButton, &amp;QPushButton::clicked, this, &amp;ImgUploaderBase::openURL);\n    connect(m_openDeleteUrlButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;ImgUploaderBase::deleteCurrentImage);\n    connect(m_toClipboardButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;ImgUploaderBase::copyImage);\n\n    QObject::connect(m_saveToFilesystemButton,\n                     &amp;QPushButton::clicked,\n                     this,\n                     &amp;ImgUploaderBase::saveScreenshotToFilesystem);\n}\n\nvoid ImgUploaderBase::openURL()\n{\n    bool successful = QDesktopServices::openUrl(m_imageURL);\n    if (!successful) {\n        m_notification-&gt;showMessage(tr(\"Unable to open the URL.\"));\n    }\n}\n\nvoid ImgUploaderBase::copyURL()\n{\n    FlameshotDaemon::copyToClipboard(m_imageURL.toString());\n    m_notification-&gt;showMessage(tr(\"URL copied to clipboard.\"));\n}\n\nvoid ImgUploaderBase::copyImage()\n{\n    FlameshotDaemon::copyToClipboard(m_pixmap);\n    m_notification-&gt;showMessage(tr(\"Screenshot copied to clipboard.\"));\n}\n\nvoid ImgUploaderBase::deleteCurrentImage()\n{\n    History history;\n    HistoryFileName unpackFileName = history.unpackFileName(m_currentImageName);\n    deleteImage(unpackFileName.file, unpackFileName.token);\n}\n\nvoid ImgUploaderBase::saveScreenshotToFilesystem()\n{\n    if (!saveToFilesystemGUI(m_pixmap)) {\n        m_notification-&gt;showMessage(\n          tr(\"Unable to save the screenshot to disk.\"));\n        return;\n    }\n    m_notification-&gt;showMessage(tr(\"Screenshot saved.\"));\n}\n\n</code></pre>"},{"location":"flameshot/imguploaderbase_8h/","title":"File imguploaderbase.h","text":"<p>FileList &gt; imgupload &gt; storages &gt; imguploaderbase.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/imguploaderbase_8h/#classes","title":"Classes","text":"Type Name class ImgUploaderBase"},{"location":"flameshot/imguploaderbase_8h_source/","title":"File imguploaderbase.h","text":"<p>File List &gt; imgupload &gt; storages &gt; imguploaderbase.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QUrl&gt;\n#include &lt;QWidget&gt;\n\nclass QNetworkReply;\nclass QNetworkAccessManager;\nclass QHBoxLayout;\nclass QVBoxLayout;\nclass QLabel;\nclass LoadSpinner;\nclass QPushButton;\nclass QUrl;\nclass NotificationWidget;\n\nclass ImgUploaderBase : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit ImgUploaderBase(const QPixmap&amp; capture, QWidget* parent = nullptr);\n\n    LoadSpinner* spinner();\n\n    const QUrl&amp; imageURL();\n    void setImageURL(const QUrl&amp;);\n    const QPixmap&amp; pixmap();\n    void setPixmap(const QPixmap&amp;);\n    void setInfoLabelText(const QString&amp;);\n\n    NotificationWidget* notification();\n    virtual void deleteImage(const QString&amp; fileName,\n                             const QString&amp; deleteToken) = 0;\n    virtual void upload() = 0;\n\nsignals:\n    void uploadOk(const QUrl&amp; url);\n    void deleteOk();\n\npublic slots:\n    void showPostUploadDialog();\n\nprivate slots:\n    void startDrag();\n    void openURL();\n    void copyURL();\n    void copyImage();\n    void deleteCurrentImage();\n    void saveScreenshotToFilesystem();\n\nprivate:\n    QPixmap m_pixmap;\n\n    QVBoxLayout* m_vLayout;\n    QHBoxLayout* m_hLayout;\n    // loading\n    QLabel* m_infoLabel;\n    LoadSpinner* m_spinner;\n    // uploaded\n    QPushButton* m_openUrlButton;\n    QPushButton* m_openDeleteUrlButton;\n    QPushButton* m_copyUrlButton;\n    QPushButton* m_toClipboardButton;\n    QPushButton* m_saveToFilesystemButton;\n    QUrl m_imageURL;\n    NotificationWidget* m_notification;\n\npublic:\n    QString m_currentImageName;\n};\n\n</code></pre>"},{"location":"flameshot/dir_9d663866a83f7a9d0218a5da0003e3bb/","title":"Dir imgur","text":"<p>FileList &gt; imgupload &gt; storages &gt; imgur</p>"},{"location":"flameshot/dir_9d663866a83f7a9d0218a5da0003e3bb/#files","title":"Files","text":"Type Name file imguruploader.cpp file imguruploader.h"},{"location":"flameshot/imguruploader_8cpp/","title":"File imguruploader.cpp","text":"<p>FileList &gt; imgupload &gt; storages &gt; imgur &gt; imguruploader.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"imguruploader.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/filenamehandler.h\"</code></li> <li><code>#include \"src/utils/history.h\"</code></li> <li><code>#include \"src/widgets/loadspinner.h\"</code></li> <li><code>#include \"src/widgets/notificationwidget.h\"</code></li> <li><code>#include &lt;QBuffer&gt;</code></li> <li><code>#include &lt;QDesktopServices&gt;</code></li> <li><code>#include &lt;QJsonDocument&gt;</code></li> <li><code>#include &lt;QJsonObject&gt;</code></li> <li><code>#include &lt;QNetworkAccessManager&gt;</code></li> <li><code>#include &lt;QNetworkReply&gt;</code></li> <li><code>#include &lt;QNetworkRequest&gt;</code></li> <li><code>#include &lt;QShortcut&gt;</code></li> <li><code>#include &lt;QUrlQuery&gt;</code></li> </ul>"},{"location":"flameshot/imguruploader_8cpp_source/","title":"File imguruploader.cpp","text":"<p>File List &gt; imgupload &gt; storages &gt; imgur &gt; imguruploader.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"imguruploader.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/filenamehandler.h\"\n#include \"src/utils/history.h\"\n#include \"src/widgets/loadspinner.h\"\n#include \"src/widgets/notificationwidget.h\"\n#include &lt;QBuffer&gt;\n#include &lt;QDesktopServices&gt;\n#include &lt;QJsonDocument&gt;\n#include &lt;QJsonObject&gt;\n#include &lt;QNetworkAccessManager&gt;\n#include &lt;QNetworkReply&gt;\n#include &lt;QNetworkRequest&gt;\n#include &lt;QShortcut&gt;\n#include &lt;QUrlQuery&gt;\n\nImgurUploader::ImgurUploader(const QPixmap&amp; capture, QWidget* parent)\n  : ImgUploaderBase(capture, parent)\n{\n    m_NetworkAM = new QNetworkAccessManager(this);\n    connect(m_NetworkAM,\n            &amp;QNetworkAccessManager::finished,\n            this,\n            &amp;ImgurUploader::handleReply);\n}\n\nvoid ImgurUploader::handleReply(QNetworkReply* reply)\n{\n    spinner()-&gt;deleteLater();\n    m_currentImageName.clear();\n    if (reply-&gt;error() == QNetworkReply::NoError) {\n        QJsonDocument response = QJsonDocument::fromJson(reply-&gt;readAll());\n        QJsonObject json = response.object();\n        QJsonObject data = json[QStringLiteral(\"data\")].toObject();\n        setImageURL(data[QStringLiteral(\"link\")].toString());\n\n        auto deleteToken = data[QStringLiteral(\"deletehash\")].toString();\n\n        // save history\n        m_currentImageName = imageURL().toString();\n        int lastSlash = m_currentImageName.lastIndexOf(\"/\");\n        if (lastSlash &gt;= 0) {\n            m_currentImageName = m_currentImageName.mid(lastSlash + 1);\n        }\n\n        // save image to history\n        History history;\n        m_currentImageName =\n          history.packFileName(\"imgur\", deleteToken, m_currentImageName);\n        history.save(pixmap(), m_currentImageName);\n\n        emit uploadOk(imageURL());\n    } else {\n        setInfoLabelText(reply-&gt;errorString());\n    }\n    new QShortcut(Qt::Key_Escape, this, SLOT(close()));\n}\n\nvoid ImgurUploader::upload()\n{\n    QByteArray byteArray;\n    QBuffer buffer(&amp;byteArray);\n    pixmap().save(&amp;buffer, \"PNG\");\n\n    QUrlQuery urlQuery;\n    urlQuery.addQueryItem(QStringLiteral(\"title\"), QStringLiteral(\"\"));\n    QString description = FileNameHandler().parsedPattern();\n    urlQuery.addQueryItem(QStringLiteral(\"description\"), description);\n\n    QUrl url(QStringLiteral(\"https://api.imgur.com/3/image\"));\n    url.setQuery(urlQuery);\n    QNetworkRequest request(url);\n    request.setHeader(QNetworkRequest::ContentTypeHeader,\n                      \"application/application/x-www-form-urlencoded\");\n    request.setRawHeader(\"Authorization\",\n                         QStringLiteral(\"Client-ID %1\")\n                           .arg(ConfigHandler().uploadClientSecret())\n                           .toUtf8());\n\n    m_NetworkAM-&gt;post(request, byteArray);\n}\n\nvoid ImgurUploader::deleteImage(const QString&amp; fileName,\n                                const QString&amp; deleteToken)\n{\n    Q_UNUSED(fileName)\n    bool successful = QDesktopServices::openUrl(\n      QUrl(QStringLiteral(\"https://imgur.com/delete/%1\").arg(deleteToken)));\n    if (!successful) {\n        notification()-&gt;showMessage(tr(\"Unable to open the URL.\"));\n    }\n\n    emit deleteOk();\n}\n\n</code></pre>"},{"location":"flameshot/imguruploader_8h/","title":"File imguruploader.h","text":"<p>FileList &gt; imgupload &gt; storages &gt; imgur &gt; imguruploader.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/imgupload/storages/imguploaderbase.h\"</code></li> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/imguruploader_8h/#classes","title":"Classes","text":"Type Name class ImgurUploader"},{"location":"flameshot/imguruploader_8h_source/","title":"File imguruploader.h","text":"<p>File List &gt; imgupload &gt; storages &gt; imgur &gt; imguruploader.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/imgupload/storages/imguploaderbase.h\"\n#include &lt;QUrl&gt;\n#include &lt;QWidget&gt;\n\nclass QNetworkReply;\nclass QNetworkAccessManager;\nclass QUrl;\n\nclass ImgurUploader : public ImgUploaderBase\n{\n    Q_OBJECT\npublic:\n    explicit ImgurUploader(const QPixmap&amp; capture, QWidget* parent = nullptr);\n    void deleteImage(const QString&amp; fileName, const QString&amp; deleteToken);\n\nprivate slots:\n    void handleReply(QNetworkReply* reply);\n\nprivate:\n    void upload();\n\nprivate:\n    QNetworkAccessManager* m_NetworkAM;\n};\n\n</code></pre>"},{"location":"flameshot/dir_3786b04329c06854f20683676e14a832/","title":"Dir invert","text":"<p>FileList &gt; invert</p>"},{"location":"flameshot/dir_3786b04329c06854f20683676e14a832/#files","title":"Files","text":"Type Name file inverttool.cpp file inverttool.h"},{"location":"flameshot/inverttool_8cpp/","title":"File inverttool.cpp","text":"<p>FileList &gt; invert &gt; inverttool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"inverttool.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QGraphicsBlurEffect&gt;</code></li> <li><code>#include &lt;QGraphicsPixmapItem&gt;</code></li> <li><code>#include &lt;QGraphicsScene&gt;</code></li> <li><code>#include &lt;QImage&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> </ul>"},{"location":"flameshot/inverttool_8cpp_source/","title":"File inverttool.cpp","text":"<p>File List &gt; invert &gt; inverttool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"inverttool.h\"\n#include &lt;QApplication&gt;\n#include &lt;QGraphicsBlurEffect&gt;\n#include &lt;QGraphicsPixmapItem&gt;\n#include &lt;QGraphicsScene&gt;\n#include &lt;QImage&gt;\n#include &lt;QPainter&gt;\n#include &lt;QPixmap&gt;\n\nInvertTool::InvertTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{}\n\nQIcon InvertTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"invert.svg\");\n}\n\nQString InvertTool::name() const\n{\n    return tr(\"Invert\");\n}\n\nCaptureTool::Type InvertTool::type() const\n{\n    return CaptureTool::TYPE_INVERT;\n}\n\nQString InvertTool::description() const\n{\n    return tr(\"Set Inverter as the paint tool\");\n}\n\nQRect InvertTool::boundingRect() const\n{\n    return QRect(points().first, points().second).normalized();\n}\n\nCaptureTool* InvertTool::copy(QObject* parent)\n{\n    auto* tool = new InvertTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid InvertTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    QRect selection = boundingRect().intersected(pixmap.rect());\n    auto pixelRatio = pixmap.devicePixelRatio();\n    QRect selectionScaled = QRect(selection.topLeft() * pixelRatio,\n                                  selection.bottomRight() * pixelRatio);\n\n    // Invert selection\n    QPixmap inv = pixmap.copy(selectionScaled);\n    QImage img = inv.toImage();\n    img.invertPixels();\n\n    painter.drawImage(selection, img);\n}\n\nvoid InvertTool::drawSearchArea(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.fillRect(boundingRect(), QBrush(Qt::black));\n}\n\nvoid InvertTool::paintMousePreview(QPainter&amp; painter,\n                                   const CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    Q_UNUSED(painter)\n}\n\nvoid InvertTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/inverttool_8h/","title":"File inverttool.h","text":"<p>FileList &gt; invert &gt; inverttool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/inverttool_8h/#classes","title":"Classes","text":"Type Name class InvertTool"},{"location":"flameshot/inverttool_8h_source/","title":"File inverttool.h","text":"<p>File List &gt; invert &gt; inverttool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass InvertTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit InvertTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n    QRect boundingRect() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void drawSearchArea(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_326deb5008ae61e8c45a344032652c44/","title":"Dir launcher","text":"<p>FileList &gt; launcher</p>"},{"location":"flameshot/dir_326deb5008ae61e8c45a344032652c44/#files","title":"Files","text":"Type Name file applaunchertool.cpp file applaunchertool.h file applauncherwidget.cpp file applauncherwidget.h file launcheritemdelegate.cpp file launcheritemdelegate.h file openwithprogram.cpp file openwithprogram.h file terminallauncher.cpp file terminallauncher.h"},{"location":"flameshot/applaunchertool_8cpp/","title":"File applaunchertool.cpp","text":"<p>FileList &gt; launcher &gt; applaunchertool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"applaunchertool.h\"</code></li> <li><code>#include \"applauncherwidget.h\"</code></li> </ul>"},{"location":"flameshot/applaunchertool_8cpp_source/","title":"File applaunchertool.cpp","text":"<p>File List &gt; launcher &gt; applaunchertool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"applaunchertool.h\"\n#include \"applauncherwidget.h\"\n\nAppLauncher::AppLauncher(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool AppLauncher::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon AppLauncher::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"open_with.svg\");\n}\nQString AppLauncher::name() const\n{\n    return tr(\"App Launcher\");\n}\n\nCaptureTool::Type AppLauncher::type() const\n{\n    return CaptureTool::TYPE_OPEN_APP;\n}\n\nQString AppLauncher::description() const\n{\n    return tr(\"Choose an app to open the capture\");\n}\n\nQWidget* AppLauncher::widget()\n{\n    return new AppLauncherWidget(capture);\n}\n\nCaptureTool* AppLauncher::copy(QObject* parent)\n{\n    return new AppLauncher(parent);\n}\n\nvoid AppLauncher::pressed(CaptureContext&amp; context)\n{\n    capture = context.selectedScreenshotArea();\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    emit requestAction(REQ_ADD_EXTERNAL_WIDGETS);\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/applaunchertool_8h/","title":"File applaunchertool.h","text":"<p>FileList &gt; launcher &gt; applaunchertool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/applaunchertool_8h/#classes","title":"Classes","text":"Type Name class AppLauncher"},{"location":"flameshot/applaunchertool_8h_source/","title":"File applaunchertool.h","text":"<p>File List &gt; launcher &gt; applaunchertool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass AppLauncher : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit AppLauncher(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    QWidget* widget() override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n\nprivate:\n    QPixmap capture;\n};\n\n</code></pre>"},{"location":"flameshot/applauncherwidget_8cpp/","title":"File applauncherwidget.cpp","text":"<p>FileList &gt; launcher &gt; applauncherwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"applauncherwidget.h\"</code></li> <li><code>#include \"src/tools/launcher/launcheritemdelegate.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/filenamehandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"terminallauncher.h\"</code></li> <li><code>#include &lt;QCheckBox&gt;</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QLineEdit&gt;</code></li> <li><code>#include &lt;QList&gt;</code></li> <li><code>#include &lt;QListView&gt;</code></li> <li><code>#include &lt;QListWidgetItem&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QProcess&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> <li><code>#include &lt;QTabWidget&gt;</code></li> </ul>"},{"location":"flameshot/applauncherwidget_8cpp_source/","title":"File applauncherwidget.cpp","text":"<p>File List &gt; launcher &gt; applauncherwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"applauncherwidget.h\"\n#include \"src/tools/launcher/launcheritemdelegate.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/filenamehandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"terminallauncher.h\"\n#include &lt;QCheckBox&gt;\n#include &lt;QDir&gt;\n#include &lt;QHBoxLayout&gt;\n#include &lt;QKeyEvent&gt;\n#include &lt;QLineEdit&gt;\n#include &lt;QList&gt;\n#include &lt;QListView&gt;\n#include &lt;QListWidgetItem&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QPixmap&gt;\n#include &lt;QProcess&gt;\n#include &lt;QStandardPaths&gt;\n#include &lt;QTabWidget&gt;\n\nnamespace {\n#if defined(Q_OS_WIN)\nQMap&lt;QString, QString&gt; catIconNames({ { \"Graphics\", \"image.svg\" },\n                                      { \"Utility\", \"apps.svg\" } });\n}\n#else\nQMap&lt;QString, QString&gt; catIconNames(\n  { { \"Multimedia\", \"applications-multimedia\" },\n    { \"Development\", \"applications-development\" },\n    { \"Graphics\", \"applications-graphics\" },\n    { \"Network\", \"preferences-system-network\" },\n    { \"Office\", \"applications-office\" },\n    { \"Science\", \"applications-science\" },\n    { \"Settings\", \"preferences-desktop\" },\n    { \"System\", \"preferences-system\" },\n    { \"Utility\", \"applications-utilities\" } });\n}\n#endif\n\nAppLauncherWidget::AppLauncherWidget(const QPixmap&amp; p, QWidget* parent)\n  : QWidget(parent)\n  , m_pixmap(p)\n{\n    setAttribute(Qt::WA_DeleteOnClose);\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    setWindowTitle(tr(\"Open With\"));\n\n    m_keepOpen = ConfigHandler().keepOpenAppLauncher();\n\n#if defined(Q_OS_WIN)\n    QDir userAppsFolder(\n      QStandardPaths::standardLocations(QStandardPaths::ApplicationsLocation)\n        .at(0));\n    m_parser.processDirectory(userAppsFolder);\n\n    QString dir(m_parser.getAllUsersStartMenuPath());\n    if (!dir.isEmpty()) {\n        QDir allUserAppsFolder(dir);\n        m_parser.processDirectory(allUserAppsFolder);\n    }\n#else\n    QString dirLocal = QDir::homePath() + \"/.local/share/applications/\";\n    QDir appsDirLocal(dirLocal);\n    m_parser.processDirectory(appsDirLocal);\n\n    QString dir = QStringLiteral(\"/usr/share/applications/\");\n    QDir appsDir(dir);\n    m_parser.processDirectory(appsDir);\n#endif\n\n    initAppMap();\n    initListWidget();\n\n    m_terminalCheckbox = new QCheckBox(tr(\"Launch in terminal\"), this);\n    m_keepOpenCheckbox = new QCheckBox(tr(\"Keep open after selection\"), this);\n    m_keepOpenCheckbox-&gt;setChecked(ConfigHandler().keepOpenAppLauncher());\n    connect(m_keepOpenCheckbox,\n            &amp;QCheckBox::clicked,\n            this,\n            &amp;AppLauncherWidget::checkboxClicked);\n\n    // search items\n    m_lineEdit = new QLineEdit;\n    connect(m_lineEdit,\n            &amp;QLineEdit::textChanged,\n            this,\n            &amp;AppLauncherWidget::searchChanged);\n    m_filterList = new QListWidget;\n    m_filterList-&gt;hide();\n    configureListView(m_filterList);\n    connect(\n      m_filterList, &amp;QListWidget::clicked, this, &amp;AppLauncherWidget::launch);\n\n    m_layout = new QVBoxLayout(this);\n    m_layout-&gt;addWidget(m_filterList);\n    m_layout-&gt;addWidget(m_tabWidget);\n    m_layout-&gt;addWidget(m_lineEdit);\n    m_layout-&gt;addWidget(m_keepOpenCheckbox);\n    m_layout-&gt;addWidget(m_terminalCheckbox);\n    m_lineEdit-&gt;setFocus();\n}\n\nvoid AppLauncherWidget::launch(const QModelIndex&amp; index)\n{\n    if (!QFileInfo(m_tempFile).isReadable()) {\n        m_tempFile =\n          FileNameHandler().properScreenshotPath(QDir::tempPath(), \"png\");\n        bool ok = m_pixmap.save(m_tempFile);\n        if (!ok) {\n            QMessageBox::about(\n              this, tr(\"Error\"), tr(\"Unable to write in\") + QDir::tempPath());\n            return;\n        }\n    }\n    // Heuristically, if there is a % in the command we assume it is the file\n    // name slot\n    QString command = index.data(Qt::UserRole).toString();\n#if defined(Q_OS_WIN)\n    // Do not split on Windows, since file path can contain spaces\n    // and % is not used in lnk files\n    QStringList prog_args;\n    prog_args &lt;&lt; command;\n#else\n    QStringList prog_args = command.split(\" \");\n#endif\n    // no quotes because it is going in an array!\n    if (command.contains(\"%\")) {\n        // but that means we need to substitute IN the array not the string!\n        for (auto&amp; i : prog_args) {\n            if (i.contains(\"%\"))\n                i.replace(QRegExp(\"(\\\\%.)\"), m_tempFile);\n        }\n    } else {\n        // we really should append the file name if there\n        prog_args.append(m_tempFile); // were no replacements\n    }\n    QString app_name = prog_args.at(0);\n    bool inTerminal =\n      index.data(Qt::UserRole + 1).toBool() || m_terminalCheckbox-&gt;isChecked();\n    if (inTerminal) {\n        bool ok = TerminalLauncher::launchDetached(command);\n        if (!ok) {\n            QMessageBox::about(\n              this, tr(\"Error\"), tr(\"Unable to launch in terminal.\"));\n        }\n    } else {\n        QFileInfo fi(m_tempFile);\n        QString workingDir = fi.absolutePath();\n        prog_args.removeAt(0); // strip program name out\n        QProcess::startDetached(app_name, prog_args, workingDir);\n    }\n    if (!m_keepOpen) {\n        close();\n    }\n}\n\nvoid AppLauncherWidget::checkboxClicked(const bool enabled)\n{\n    m_keepOpen = enabled;\n    ConfigHandler().setKeepOpenAppLauncher(enabled);\n    m_keepOpenCheckbox-&gt;setChecked(enabled);\n}\n\nvoid AppLauncherWidget::searchChanged(const QString&amp; text)\n{\n    if (text.isEmpty()) {\n        m_filterList-&gt;hide();\n        m_tabWidget-&gt;show();\n    } else {\n        m_tabWidget-&gt;hide();\n        m_filterList-&gt;show();\n        m_filterList-&gt;clear();\n        QRegExp regexp(text, Qt::CaseInsensitive, QRegExp::Wildcard);\n        QVector&lt;DesktopAppData&gt; apps;\n\n        for (auto const&amp; i : catIconNames.toStdMap()) {\n            const QString&amp; cat = i.first;\n            if (!m_appsMap.contains(cat)) {\n                continue;\n            }\n            const QVector&lt;DesktopAppData&gt;&amp; appList = m_appsMap[cat];\n            for (const DesktopAppData&amp; app : appList) {\n                if (!apps.contains(app) &amp;&amp; (app.name.contains(regexp) ||\n                                            app.description.contains(regexp))) {\n                    apps.append(app);\n                }\n            }\n        }\n        addAppsToListWidget(m_filterList, apps);\n    }\n}\n\nvoid AppLauncherWidget::initListWidget()\n{\n    m_tabWidget = new QTabWidget;\n    const int size = GlobalValues::buttonBaseSize();\n    m_tabWidget-&gt;setIconSize(QSize(size, size));\n\n    for (auto const&amp; i : catIconNames.toStdMap()) {\n        const QString&amp; cat = i.first;\n        const QString&amp; iconName = i.second;\n\n        if (!m_appsMap.contains(cat)) {\n            continue;\n        }\n\n        auto* itemsWidget = new QListWidget();\n        configureListView(itemsWidget);\n\n        const QVector&lt;DesktopAppData&gt;&amp; appList = m_appsMap[cat];\n        addAppsToListWidget(itemsWidget, appList);\n\n#if defined(Q_OS_WIN)\n        QColor background = this-&gt;palette().window().color();\n        bool isDark = ColorUtils::colorIsDark(background);\n        QString modifier =\n          isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();\n        m_tabWidget-&gt;addTab(\n          itemsWidget, QIcon(modifier + iconName), QLatin1String(\"\"));\n#else\n        m_tabWidget-&gt;addTab(\n          itemsWidget, QIcon::fromTheme(iconName), QLatin1String(\"\"));\n#endif\n        m_tabWidget-&gt;setTabToolTip(m_tabWidget-&gt;count(), cat);\n        if (cat == QLatin1String(\"Graphics\")) {\n            m_tabWidget-&gt;setCurrentIndex(m_tabWidget-&gt;count() - 1);\n        }\n    }\n}\n\nvoid AppLauncherWidget::initAppMap()\n{\n    QStringList categories({ \"AudioVideo\",\n                             \"Audio\",\n                             \"Video\",\n                             \"Development\",\n                             \"Graphics\",\n                             \"Network\",\n                             \"Office\",\n                             \"Science\",\n                             \"Settings\",\n                             \"System\",\n                             \"Utility\" });\n\n    m_appsMap = m_parser.getAppsByCategory(categories);\n\n    // Unify multimedia.\n    QVector&lt;DesktopAppData&gt; multimediaList;\n    QStringList multimediaNames;\n    multimediaNames &lt;&lt; QStringLiteral(\"AudioVideo\") &lt;&lt; QStringLiteral(\"Audio\")\n                    &lt;&lt; QStringLiteral(\"Video\");\n    for (const QString&amp; name : qAsConst(multimediaNames)) {\n        if (!m_appsMap.contains(name)) {\n            continue;\n        }\n        for (const auto&amp; i : m_appsMap[name]) {\n            if (!multimediaList.contains(i)) {\n                multimediaList.append(i);\n            }\n        }\n        m_appsMap.remove(name);\n    }\n\n    if (!multimediaList.isEmpty()) {\n        m_appsMap.insert(QStringLiteral(\"Multimedia\"), multimediaList);\n    }\n}\n\nvoid AppLauncherWidget::configureListView(QListWidget* widget)\n{\n    widget-&gt;setItemDelegate(new LauncherItemDelegate());\n    widget-&gt;setViewMode(QListWidget::IconMode);\n    widget-&gt;setResizeMode(QListView::Adjust);\n    widget-&gt;setSpacing(4);\n    widget-&gt;setFlow(QListView::LeftToRight);\n    widget-&gt;setDragEnabled(false);\n    widget-&gt;setMinimumWidth(GlobalValues::buttonBaseSize() * 11);\n    connect(widget, &amp;QListWidget::clicked, this, &amp;AppLauncherWidget::launch);\n}\n\nvoid AppLauncherWidget::addAppsToListWidget(\n  QListWidget* widget,\n  const QVector&lt;DesktopAppData&gt;&amp; appList)\n{\n    for (const DesktopAppData&amp; app : appList) {\n        auto* buttonItem = new QListWidgetItem(widget);\n        buttonItem-&gt;setData(Qt::DecorationRole, app.icon);\n        buttonItem-&gt;setData(Qt::DisplayRole, app.name);\n        buttonItem-&gt;setData(Qt::UserRole, app.exec);\n        buttonItem-&gt;setData(Qt::UserRole + 1, app.showInTerminal);\n        QColor foregroundColor =\n          this-&gt;palette().color(QWidget::foregroundRole());\n        buttonItem-&gt;setForeground(foregroundColor);\n\n        buttonItem-&gt;setIcon(app.icon);\n        buttonItem-&gt;setText(app.name);\n        buttonItem-&gt;setToolTip(app.description);\n    }\n}\n\nvoid AppLauncherWidget::keyPressEvent(QKeyEvent* keyEvent)\n{\n    if (keyEvent-&gt;key() == Qt::Key_Escape) {\n        close();\n    } else if (keyEvent-&gt;key() == Qt::Key_Return) {\n        auto* widget = (QListWidget*)m_tabWidget-&gt;currentWidget();\n        if (m_filterList-&gt;isVisible())\n            widget = m_filterList;\n        auto* item = widget-&gt;currentItem();\n        if (item == nullptr) {\n            item = widget-&gt;item(0);\n            widget-&gt;setCurrentItem(item);\n        }\n        QModelIndex const idx = widget-&gt;currentIndex();\n        AppLauncherWidget::launch(idx);\n    } else {\n        QWidget::keyPressEvent(keyEvent);\n    }\n}\n\n</code></pre>"},{"location":"flameshot/applauncherwidget_8h/","title":"File applauncherwidget.h","text":"<p>FileList &gt; launcher &gt; applauncherwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> <li><code>#include \"src/utils/desktopfileparse.h\"</code></li> </ul>"},{"location":"flameshot/applauncherwidget_8h/#classes","title":"Classes","text":"Type Name class AppLauncherWidget"},{"location":"flameshot/applauncherwidget_8h_source/","title":"File applauncherwidget.h","text":"<p>File List &gt; launcher &gt; applauncherwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QMap&gt;\n#include &lt;QWidget&gt;\n\n#if defined(Q_OS_WIN)\n#include \"src/utils/winlnkfileparse.h\"\n#else\n#include \"src/utils/desktopfileparse.h\"\n#endif\n\nclass QTabWidget;\nclass QCheckBox;\nclass QVBoxLayout;\nclass QLineEdit;\nclass QListWidget;\n\nclass AppLauncherWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit AppLauncherWidget(const QPixmap&amp; p, QWidget* parent = nullptr);\n\nprivate slots:\n    void launch(const QModelIndex&amp; index);\n    void checkboxClicked(const bool enabled);\n    void searchChanged(const QString&amp; text);\n\nprivate:\n    void initListWidget();\n    void initAppMap();\n    void configureListView(QListWidget* widget);\n    void addAppsToListWidget(QListWidget* widget,\n                             const QVector&lt;DesktopAppData&gt;&amp; appList);\n    void keyPressEvent(QKeyEvent* keyEvent) override;\n\n#if defined(Q_OS_WIN)\n    WinLnkFileParser m_parser;\n#else\n    DesktopFileParser m_parser;\n#endif\n    QPixmap m_pixmap;\n    QString m_tempFile;\n    bool m_keepOpen;\n    QMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; m_appsMap;\n    QCheckBox* m_keepOpenCheckbox;\n    QCheckBox* m_terminalCheckbox;\n    QVBoxLayout* m_layout;\n    QLineEdit* m_lineEdit;\n    QListWidget* m_filterList;\n    QTabWidget* m_tabWidget;\n};\n\n</code></pre>"},{"location":"flameshot/launcheritemdelegate_8cpp/","title":"File launcheritemdelegate.cpp","text":"<p>FileList &gt; launcher &gt; launcheritemdelegate.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"launcheritemdelegate.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/launcheritemdelegate_8cpp_source/","title":"File launcheritemdelegate.cpp","text":"<p>File List &gt; launcher &gt; launcheritemdelegate.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"launcheritemdelegate.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QPainter&gt;\n\nLauncherItemDelegate::LauncherItemDelegate(QObject* parent)\n  : QStyledItemDelegate(parent)\n{}\n\nvoid LauncherItemDelegate::paint(QPainter* painter,\n                                 const QStyleOptionViewItem&amp; option,\n                                 const QModelIndex&amp; index) const\n{\n    const QRect&amp; rect = option.rect;\n    if (option.state &amp; (QStyle::State_Selected | QStyle::State_MouseOver)) {\n        painter-&gt;save();\n        painter-&gt;setPen(Qt::transparent);\n        painter-&gt;setBrush(QPalette().highlight());\n        painter-&gt;drawRect(\n          rect.x(), rect.y(), rect.width() - 1, rect.height() - 1);\n        painter-&gt;restore();\n    }\n    auto icon = index.data(Qt::DecorationRole).value&lt;QIcon&gt;();\n\n    const int iconSide = static_cast&lt;int&gt;(GlobalValues::buttonBaseSize() * 1.3);\n    const int halfIcon = iconSide / 2;\n    const int halfWidth = rect.width() / 2;\n    const int halfHeight = rect.height() / 2;\n    QSize size(iconSide, iconSide);\n    QPixmap pixIcon = icon.pixmap(size).scaled(\n      size, Qt::KeepAspectRatio, Qt::SmoothTransformation);\n    painter-&gt;drawPixmap(rect.x() + (halfWidth - halfIcon),\n                        rect.y() + (halfHeight / 2 - halfIcon),\n                        iconSide,\n                        iconSide,\n                        pixIcon);\n    const QRect textRect(\n      rect.x(), rect.y() + halfHeight, rect.width(), halfHeight);\n    painter-&gt;drawText(textRect,\n                      Qt::TextWordWrap | Qt::AlignHCenter,\n                      index.data(Qt::DisplayRole).toString());\n}\n\nQSize LauncherItemDelegate::sizeHint(const QStyleOptionViewItem&amp; option,\n                                     const QModelIndex&amp; index) const\n{\n    Q_UNUSED(option)\n    Q_UNUSED(index)\n    const int size = GlobalValues::buttonBaseSize();\n    return { static_cast&lt;int&gt;(size * 3.2), static_cast&lt;int&gt;(size * 3.7) };\n}\n\n</code></pre>"},{"location":"flameshot/launcheritemdelegate_8h/","title":"File launcheritemdelegate.h","text":"<p>FileList &gt; launcher &gt; launcheritemdelegate.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/utils/desktopfileparse.h\"</code></li> <li><code>#include &lt;QStyledItemDelegate&gt;</code></li> </ul>"},{"location":"flameshot/launcheritemdelegate_8h/#classes","title":"Classes","text":"Type Name class LauncherItemDelegate"},{"location":"flameshot/launcheritemdelegate_8h_source/","title":"File launcheritemdelegate.h","text":"<p>File List &gt; launcher &gt; launcheritemdelegate.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/utils/desktopfileparse.h\"\n#include &lt;QStyledItemDelegate&gt;\n\nclass LauncherItemDelegate : public QStyledItemDelegate\n{\n    Q_OBJECT\npublic:\n    explicit LauncherItemDelegate(QObject* parent = nullptr);\n\n    void paint(QPainter* painter,\n               const QStyleOptionViewItem&amp; option,\n               const QModelIndex&amp; index) const override;\n\n    QSize sizeHint(const QStyleOptionViewItem&amp; option,\n                   const QModelIndex&amp; index) const override;\n};\n\n</code></pre>"},{"location":"flameshot/openwithprogram_8cpp/","title":"File openwithprogram.cpp","text":"<p>FileList &gt; launcher &gt; openwithprogram.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"openwithprogram.h\"</code></li> <li><code>#include \"src/tools/launcher/applauncherwidget.h\"</code></li> </ul>"},{"location":"flameshot/openwithprogram_8cpp/#public-functions","title":"Public Functions","text":"Type Name void showOpenWithMenu (const QPixmap &amp; capture)"},{"location":"flameshot/openwithprogram_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/openwithprogram_8cpp/#function-showopenwithmenu","title":"function showOpenWithMenu","text":"<pre><code>void showOpenWithMenu (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/openwithprogram_8cpp_source/","title":"File openwithprogram.cpp","text":"<p>File List &gt; launcher &gt; openwithprogram.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"openwithprogram.h\"\n\n#if defined(Q_OS_WIN)\n#include \"src/utils/filenamehandler.h\"\n#include &lt;QDir&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;windows.h&gt;\n#ifdef _WIN32_WINNT\n#undef _WIN32_WINNT\n#define _WIN32_WINNT 0x601\n#endif\n#include &lt;Shlobj.h&gt;\n\n#pragma comment(lib, \"Shell32.lib\")\n#else\n#include \"src/tools/launcher/applauncherwidget.h\"\n#endif\n\nvoid showOpenWithMenu(const QPixmap&amp; capture)\n{\n#if defined(Q_OS_WIN)\n    QString tempFile =\n      FileNameHandler().properScreenshotPath(QDir::tempPath(), \"png\");\n    bool ok = capture.save(tempFile);\n    if (!ok) {\n        QMessageBox::about(nullptr,\n                           QObject::tr(\"Error\"),\n                           QObject::tr(\"Unable to write in\") +\n                             QDir::tempPath());\n        return;\n    }\n\n    OPENASINFO info;\n    auto wStringFile = tempFile.replace(\"/\", \"\\\\\").toStdWString();\n    info.pcszFile = wStringFile.c_str();\n    info.pcszClass = nullptr;\n    info.oaifInFlags = OAIF_ALLOW_REGISTRATION | OAIF_EXEC;\n    SHOpenWithDialog(nullptr, &amp;info);\n#else\n    auto* w = new AppLauncherWidget(capture);\n    w-&gt;show();\n#endif\n}\n\n</code></pre>"},{"location":"flameshot/openwithprogram_8h/","title":"File openwithprogram.h","text":"<p>FileList &gt; launcher &gt; openwithprogram.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QPixmap&gt;</code></li> </ul>"},{"location":"flameshot/openwithprogram_8h/#public-functions","title":"Public Functions","text":"Type Name void showOpenWithMenu (const QPixmap &amp; capture)"},{"location":"flameshot/openwithprogram_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/openwithprogram_8h/#function-showopenwithmenu","title":"function showOpenWithMenu","text":"<pre><code>void showOpenWithMenu (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/openwithprogram_8h_source/","title":"File openwithprogram.h","text":"<p>File List &gt; launcher &gt; openwithprogram.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QPixmap&gt;\n\nvoid showOpenWithMenu(const QPixmap&amp; capture);\n\n</code></pre>"},{"location":"flameshot/terminallauncher_8cpp/","title":"File terminallauncher.cpp","text":"<p>FileList &gt; launcher &gt; terminallauncher.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"terminallauncher.h\"</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QProcess&gt;</code></li> <li><code>#include &lt;QProcessEnvironment&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> </ul>"},{"location":"flameshot/terminallauncher_8cpp_source/","title":"File terminallauncher.cpp","text":"<p>File List &gt; launcher &gt; terminallauncher.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"terminallauncher.h\"\n#include &lt;QDir&gt;\n#include &lt;QProcess&gt;\n#include &lt;QProcessEnvironment&gt;\n#include &lt;QStandardPaths&gt;\n\nnamespace {\nstatic const TerminalApp terminalApps[] = {\n    { \"x-terminal-emulator\", \"-e\" },\n    { \"xfce4-terminal\", \"-x\" },\n    { \"konsole\", \"-e\" },\n    { \"gnome-terminal\", \"--\" },\n    { \"terminator\", \"-e\" },\n    { \"terminology\", \"-e\" },\n    { \"tilix\", \"-e\" },\n    { \"xterm\", \"-e\" },\n    { \"aterm\", \"-e\" },\n    { \"Eterm\", \"-e\" },\n    { \"rxvt\", \"-e\" },\n    { \"urxvt\", \"-e\" },\n};\n}\n\nTerminalLauncher::TerminalLauncher(QObject* parent)\n  : QObject(parent)\n{}\n\nTerminalApp TerminalLauncher::getPreferedTerminal()\n{\n    TerminalApp res;\n    for (const TerminalApp&amp; app : terminalApps) {\n        QString path = QStandardPaths::findExecutable(app.name);\n        if (!path.isEmpty()) {\n            res = app;\n            break;\n        }\n    }\n    return res;\n}\n\nbool TerminalLauncher::launchDetached(const QString&amp; command)\n{\n    TerminalApp app = getPreferedTerminal();\n    return QProcess::startDetached(app.name, { app.arg, command });\n}\n\n</code></pre>"},{"location":"flameshot/terminallauncher_8h/","title":"File terminallauncher.h","text":"<p>FileList &gt; launcher &gt; terminallauncher.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/terminallauncher_8h/#classes","title":"Classes","text":"Type Name struct TerminalApp class TerminalLauncher"},{"location":"flameshot/terminallauncher_8h_source/","title":"File terminallauncher.h","text":"<p>File List &gt; launcher &gt; terminallauncher.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QObject&gt;\n\nstruct TerminalApp\n{\n    QString name;\n    QString arg;\n};\n\nclass TerminalLauncher : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit TerminalLauncher(QObject* parent = nullptr);\n\n    static bool launchDetached(const QString&amp; command);\n\nprivate:\n    static TerminalApp getPreferedTerminal();\n};\n\n</code></pre>"},{"location":"flameshot/dir_0d0caafe2e9a89cac97883145bdb356a/","title":"Dir line","text":"<p>FileList &gt; line</p>"},{"location":"flameshot/dir_0d0caafe2e9a89cac97883145bdb356a/#files","title":"Files","text":"Type Name file linetool.cpp file linetool.h"},{"location":"flameshot/linetool_8cpp/","title":"File linetool.cpp","text":"<p>FileList &gt; line &gt; linetool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"linetool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/linetool_8cpp_source/","title":"File linetool.cpp","text":"<p>File List &gt; line &gt; linetool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"linetool.h\"\n#include &lt;QPainter&gt;\n\nLineTool::LineTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{\n    m_supportsOrthogonalAdj = true;\n    m_supportsDiagonalAdj = true;\n}\n\nQIcon LineTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"line.svg\");\n}\n\nQString LineTool::name() const\n{\n    return tr(\"Line\");\n}\n\nCaptureTool::Type LineTool::type() const\n{\n    return CaptureTool::TYPE_DRAWER;\n}\n\nQString LineTool::description() const\n{\n    return tr(\"Set the Line as the paint tool\");\n}\n\nCaptureTool* LineTool::copy(QObject* parent)\n{\n    auto* tool = new LineTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid LineTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.setPen(QPen(color(), size()));\n    painter.drawLine(points().first, points().second);\n}\n\nvoid LineTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/linetool_8h/","title":"File linetool.h","text":"<p>FileList &gt; line &gt; linetool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/linetool_8h/#classes","title":"Classes","text":"Type Name class LineTool"},{"location":"flameshot/linetool_8h_source/","title":"File linetool.h","text":"<p>File List &gt; line &gt; linetool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass LineTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit LineTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_216b21e4e5ad693563f55da5d6bf2868/","title":"Dir marker","text":"<p>FileList &gt; marker</p>"},{"location":"flameshot/dir_216b21e4e5ad693563f55da5d6bf2868/#files","title":"Files","text":"Type Name file markertool.cpp file markertool.h"},{"location":"flameshot/markertool_8cpp/","title":"File markertool.cpp","text":"<p>FileList &gt; marker &gt; markertool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"markertool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/markertool_8cpp/#macros","title":"Macros","text":"Type Name define PADDING_VALUE  14"},{"location":"flameshot/markertool_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/markertool_8cpp/#define-padding_value","title":"define PADDING_VALUE","text":"<pre><code>#define PADDING_VALUE 14\n</code></pre>"},{"location":"flameshot/markertool_8cpp_source/","title":"File markertool.cpp","text":"<p>File List &gt; marker &gt; markertool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"markertool.h\"\n#include &lt;QPainter&gt;\n\n#define PADDING_VALUE 14\n\nMarkerTool::MarkerTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{\n    m_supportsOrthogonalAdj = true;\n    m_supportsDiagonalAdj = true;\n}\n\nQIcon MarkerTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"marker.svg\");\n}\nQString MarkerTool::name() const\n{\n    return tr(\"Marker\");\n}\n\nCaptureTool::Type MarkerTool::type() const\n{\n    return CaptureTool::TYPE_MARKER;\n}\n\nQString MarkerTool::description() const\n{\n    return tr(\"Set the Marker as the paint tool\");\n}\n\nQRect MarkerTool::mousePreviewRect(const CaptureContext&amp; context) const\n{\n    int width = PADDING_VALUE + context.toolSize;\n    QRect rect(0, 0, width + 2, width + 2);\n    rect.moveCenter(context.mousePos);\n    return rect;\n}\n\nCaptureTool* MarkerTool::copy(QObject* parent)\n{\n    auto* tool = new MarkerTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid MarkerTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    auto compositionMode = painter.compositionMode();\n    qreal opacity = painter.opacity();\n    auto pen = painter.pen();\n    painter.setCompositionMode(QPainter::CompositionMode_Multiply);\n    painter.setOpacity(0.35);\n    painter.setPen(QPen(color(), size()));\n    painter.drawLine(points().first, points().second);\n    painter.setPen(pen);\n    painter.setOpacity(opacity);\n    painter.setCompositionMode(compositionMode);\n}\n\nvoid MarkerTool::paintMousePreview(QPainter&amp; painter,\n                                   const CaptureContext&amp; context)\n{\n    auto compositionMode = painter.compositionMode();\n    qreal opacity = painter.opacity();\n    auto pen = painter.pen();\n    painter.setCompositionMode(QPainter::CompositionMode_Multiply);\n    painter.setOpacity(0.35);\n    painter.setPen(QPen(context.color, PADDING_VALUE + context.toolSize));\n    painter.drawLine(context.mousePos, context.mousePos);\n    painter.setPen(pen);\n    painter.setOpacity(opacity);\n    painter.setCompositionMode(compositionMode);\n}\n\nvoid MarkerTool::drawStart(const CaptureContext&amp; context)\n{\n    AbstractTwoPointTool::drawStart(context);\n    onSizeChanged(context.toolSize + PADDING_VALUE);\n}\n\nvoid MarkerTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/markertool_8h/","title":"File markertool.h","text":"<p>FileList &gt; marker &gt; markertool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/markertool_8h/#classes","title":"Classes","text":"Type Name class MarkerTool"},{"location":"flameshot/markertool_8h_source/","title":"File markertool.h","text":"<p>File List &gt; marker &gt; markertool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass MarkerTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit MarkerTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n    QRect mousePreviewRect(const CaptureContext&amp; context) const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void drawStart(const CaptureContext&amp; context) override;\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_9298e764bfa4f928068ef838f950b224/","title":"Dir move","text":"<p>FileList &gt; move</p>"},{"location":"flameshot/dir_9298e764bfa4f928068ef838f950b224/#files","title":"Files","text":"Type Name file movetool.cpp file movetool.h"},{"location":"flameshot/movetool_8cpp/","title":"File movetool.cpp","text":"<p>FileList &gt; move &gt; movetool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"movetool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/movetool_8cpp_source/","title":"File movetool.cpp","text":"<p>File List &gt; move &gt; movetool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"movetool.h\"\n#include &lt;QPainter&gt;\n\nMoveTool::MoveTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool MoveTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nQIcon MoveTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"cursor-move.svg\");\n}\nQString MoveTool::name() const\n{\n    return tr(\"Move\");\n}\n\nCaptureTool::Type MoveTool::type() const\n{\n    return CaptureTool::TYPE_MOVESELECTION;\n}\n\nQString MoveTool::description() const\n{\n    return tr(\"Move the selection area\");\n}\n\nCaptureTool* MoveTool::copy(QObject* parent)\n{\n    return new MoveTool(parent);\n}\n\nvoid MoveTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\nbool MoveTool::isSelectable() const\n{\n    return true;\n}\n\n</code></pre>"},{"location":"flameshot/movetool_8h/","title":"File movetool.h","text":"<p>FileList &gt; move &gt; movetool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/movetool_8h/#classes","title":"Classes","text":"Type Name class MoveTool"},{"location":"flameshot/movetool_8h_source/","title":"File movetool.h","text":"<p>File List &gt; move &gt; movetool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass MoveTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit MoveTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    CaptureTool::Type type() const override;\n    QString description() const override;\n    bool isSelectable() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_ba37296f25af0f64ffd9ff73ad908ca7/","title":"Dir pencil","text":"<p>FileList &gt; pencil</p>"},{"location":"flameshot/dir_ba37296f25af0f64ffd9ff73ad908ca7/#files","title":"Files","text":"Type Name file penciltool.cpp file penciltool.h"},{"location":"flameshot/penciltool_8cpp/","title":"File penciltool.cpp","text":"<p>FileList &gt; pencil &gt; penciltool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"penciltool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/penciltool_8cpp_source/","title":"File penciltool.cpp","text":"<p>File List &gt; pencil &gt; penciltool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"penciltool.h\"\n#include &lt;QPainter&gt;\n\nPencilTool::PencilTool(QObject* parent)\n  : AbstractPathTool(parent)\n{}\n\nQIcon PencilTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"pencil.svg\");\n}\nQString PencilTool::name() const\n{\n    return tr(\"Pencil\");\n}\n\nCaptureTool::Type PencilTool::type() const\n{\n    return CaptureTool::TYPE_PENCIL;\n}\n\nQString PencilTool::description() const\n{\n    return tr(\"Set the Pencil as the paint tool\");\n}\n\nCaptureTool* PencilTool::copy(QObject* parent)\n{\n    auto* tool = new PencilTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid PencilTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.setPen(QPen(m_color, size()));\n    painter.drawPolyline(m_points.data(), m_points.size());\n}\n\nvoid PencilTool::paintMousePreview(QPainter&amp; painter,\n                                   const CaptureContext&amp; context)\n{\n    painter.setPen(QPen(context.color, context.toolSize + 2));\n    painter.drawLine(context.mousePos, context.mousePos);\n}\n\nvoid PencilTool::drawStart(const CaptureContext&amp; context)\n{\n    m_color = context.color;\n    onSizeChanged(context.toolSize);\n    m_points.append(context.mousePos);\n    m_pathArea.setTopLeft(context.mousePos);\n    m_pathArea.setBottomRight(context.mousePos);\n}\n\nvoid PencilTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/penciltool_8h/","title":"File penciltool.h","text":"<p>FileList &gt; pencil &gt; penciltool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractpathtool.h\"</code></li> </ul>"},{"location":"flameshot/penciltool_8h/#classes","title":"Classes","text":"Type Name class PencilTool"},{"location":"flameshot/penciltool_8h_source/","title":"File penciltool.h","text":"<p>File List &gt; pencil &gt; penciltool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractpathtool.h\"\n\nclass PencilTool : public AbstractPathTool\n{\n    Q_OBJECT\npublic:\n    explicit PencilTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void drawStart(const CaptureContext&amp; context) override;\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_5a728c54be3df44fb5be2cd75280d106/","title":"Dir pin","text":"<p>FileList &gt; pin</p>"},{"location":"flameshot/dir_5a728c54be3df44fb5be2cd75280d106/#files","title":"Files","text":"Type Name file pintool.cpp file pintool.h file pinwidget.cpp file pinwidget.h"},{"location":"flameshot/pintool_8cpp/","title":"File pintool.cpp","text":"<p>FileList &gt; pin &gt; pintool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"pintool.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/tools/pin/pinwidget.h\"</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/pintool_8cpp_source/","title":"File pintool.cpp","text":"<p>File List &gt; pin &gt; pintool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"pintool.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/tools/pin/pinwidget.h\"\n#include &lt;QScreen&gt;\n\nPinTool::PinTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool PinTool::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon PinTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"pin.svg\");\n}\nQString PinTool::name() const\n{\n    return tr(\"Pin Tool\");\n}\n\nCaptureTool::Type PinTool::type() const\n{\n    return CaptureTool::TYPE_PIN;\n}\n\nQString PinTool::description() const\n{\n    return tr(\"Pin image on the desktop\");\n}\n\nCaptureTool* PinTool::copy(QObject* parent)\n{\n    return new PinTool(parent);\n}\n\nvoid PinTool::pressed(CaptureContext&amp; context)\n{\n    emit requestAction(REQ_CLEAR_SELECTION);\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    context.request.addTask(CaptureRequest::PIN);\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/pintool_8h/","title":"File pintool.h","text":"<p>FileList &gt; pin &gt; pintool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/pintool_8h/#classes","title":"Classes","text":"Type Name class PinTool"},{"location":"flameshot/pintool_8h_source/","title":"File pintool.h","text":"<p>File List &gt; pin &gt; pintool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass PinTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit PinTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n\nprivate:\n    QRect m_geometry;\n    QPixmap m_pixmap;\n};\n\n</code></pre>"},{"location":"flameshot/pinwidget_8cpp/","title":"File pinwidget.cpp","text":"<p>FileList &gt; pin &gt; pinwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QGraphicsDropShadowEffect&gt;</code></li> <li><code>#include &lt;QGraphicsOpacityEffect&gt;</code></li> <li><code>#include &lt;QPinchGesture&gt;</code></li> <li><code>#include \"pinwidget.h\"</code></li> <li><code>#include \"qguiappcurrentscreen.h\"</code></li> <li><code>#include \"screenshotsaver.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QMenu&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> <li><code>#include &lt;QShortcut&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> <li><code>#include &lt;QWheelEvent&gt;</code></li> </ul>"},{"location":"flameshot/pinwidget_8cpp_source/","title":"File pinwidget.cpp","text":"<p>File List &gt; pin &gt; pinwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n#include &lt;QGraphicsDropShadowEffect&gt;\n#include &lt;QGraphicsOpacityEffect&gt;\n#include &lt;QPinchGesture&gt;\n\n#include \"pinwidget.h\"\n#include \"qguiappcurrentscreen.h\"\n#include \"screenshotsaver.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n\n#include &lt;QLabel&gt;\n#include &lt;QMenu&gt;\n#include &lt;QScreen&gt;\n#include &lt;QShortcut&gt;\n#include &lt;QVBoxLayout&gt;\n#include &lt;QWheelEvent&gt;\n\nnamespace {\nconstexpr int MARGIN = 7;\nconstexpr int BLUR_RADIUS = 2 * MARGIN;\nconstexpr qreal STEP = 0.03;\nconstexpr qreal MIN_SIZE = 100.0;\n}\n\nPinWidget::PinWidget(const QPixmap&amp; pixmap,\n                     const QRect&amp; geometry,\n                     QWidget* parent)\n  : QWidget(parent)\n  , m_pixmap(pixmap)\n  , m_layout(new QVBoxLayout(this))\n  , m_label(new QLabel())\n  , m_shadowEffect(new QGraphicsDropShadowEffect(this))\n{\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint);\n    setFocusPolicy(Qt::StrongFocus);\n    // set the bottom widget background transparent\n    setAttribute(Qt::WA_TranslucentBackground);\n    setAttribute(Qt::WA_DeleteOnClose);\n    ConfigHandler conf;\n    m_baseColor = conf.uiColor();\n    m_hoverColor = conf.contrastUiColor();\n\n    m_layout-&gt;setContentsMargins(MARGIN, MARGIN, MARGIN, MARGIN);\n\n    m_shadowEffect-&gt;setColor(m_baseColor);\n    m_shadowEffect-&gt;setBlurRadius(BLUR_RADIUS);\n    m_shadowEffect-&gt;setOffset(0, 0);\n    setGraphicsEffect(m_shadowEffect);\n    setWindowOpacity(m_opacity);\n\n    m_label-&gt;setPixmap(m_pixmap);\n    m_layout-&gt;addWidget(m_label);\n\n    new QShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q), this, SLOT(close()));\n    new QShortcut(Qt::Key_Escape, this, SLOT(close()));\n\n    qreal devicePixelRatio = 1;\n#if defined(Q_OS_MACOS) || defined(Q_OS_LINUX)\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    if (currentScreen != nullptr) {\n        devicePixelRatio = currentScreen-&gt;devicePixelRatio();\n    }\n#endif\n    const int margin =\n      static_cast&lt;int&gt;(static_cast&lt;double&gt;(MARGIN) * devicePixelRatio);\n    QRect adjusted_pos = geometry + QMargins(margin, margin, margin, margin);\n    setGeometry(adjusted_pos);\n#if defined(Q_OS_LINUX)\n    setWindowFlags(Qt::X11BypassWindowManagerHint);\n#endif\n\n#if defined(Q_OS_MACOS) || defined(Q_OS_LINUX)\n    if (currentScreen != nullptr) {\n        QPoint topLeft = currentScreen-&gt;geometry().topLeft();\n        adjusted_pos.setX((adjusted_pos.x() - topLeft.x()) / devicePixelRatio +\n                          topLeft.x());\n\n        adjusted_pos.setY((adjusted_pos.y() - topLeft.y()) / devicePixelRatio +\n                          topLeft.y());\n        adjusted_pos.setWidth(adjusted_pos.size().width() / devicePixelRatio);\n        adjusted_pos.setHeight(adjusted_pos.size().height() / devicePixelRatio);\n        resize(0, 0);\n        move(adjusted_pos.x(), adjusted_pos.y());\n    }\n#endif\n    grabGesture(Qt::PinchGesture);\n\n    this-&gt;setContextMenuPolicy(Qt::CustomContextMenu);\n\n    connect(this,\n            &amp;QWidget::customContextMenuRequested,\n            this,\n            &amp;PinWidget::showContextMenu);\n}\n\nvoid PinWidget::closePin()\n{\n    update();\n    close();\n}\nbool PinWidget::scrollEvent(QWheelEvent* event)\n{\n    const auto phase = event-&gt;phase();\n    if (phase == Qt::ScrollPhase::ScrollUpdate\n#if defined(Q_OS_LINUX) || defined(Q_OS_WINDOWS)\n        // Linux is getting only NoScrollPhase events.\n        || phase == Qt::ScrollPhase::NoScrollPhase\n#endif\n    ) {\n        const auto angle = event-&gt;angleDelta();\n        if (angle.y() == 0) {\n            return true;\n        }\n        m_currentStepScaleFactor = angle.y() &gt; 0\n                                     ? m_currentStepScaleFactor + STEP\n                                     : m_currentStepScaleFactor - STEP;\n        m_expanding = m_currentStepScaleFactor &gt;= 1.0;\n    }\n#if defined(Q_OS_MACOS)\n    // ScrollEnd is currently supported only on Mac OSX\n    if (phase == Qt::ScrollPhase::ScrollEnd) {\n#else\n    else {\n#endif\n        m_scaleFactor *= m_currentStepScaleFactor;\n        m_currentStepScaleFactor = 1.0;\n        m_expanding = false;\n    }\n\n    m_sizeChanged = true;\n    update();\n    return true;\n}\n\nvoid PinWidget::enterEvent(QEvent*)\n{\n    m_shadowEffect-&gt;setColor(m_hoverColor);\n}\n\nvoid PinWidget::leaveEvent(QEvent*)\n{\n    m_shadowEffect-&gt;setColor(m_baseColor);\n}\n\nvoid PinWidget::mouseDoubleClickEvent(QMouseEvent*)\n{\n    closePin();\n}\n\nvoid PinWidget::mousePressEvent(QMouseEvent* e)\n{\n    m_dragStart = e-&gt;globalPos();\n    m_offsetX = e-&gt;localPos().x() / width();\n    m_offsetY = e-&gt;localPos().y() / height();\n}\n\nvoid PinWidget::mouseMoveEvent(QMouseEvent* e)\n{\n    const QPoint delta = e-&gt;globalPos() - m_dragStart;\n    const int offsetW = width() * m_offsetX;\n    const int offsetH = height() * m_offsetY;\n    move(m_dragStart.x() + delta.x() - offsetW,\n         m_dragStart.y() + delta.y() - offsetH);\n}\n\nvoid PinWidget::keyPressEvent(QKeyEvent* event)\n{\n    if (event-&gt;key() == Qt::Key_0) {\n        m_opacity = 1.0;\n    } else if (event-&gt;key() == Qt::Key_9) {\n        m_opacity = 0.9;\n    } else if (event-&gt;key() == Qt::Key_8) {\n        m_opacity = 0.8;\n    } else if (event-&gt;key() == Qt::Key_7) {\n        m_opacity = 0.7;\n    } else if (event-&gt;key() == Qt::Key_6) {\n        m_opacity = 0.6;\n    } else if (event-&gt;key() == Qt::Key_5) {\n        m_opacity = 0.5;\n    } else if (event-&gt;key() == Qt::Key_4) {\n        m_opacity = 0.4;\n    } else if (event-&gt;key() == Qt::Key_3) {\n        m_opacity = 0.3;\n    } else if (event-&gt;key() == Qt::Key_2) {\n        m_opacity = 0.2;\n    } else if (event-&gt;key() == Qt::Key_1) {\n        m_opacity = 0.1;\n    }\n\n    setWindowOpacity(m_opacity);\n}\nbool PinWidget::gestureEvent(QGestureEvent* event)\n{\n    if (QGesture* pinch = event-&gt;gesture(Qt::PinchGesture)) {\n        pinchTriggered(static_cast&lt;QPinchGesture*&gt;(pinch));\n    }\n    return true;\n}\n\nvoid PinWidget::rotateLeft()\n{\n    m_sizeChanged = true;\n\n    auto rotateTransform = QTransform().rotate(270);\n    m_pixmap = m_pixmap.transformed(rotateTransform);\n}\n\nvoid PinWidget::rotateRight()\n{\n    m_sizeChanged = true;\n\n    auto rotateTransform = QTransform().rotate(90);\n    m_pixmap = m_pixmap.transformed(rotateTransform);\n}\n\nvoid PinWidget::increaseOpacity()\n{\n    m_opacity += 0.1;\n    if (m_opacity &gt; 1.0) {\n        m_opacity = 1.0;\n    }\n    setWindowOpacity(m_opacity);\n}\n\nvoid PinWidget::decreaseOpacity()\n{\n    m_opacity -= 0.1;\n    if (m_opacity &lt; 0.0) {\n        m_opacity = 0.0;\n    }\n\n    setWindowOpacity(m_opacity);\n}\n\nbool PinWidget::event(QEvent* event)\n{\n    if (event-&gt;type() == QEvent::Gesture) {\n        return gestureEvent(static_cast&lt;QGestureEvent*&gt;(event));\n    } else if (event-&gt;type() == QEvent::Wheel) {\n        return scrollEvent(static_cast&lt;QWheelEvent*&gt;(event));\n    }\n    return QWidget::event(event);\n}\n\nvoid PinWidget::paintEvent(QPaintEvent* event)\n{\n    if (m_sizeChanged) {\n        const auto aspectRatio =\n          m_expanding ? Qt::KeepAspectRatioByExpanding : Qt::KeepAspectRatio;\n        const auto transformType = ConfigHandler().antialiasingPinZoom()\n                                     ? Qt::SmoothTransformation\n                                     : Qt::FastTransformation;\n        const qreal iw = m_pixmap.width();\n        const qreal ih = m_pixmap.height();\n        const qreal nw = qBound(MIN_SIZE,\n                                iw * m_currentStepScaleFactor * m_scaleFactor,\n                                static_cast&lt;qreal&gt;(maximumWidth()));\n        const qreal nh = qBound(MIN_SIZE,\n                                ih * m_currentStepScaleFactor * m_scaleFactor,\n                                static_cast&lt;qreal&gt;(maximumHeight()));\n\n        const QPixmap pix = m_pixmap.scaled(nw, nh, aspectRatio, transformType);\n\n        m_label-&gt;setPixmap(pix);\n        adjustSize();\n        m_sizeChanged = false;\n    }\n}\n\nvoid PinWidget::pinchTriggered(QPinchGesture* gesture)\n{\n    const QPinchGesture::ChangeFlags changeFlags = gesture-&gt;changeFlags();\n    if (changeFlags &amp; QPinchGesture::ScaleFactorChanged) {\n        m_currentStepScaleFactor = gesture-&gt;totalScaleFactor();\n        m_expanding = m_currentStepScaleFactor &gt; gesture-&gt;lastScaleFactor();\n    }\n    if (gesture-&gt;state() == Qt::GestureFinished) {\n        m_scaleFactor *= m_currentStepScaleFactor;\n        m_currentStepScaleFactor = 1;\n        m_expanding = false;\n    }\n    m_sizeChanged = true;\n    update();\n}\n\nvoid PinWidget::showContextMenu(const QPoint&amp; pos)\n{\n    QMenu contextMenu(tr(\"Context menu\"), this);\n\n    QAction copyToClipboardAction(tr(\"Copy to clipboard\"), this);\n    connect(&amp;copyToClipboardAction,\n            &amp;QAction::triggered,\n            this,\n            &amp;PinWidget::copyToClipboard);\n    contextMenu.addAction(&amp;copyToClipboardAction);\n\n    QAction saveToFileAction(tr(\"Save to file\"), this);\n    connect(\n      &amp;saveToFileAction, &amp;QAction::triggered, this, &amp;PinWidget::saveToFile);\n    contextMenu.addAction(&amp;saveToFileAction);\n\n    contextMenu.addSeparator();\n\n    QAction rotateRightAction(tr(\"Rotate Right\"), this);\n    connect(\n      &amp;rotateRightAction, &amp;QAction::triggered, this, &amp;PinWidget::rotateRight);\n    contextMenu.addAction(&amp;rotateRightAction);\n\n    QAction rotateLeftAction(tr(\"Rotate Left\"), this);\n    connect(\n      &amp;rotateLeftAction, &amp;QAction::triggered, this, &amp;PinWidget::rotateLeft);\n    contextMenu.addAction(&amp;rotateLeftAction);\n\n    QAction increaseOpacityAction(tr(\"Increase Opacity\"), this);\n    connect(&amp;increaseOpacityAction,\n            &amp;QAction::triggered,\n            this,\n            &amp;PinWidget::increaseOpacity);\n    contextMenu.addAction(&amp;increaseOpacityAction);\n\n    QAction decreaseOpacityAction(tr(\"Decrease Opacity\"), this);\n    connect(&amp;decreaseOpacityAction,\n            &amp;QAction::triggered,\n            this,\n            &amp;PinWidget::decreaseOpacity);\n    contextMenu.addAction(&amp;decreaseOpacityAction);\n\n    QAction closePinAction(tr(\"Close\"), this);\n    connect(&amp;closePinAction, &amp;QAction::triggered, this, &amp;PinWidget::closePin);\n    contextMenu.addSeparator();\n    contextMenu.addAction(&amp;closePinAction);\n\n    contextMenu.exec(mapToGlobal(pos));\n}\n\nvoid PinWidget::copyToClipboard()\n{\n    saveToClipboard(m_pixmap);\n}\nvoid PinWidget::saveToFile()\n{\n    hide();\n    saveToFilesystemGUI(m_pixmap);\n    show();\n}\n\n</code></pre>"},{"location":"flameshot/pinwidget_8h/","title":"File pinwidget.h","text":"<p>FileList &gt; pin &gt; pinwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/pinwidget_8h/#classes","title":"Classes","text":"Type Name class PinWidget"},{"location":"flameshot/pinwidget_8h_source/","title":"File pinwidget.h","text":"<p>File List &gt; pin &gt; pinwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass QLabel;\nclass QVBoxLayout;\nclass QGestureEvent;\nclass QPinchGesture;\nclass QGraphicsDropShadowEffect;\n\nclass PinWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit PinWidget(const QPixmap&amp; pixmap,\n                       const QRect&amp; geometry,\n                       QWidget* parent = nullptr);\n\nprotected:\n    void mouseDoubleClickEvent(QMouseEvent*) override;\n    void mousePressEvent(QMouseEvent*) override;\n    void mouseMoveEvent(QMouseEvent*) override;\n    void keyPressEvent(QKeyEvent*) override;\n    void enterEvent(QEvent*) override;\n    void leaveEvent(QEvent*) override;\n\n    bool event(QEvent* event) override;\n    void paintEvent(QPaintEvent* event) override;\n\nprivate:\n    bool gestureEvent(QGestureEvent* event);\n    bool scrollEvent(QWheelEvent* e);\n    void pinchTriggered(QPinchGesture*);\n    void closePin();\n\n    void rotateLeft();\n    void rotateRight();\n\n    void increaseOpacity();\n    void decreaseOpacity();\n\n    QPixmap m_pixmap;\n    QVBoxLayout* m_layout;\n    QLabel* m_label;\n    QPoint m_dragStart;\n    qreal m_offsetX{}, m_offsetY{};\n    QGraphicsDropShadowEffect* m_shadowEffect;\n    QColor m_baseColor, m_hoverColor;\n\n    bool m_expanding{ false };\n    qreal m_scaleFactor{ 1 };\n    qreal m_opacity{ 1 };\n    unsigned int m_rotateFactor{ 0 };\n    qreal m_currentStepScaleFactor{ 1 };\n    bool m_sizeChanged{ false };\n\nprivate slots:\n    void showContextMenu(const QPoint&amp; pos);\n    void copyToClipboard();\n    void saveToFile();\n};\n\n</code></pre>"},{"location":"flameshot/dir_1917b87740cdd44c073a6cb99e523447/","title":"Dir pixelate","text":"<p>FileList &gt; pixelate</p>"},{"location":"flameshot/dir_1917b87740cdd44c073a6cb99e523447/#files","title":"Files","text":"Type Name file pixelatetool.cpp file pixelatetool.h"},{"location":"flameshot/pixelatetool_8cpp/","title":"File pixelatetool.cpp","text":"<p>FileList &gt; pixelate &gt; pixelatetool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"pixelatetool.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QGraphicsBlurEffect&gt;</code></li> <li><code>#include &lt;QGraphicsPixmapItem&gt;</code></li> <li><code>#include &lt;QGraphicsScene&gt;</code></li> <li><code>#include &lt;QImage&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/pixelatetool_8cpp_source/","title":"File pixelatetool.cpp","text":"<p>File List &gt; pixelate &gt; pixelatetool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"pixelatetool.h\"\n#include &lt;QApplication&gt;\n#include &lt;QGraphicsBlurEffect&gt;\n#include &lt;QGraphicsPixmapItem&gt;\n#include &lt;QGraphicsScene&gt;\n#include &lt;QImage&gt;\n#include &lt;QPainter&gt;\n\nPixelateTool::PixelateTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{}\n\nQIcon PixelateTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"pixelate.svg\");\n}\n\nQString PixelateTool::name() const\n{\n    return tr(\"Pixelate\");\n}\n\nCaptureTool::Type PixelateTool::type() const\n{\n    return CaptureTool::TYPE_PIXELATE;\n}\n\nQString PixelateTool::description() const\n{\n    return tr(\"Set Pixelate as the paint tool\");\n}\n\nQRect PixelateTool::boundingRect() const\n{\n    return QRect(points().first, points().second).normalized();\n}\n\nCaptureTool* PixelateTool::copy(QObject* parent)\n{\n    auto* tool = new PixelateTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid PixelateTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    QRect selection = boundingRect().intersected(pixmap.rect());\n    auto pixelRatio = pixmap.devicePixelRatio();\n    QRect selectionScaled = QRect(selection.topLeft() * pixelRatio,\n                                  selection.bottomRight() * pixelRatio);\n\n    // If thickness is less than 1, use old blur process\n    if (size() &lt;= 1) {\n        auto* blur = new QGraphicsBlurEffect;\n        blur-&gt;setBlurRadius(10);\n        auto* item = new QGraphicsPixmapItem(pixmap.copy(selectionScaled));\n        item-&gt;setGraphicsEffect(blur);\n\n        QGraphicsScene scene;\n        scene.addItem(item);\n\n        scene.render(&amp;painter, selection, QRectF());\n        blur-&gt;setBlurRadius(12);\n        // multiple repeat for make blur effect stronger\n        scene.render(&amp;painter, selection, QRectF());\n\n    } else {\n        int width =\n          static_cast&lt;int&gt;(selection.width() * (0.5 / qMax(1, size() + 1)));\n        int height =\n          static_cast&lt;int&gt;(selection.height() * (0.5 / qMax(1, size() + 1)));\n        QSize size = QSize(qMax(width, 1), qMax(height, 1));\n\n        QPixmap t = pixmap.copy(selectionScaled);\n        t = t.scaled(size, Qt::IgnoreAspectRatio, Qt::SmoothTransformation);\n        t = t.scaled(selection.width(), selection.height());\n        painter.drawImage(selection, t.toImage());\n    }\n}\n\nvoid PixelateTool::drawSearchArea(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.fillRect(boundingRect(), QBrush(Qt::black));\n}\n\nvoid PixelateTool::paintMousePreview(QPainter&amp; painter,\n                                     const CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    Q_UNUSED(painter)\n}\n\nvoid PixelateTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/pixelatetool_8h/","title":"File pixelatetool.h","text":"<p>FileList &gt; pixelate &gt; pixelatetool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/pixelatetool_8h/#classes","title":"Classes","text":"Type Name class PixelateTool"},{"location":"flameshot/pixelatetool_8h_source/","title":"File pixelatetool.h","text":"<p>File List &gt; pixelate &gt; pixelatetool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass PixelateTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit PixelateTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n    QRect boundingRect() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void drawSearchArea(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_13d91df74e9cb3c514b017d500313e91/","title":"Dir rectangle","text":"<p>FileList &gt; rectangle</p>"},{"location":"flameshot/dir_13d91df74e9cb3c514b017d500313e91/#files","title":"Files","text":"Type Name file rectangletool.cpp file rectangletool.h"},{"location":"flameshot/rectangletool_8cpp/","title":"File rectangletool.cpp","text":"<p>FileList &gt; rectangle &gt; rectangletool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"rectangletool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPainterPath&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"flameshot/rectangletool_8cpp_source/","title":"File rectangletool.cpp","text":"<p>File List &gt; rectangle &gt; rectangletool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"rectangletool.h\"\n#include &lt;QPainter&gt;\n#include &lt;QPainterPath&gt;\n#include &lt;cmath&gt;\n\nRectangleTool::RectangleTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{\n    m_supportsDiagonalAdj = true;\n}\n\nQIcon RectangleTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"square.svg\");\n}\nQString RectangleTool::name() const\n{\n    return tr(\"Rectangle\");\n}\n\nCaptureTool::Type RectangleTool::type() const\n{\n    return CaptureTool::TYPE_RECTANGLE;\n}\n\nQString RectangleTool::description() const\n{\n    return tr(\"Set the Rectangle as the paint tool\");\n}\n\nCaptureTool* RectangleTool::copy(QObject* parent)\n{\n    auto* tool = new RectangleTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid RectangleTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    QPen orig_pen = painter.pen();\n    QBrush orig_brush = painter.brush();\n    painter.setPen(\n      QPen(color(), size(), Qt::SolidLine, Qt::SquareCap, Qt::RoundJoin));\n    painter.setBrush(QBrush(color()));\n    if (size() == 0) {\n        painter.drawRect(QRect(points().first, points().second));\n    } else {\n        QPainterPath path;\n        int offset =\n          size() &lt;= 1 ? 1 : static_cast&lt;int&gt;(round(size() / 2 + 0.5));\n        path.addRoundedRect(\n          QRectF(\n            std::min(points().first.x(), points().second.x()) - offset,\n            std::min(points().first.y(), points().second.y()) - offset,\n            std::abs(points().first.x() - points().second.x()) + offset * 2,\n            std::abs(points().first.y() - points().second.y()) + offset * 2),\n          size(),\n          size());\n        painter.fillPath(path, color());\n    }\n    painter.setPen(orig_pen);\n    painter.setBrush(orig_brush);\n}\n\nvoid RectangleTool::drawStart(const CaptureContext&amp; context)\n{\n    AbstractTwoPointTool::drawStart(context);\n    onSizeChanged(context.toolSize);\n}\n\nvoid RectangleTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/rectangletool_8h/","title":"File rectangletool.h","text":"<p>FileList &gt; rectangle &gt; rectangletool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/rectangletool_8h/#classes","title":"Classes","text":"Type Name class RectangleTool"},{"location":"flameshot/rectangletool_8h_source/","title":"File rectangletool.h","text":"<p>File List &gt; rectangle &gt; rectangletool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass RectangleTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit RectangleTool(QObject* parent = nullptr);\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void drawStart(const CaptureContext&amp; context) override;\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_1ff013da6731a496c5c20c595c3604d8/","title":"Dir redo","text":"<p>FileList &gt; redo</p>"},{"location":"flameshot/dir_1ff013da6731a496c5c20c595c3604d8/#files","title":"Files","text":"Type Name file redotool.cpp file redotool.h"},{"location":"flameshot/redotool_8cpp/","title":"File redotool.cpp","text":"<p>FileList &gt; redo &gt; redotool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"redotool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/redotool_8cpp_source/","title":"File redotool.cpp","text":"<p>File List &gt; redo &gt; redotool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"redotool.h\"\n#include &lt;QPainter&gt;\n\nRedoTool::RedoTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool RedoTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nQIcon RedoTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"redo-variant.svg\");\n}\nQString RedoTool::name() const\n{\n    return tr(\"Redo\");\n}\n\nCaptureTool::Type RedoTool::type() const\n{\n    return CaptureTool::TYPE_REDO;\n}\n\nQString RedoTool::description() const\n{\n    return tr(\"Redo the next modification\");\n}\n\nCaptureTool* RedoTool::copy(QObject* parent)\n{\n    return new RedoTool(parent);\n}\n\nvoid RedoTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    emit requestAction(REQ_REDO_MODIFICATION);\n}\n\n</code></pre>"},{"location":"flameshot/redotool_8h/","title":"File redotool.h","text":"<p>FileList &gt; redo &gt; redotool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/redotool_8h/#classes","title":"Classes","text":"Type Name class RedoTool"},{"location":"flameshot/redotool_8h_source/","title":"File redotool.h","text":"<p>File List &gt; redo &gt; redotool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass RedoTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit RedoTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_3c4a7bc90ef282c246ef9e2efd31c803/","title":"Dir save","text":"<p>FileList &gt; save</p>"},{"location":"flameshot/dir_3c4a7bc90ef282c246ef9e2efd31c803/#files","title":"Files","text":"Type Name file savetool.cpp file savetool.h"},{"location":"flameshot/savetool_8cpp/","title":"File savetool.cpp","text":"<p>FileList &gt; save &gt; savetool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"savetool.h\"</code></li> <li><code>#include \"src/utils/screenshotsaver.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/savetool_8cpp_source/","title":"File savetool.cpp","text":"<p>File List &gt; save &gt; savetool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"savetool.h\"\n#include \"src/utils/screenshotsaver.h\"\n#include &lt;QPainter&gt;\n\nSaveTool::SaveTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool SaveTool::closeOnButtonPressed() const\n{\n    return true;\n}\n\nQIcon SaveTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"content-save.svg\");\n}\nQString SaveTool::name() const\n{\n    return tr(\"Save\");\n}\n\nCaptureTool::Type SaveTool::type() const\n{\n    return CaptureTool::TYPE_SAVE;\n}\n\nQString SaveTool::description() const\n{\n    return tr(\"Save screenshot to a file\");\n}\n\nCaptureTool* SaveTool::copy(QObject* parent)\n{\n    return new SaveTool(parent);\n}\n\nvoid SaveTool::pressed(CaptureContext&amp; context)\n{\n    emit requestAction(REQ_CLEAR_SELECTION);\n    context.request.addSaveTask();\n    emit requestAction(REQ_CAPTURE_DONE_OK);\n    emit requestAction(REQ_CLOSE_GUI);\n}\n\n</code></pre>"},{"location":"flameshot/savetool_8h/","title":"File savetool.h","text":"<p>FileList &gt; save &gt; savetool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/savetool_8h/#classes","title":"Classes","text":"Type Name class SaveTool"},{"location":"flameshot/savetool_8h_source/","title":"File savetool.h","text":"<p>File List &gt; save &gt; savetool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass SaveTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit SaveTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_f9edf2c38a504f974175e7ed9752a343/","title":"Dir selection","text":"<p>FileList &gt; selection</p>"},{"location":"flameshot/dir_f9edf2c38a504f974175e7ed9752a343/#files","title":"Files","text":"Type Name file selectiontool.cpp file selectiontool.h"},{"location":"flameshot/selectiontool_8cpp/","title":"File selectiontool.cpp","text":"<p>FileList &gt; selection &gt; selectiontool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"selectiontool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/selectiontool_8cpp_source/","title":"File selectiontool.cpp","text":"<p>File List &gt; selection &gt; selectiontool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"selectiontool.h\"\n#include &lt;QPainter&gt;\n\nSelectionTool::SelectionTool(QObject* parent)\n  : AbstractTwoPointTool(parent)\n{\n    m_supportsDiagonalAdj = true;\n}\n\nbool SelectionTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nQIcon SelectionTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"square-outline.svg\");\n}\nQString SelectionTool::name() const\n{\n    return tr(\"Rectangular Selection\");\n}\n\nCaptureTool::Type SelectionTool::type() const\n{\n    return CaptureTool::TYPE_SELECTION;\n}\n\nQString SelectionTool::description() const\n{\n    return tr(\"Set Selection as the paint tool\");\n}\n\nCaptureTool* SelectionTool::copy(QObject* parent)\n{\n    auto* tool = new SelectionTool(parent);\n    copyParams(this, tool);\n    return tool;\n}\n\nvoid SelectionTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    painter.setPen(\n      QPen(color(), size(), Qt::SolidLine, Qt::SquareCap, Qt::MiterJoin));\n    painter.drawRect(QRect(points().first, points().second));\n}\n\nvoid SelectionTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\n</code></pre>"},{"location":"flameshot/selectiontool_8h/","title":"File selectiontool.h","text":"<p>FileList &gt; selection &gt; selectiontool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstracttwopointtool.h\"</code></li> </ul>"},{"location":"flameshot/selectiontool_8h/#classes","title":"Classes","text":"Type Name class SelectionTool"},{"location":"flameshot/selectiontool_8h_source/","title":"File selectiontool.h","text":"<p>File List &gt; selection &gt; selectiontool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstracttwopointtool.h\"\n\nclass SelectionTool : public AbstractTwoPointTool\n{\n    Q_OBJECT\npublic:\n    explicit SelectionTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_b0ea79cfc017f31af5ad5063fc901952/","title":"Dir sizedecrease","text":"<p>FileList &gt; sizedecrease</p>"},{"location":"flameshot/dir_b0ea79cfc017f31af5ad5063fc901952/#files","title":"Files","text":"Type Name file sizedecreasetool.cpp file sizedecreasetool.h"},{"location":"flameshot/sizedecreasetool_8cpp/","title":"File sizedecreasetool.cpp","text":"<p>FileList &gt; sizedecrease &gt; sizedecreasetool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"sizedecreasetool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/sizedecreasetool_8cpp_source/","title":"File sizedecreasetool.cpp","text":"<p>File List &gt; sizedecrease &gt; sizedecreasetool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// Copyright(c) 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n//\n// This file is part of Flameshot.\n//\n//     Flameshot is free software: you can redistribute it and/or modify\n//     it under the terms of the GNU General Public License as published by\n//     the Free Software Foundation, either version 3 of the License, or\n//     (at your option) any later version.\n//\n//     Flameshot is distributed in the hope that it will be useful,\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//     GNU General Public License for more details.\n//\n//     You should have received a copy of the GNU General Public License\n//     along with Flameshot.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n\n#include \"sizedecreasetool.h\"\n#include &lt;QPainter&gt;\n\nSizeDecreaseTool::SizeDecreaseTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool SizeDecreaseTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nQIcon SizeDecreaseTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"minus.svg\");\n}\nQString SizeDecreaseTool::name() const\n{\n    return tr(\"Decrease Tool Size\");\n}\n\nCaptureTool::Type SizeDecreaseTool::type() const\n{\n    return CaptureTool::TYPE_SIZEDECREASE;\n}\n\nQString SizeDecreaseTool::description() const\n{\n    return tr(\"Decrease the size of the other tools\");\n}\n\nCaptureTool* SizeDecreaseTool::copy(QObject* parent)\n{\n    return new SizeDecreaseTool(parent);\n}\n\nvoid SizeDecreaseTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    emit requestAction(REQ_DECREASE_TOOL_SIZE);\n}\n\n</code></pre>"},{"location":"flameshot/sizedecreasetool_8h/","title":"File sizedecreasetool.h","text":"<p>FileList &gt; sizedecrease &gt; sizedecreasetool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/sizedecreasetool_8h/#classes","title":"Classes","text":"Type Name class SizeDecreaseTool"},{"location":"flameshot/sizedecreasetool_8h_source/","title":"File sizedecreasetool.h","text":"<p>File List &gt; sizedecrease &gt; sizedecreasetool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// Copyright(c) 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n//\n// This file is part of Flameshot.\n//\n//     Flameshot is free software: you can redistribute it and/or modify\n//     it under the terms of the GNU General Public License as published by\n//     the Free Software Foundation, either version 3 of the License, or\n//     (at your option) any later version.\n//\n//     Flameshot is distributed in the hope that it will be useful,\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//     GNU General Public License for more details.\n//\n//     You should have received a copy of the GNU General Public License\n//     along with Flameshot.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass SizeDecreaseTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit SizeDecreaseTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_777de1af8ff1563507ac02c87d0e93ef/","title":"Dir sizeincrease","text":"<p>FileList &gt; sizeincrease</p>"},{"location":"flameshot/dir_777de1af8ff1563507ac02c87d0e93ef/#files","title":"Files","text":"Type Name file sizeincreasetool.cpp file sizeincreasetool.h"},{"location":"flameshot/sizeincreasetool_8cpp/","title":"File sizeincreasetool.cpp","text":"<p>FileList &gt; sizeincrease &gt; sizeincreasetool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"sizeincreasetool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/sizeincreasetool_8cpp_source/","title":"File sizeincreasetool.cpp","text":"<p>File List &gt; sizeincrease &gt; sizeincreasetool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// Copyright(c) 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n//\n// This file is part of Flameshot.\n//\n//     Flameshot is free software: you can redistribute it and/or modify\n//     it under the terms of the GNU General Public License as published by\n//     the Free Software Foundation, either version 3 of the License, or\n//     (at your option) any later version.\n//\n//     Flameshot is distributed in the hope that it will be useful,\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//     GNU General Public License for more details.\n//\n//     You should have received a copy of the GNU General Public License\n//     along with Flameshot.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n\n#include \"sizeincreasetool.h\"\n#include &lt;QPainter&gt;\n\nSizeIncreaseTool::SizeIncreaseTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool SizeIncreaseTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nQIcon SizeIncreaseTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"plus.svg\");\n}\nQString SizeIncreaseTool::name() const\n{\n    return tr(\"Increase Tool Size\");\n}\n\nCaptureTool::Type SizeIncreaseTool::type() const\n{\n    return CaptureTool::TYPE_SIZEINCREASE;\n}\n\nQString SizeIncreaseTool::description() const\n{\n    return tr(\"Increase the size of the other tools\");\n}\n\nCaptureTool* SizeIncreaseTool::copy(QObject* parent)\n{\n    return new SizeIncreaseTool(parent);\n}\n\nvoid SizeIncreaseTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    emit requestAction(REQ_INCREASE_TOOL_SIZE);\n}\n\n</code></pre>"},{"location":"flameshot/sizeincreasetool_8h/","title":"File sizeincreasetool.h","text":"<p>FileList &gt; sizeincrease &gt; sizeincreasetool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/sizeincreasetool_8h/#classes","title":"Classes","text":"Type Name class SizeIncreaseTool"},{"location":"flameshot/sizeincreasetool_8h_source/","title":"File sizeincreasetool.h","text":"<p>File List &gt; sizeincrease &gt; sizeincreasetool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// Copyright(c) 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n//\n// This file is part of Flameshot.\n//\n//     Flameshot is free software: you can redistribute it and/or modify\n//     it under the terms of the GNU General Public License as published by\n//     the Free Software Foundation, either version 3 of the License, or\n//     (at your option) any later version.\n//\n//     Flameshot is distributed in the hope that it will be useful,\n//     but WITHOUT ANY WARRANTY; without even the implied warranty of\n//     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n//     GNU General Public License for more details.\n//\n//     You should have received a copy of the GNU General Public License\n//     along with Flameshot.  If not, see &lt;http://www.gnu.org/licenses/&gt;.\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass SizeIncreaseTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit SizeIncreaseTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_f5021cd629193c5e75833314925eef7a/","title":"Dir text","text":"<p>FileList &gt; src &gt; tools &gt; text</p>"},{"location":"flameshot/dir_f5021cd629193c5e75833314925eef7a/#files","title":"Files","text":"Type Name file textconfig.cpp file textconfig.h file texttool.cpp file texttool.h file textwidget.cpp file textwidget.h"},{"location":"flameshot/textconfig_8cpp/","title":"File textconfig.cpp","text":"<p>FileList &gt; src &gt; tools &gt; text &gt; textconfig.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"textconfig.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/pathinfo.h\"</code></li> <li><code>#include &lt;QComboBox&gt;</code></li> <li><code>#include &lt;QFontDatabase&gt;</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> </ul>"},{"location":"flameshot/textconfig_8cpp_source/","title":"File textconfig.cpp","text":"<p>File List &gt; src &gt; tools &gt; text &gt; textconfig.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"textconfig.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/pathinfo.h\"\n#include &lt;QComboBox&gt;\n#include &lt;QFontDatabase&gt;\n#include &lt;QHBoxLayout&gt;\n#include &lt;QPushButton&gt;\n\nTextConfig::TextConfig(QWidget* parent)\n  : QWidget(parent)\n  , m_layout(new QVBoxLayout(this))\n  , m_fontsCB(new QComboBox())\n  , m_strikeOutButton(nullptr)\n  , m_underlineButton(nullptr)\n  , m_weightButton(nullptr)\n  , m_italicButton(nullptr)\n  , m_leftAlignButton(nullptr)\n  , m_centerAlignButton(nullptr)\n  , m_rightAlignButton(nullptr)\n{\n\n    QFontDatabase fontDB;\n\n    connect(m_fontsCB,\n            &amp;QComboBox::currentTextChanged,\n            this,\n            &amp;TextConfig::fontFamilyChanged);\n    m_fontsCB-&gt;addItems(fontDB.families());\n    setFontFamily(ConfigHandler().fontFamily());\n\n    QString iconPrefix = ColorUtils::colorIsDark(palette().windowText().color())\n                           ? PathInfo::blackIconPath()\n                           : PathInfo::whiteIconPath();\n\n    m_strikeOutButton = new QPushButton(\n      QIcon(iconPrefix + \"format_strikethrough.svg\"), QLatin1String(\"\"));\n    m_strikeOutButton-&gt;setCheckable(true);\n    connect(m_strikeOutButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;TextConfig::fontStrikeOutChanged);\n    m_strikeOutButton-&gt;setToolTip(tr(\"StrikeOut\"));\n\n    m_underlineButton = new QPushButton(\n      QIcon(iconPrefix + \"format_underlined.svg\"), QLatin1String(\"\"));\n    m_underlineButton-&gt;setCheckable(true);\n    connect(m_underlineButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;TextConfig::fontUnderlineChanged);\n    m_underlineButton-&gt;setToolTip(tr(\"Underline\"));\n\n    m_weightButton =\n      new QPushButton(QIcon(iconPrefix + \"format_bold.svg\"), QLatin1String(\"\"));\n    m_weightButton-&gt;setCheckable(true);\n    connect(m_weightButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;TextConfig::weightButtonPressed);\n    m_weightButton-&gt;setToolTip(tr(\"Bold\"));\n\n    m_italicButton = new QPushButton(QIcon(iconPrefix + \"format_italic.svg\"),\n                                     QLatin1String(\"\"));\n    m_italicButton-&gt;setCheckable(true);\n    connect(m_italicButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;TextConfig::fontItalicChanged);\n    m_italicButton-&gt;setToolTip(tr(\"Italic\"));\n    auto* modifiersLayout = new QHBoxLayout();\n\n    m_leftAlignButton =\n      new QPushButton(QIcon(iconPrefix + \"leftalign.svg\"), QLatin1String(\"\"));\n    m_leftAlignButton-&gt;setCheckable(true);\n    m_leftAlignButton-&gt;setAutoExclusive(true);\n    connect(m_leftAlignButton, &amp;QPushButton::clicked, this, [this] {\n        alignmentChanged(Qt::AlignLeft);\n    });\n    m_leftAlignButton-&gt;setToolTip(tr(\"Left Align\"));\n\n    m_centerAlignButton =\n      new QPushButton(QIcon(iconPrefix + \"centeralign.svg\"), QLatin1String(\"\"));\n    m_centerAlignButton-&gt;setCheckable(true);\n    m_centerAlignButton-&gt;setAutoExclusive(true);\n    connect(m_centerAlignButton, &amp;QPushButton::clicked, this, [this] {\n        alignmentChanged(Qt::AlignCenter);\n    });\n    m_centerAlignButton-&gt;setToolTip(tr(\"Center Align\"));\n\n    m_rightAlignButton =\n      new QPushButton(QIcon(iconPrefix + \"rightalign.svg\"), QLatin1String(\"\"));\n    m_rightAlignButton-&gt;setCheckable(true);\n    m_rightAlignButton-&gt;setAutoExclusive(true);\n    connect(m_rightAlignButton, &amp;QPushButton::clicked, this, [this] {\n        alignmentChanged(Qt::AlignRight);\n    });\n    m_rightAlignButton-&gt;setToolTip(tr(\"Right Align\"));\n\n    auto* alignmentLayout = new QHBoxLayout();\n    alignmentLayout-&gt;addWidget(m_leftAlignButton);\n    alignmentLayout-&gt;addWidget(m_centerAlignButton);\n    alignmentLayout-&gt;addWidget(m_rightAlignButton);\n\n    m_layout-&gt;addWidget(m_fontsCB);\n    modifiersLayout-&gt;addWidget(m_strikeOutButton);\n    modifiersLayout-&gt;addWidget(m_underlineButton);\n    modifiersLayout-&gt;addWidget(m_weightButton);\n    modifiersLayout-&gt;addWidget(m_italicButton);\n    m_layout-&gt;addLayout(modifiersLayout);\n    m_layout-&gt;addLayout(alignmentLayout);\n}\n\nvoid TextConfig::setFontFamily(const QString&amp; fontFamily)\n{\n    m_fontsCB-&gt;setCurrentIndex(\n      m_fontsCB-&gt;findText(fontFamily.isEmpty() ? font().family() : fontFamily));\n}\n\nvoid TextConfig::setUnderline(const bool underline)\n{\n    m_underlineButton-&gt;setChecked(underline);\n}\n\nvoid TextConfig::setStrikeOut(const bool strikeout)\n{\n    m_strikeOutButton-&gt;setChecked(strikeout);\n}\n\nvoid TextConfig::setWeight(const int weight)\n{\n    m_weightButton-&gt;setChecked(static_cast&lt;QFont::Weight&gt;(weight) ==\n                               QFont::Bold);\n}\n\nvoid TextConfig::setItalic(const bool italic)\n{\n    m_italicButton-&gt;setChecked(italic);\n}\n\nvoid TextConfig::weightButtonPressed(const bool weight)\n{\n    if (weight) {\n        emit fontWeightChanged(QFont::Bold);\n    } else {\n        emit fontWeightChanged(QFont::Normal);\n    }\n}\n\nvoid TextConfig::setTextAlignment(Qt::AlignmentFlag alignment)\n{\n    switch (alignment) {\n        case (Qt::AlignCenter):\n            m_leftAlignButton-&gt;setChecked(false);\n            m_centerAlignButton-&gt;setChecked(true);\n            m_rightAlignButton-&gt;setChecked(false);\n            break;\n        case (Qt::AlignRight):\n            m_leftAlignButton-&gt;setChecked(false);\n            m_centerAlignButton-&gt;setChecked(false);\n            m_rightAlignButton-&gt;setChecked(true);\n            break;\n        case (Qt::AlignLeft):\n        default:\n            m_leftAlignButton-&gt;setChecked(true);\n            m_centerAlignButton-&gt;setChecked(false);\n            m_rightAlignButton-&gt;setChecked(false);\n            break;\n    }\n    emit alignmentChanged(alignment);\n}\n\n</code></pre>"},{"location":"flameshot/textconfig_8h/","title":"File textconfig.h","text":"<p>FileList &gt; src &gt; tools &gt; text &gt; textconfig.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/textconfig_8h/#classes","title":"Classes","text":"Type Name class TextConfig"},{"location":"flameshot/textconfig_8h_source/","title":"File textconfig.h","text":"<p>File List &gt; src &gt; tools &gt; text &gt; textconfig.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass QVBoxLayout;\nclass QPushButton;\nclass QComboBox;\n\nclass TextConfig : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit TextConfig(QWidget* parent = nullptr);\n\n    void setFontFamily(const QString&amp; fontFamily);\n    void setUnderline(bool underline);\n    void setStrikeOut(bool strikeout);\n    void setWeight(int weight);\n    void setItalic(bool italic);\n    void setTextAlignment(Qt::AlignmentFlag alignment);\n\nsignals:\n    void fontFamilyChanged(const QString&amp; f);\n    void fontUnderlineChanged(const bool underlined);\n    void fontStrikeOutChanged(const bool dashed);\n    void fontWeightChanged(const QFont::Weight w);\n    void fontItalicChanged(const bool italic);\n    void alignmentChanged(Qt::AlignmentFlag alignment);\npublic slots:\n\nprivate slots:\n    void weightButtonPressed(bool weight);\n\nprivate:\n    QVBoxLayout* m_layout;\n    QComboBox* m_fontsCB;\n    QPushButton* m_strikeOutButton;\n    QPushButton* m_underlineButton;\n    QPushButton* m_weightButton;\n    QPushButton* m_italicButton;\n\n    QPushButton* m_leftAlignButton;\n    QPushButton* m_centerAlignButton;\n    QPushButton* m_rightAlignButton;\n};\n\n</code></pre>"},{"location":"flameshot/texttool_8cpp/","title":"File texttool.cpp","text":"<p>FileList &gt; src &gt; tools &gt; text &gt; texttool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"texttool.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"textconfig.h\"</code></li> <li><code>#include \"textwidget.h\"</code></li> </ul>"},{"location":"flameshot/texttool_8cpp/#macros","title":"Macros","text":"Type Name define BASE_POINT_SIZE  8 define MAX_INFO_LENGTH  24"},{"location":"flameshot/texttool_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/texttool_8cpp/#define-base_point_size","title":"define BASE_POINT_SIZE","text":"<pre><code>#define BASE_POINT_SIZE 8\n</code></pre>"},{"location":"flameshot/texttool_8cpp/#define-max_info_length","title":"define MAX_INFO_LENGTH","text":"<pre><code>#define MAX_INFO_LENGTH 24\n</code></pre>"},{"location":"flameshot/texttool_8cpp_source/","title":"File texttool.cpp","text":"<p>File List &gt; src &gt; tools &gt; text &gt; texttool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"texttool.h\"\n#include \"src/utils/confighandler.h\"\n#include \"textconfig.h\"\n#include \"textwidget.h\"\n\n#define BASE_POINT_SIZE 8\n#define MAX_INFO_LENGTH 24\n\nTextTool::TextTool(QObject* parent)\n  : CaptureTool(parent)\n  , m_size(1)\n{\n    QString fontFamily = ConfigHandler().fontFamily();\n    if (!fontFamily.isEmpty()) {\n        m_font.setFamily(ConfigHandler().fontFamily());\n    }\n    m_alignment = Qt::AlignLeft;\n}\n\nTextTool::~TextTool()\n{\n    closeEditor();\n}\n\nvoid TextTool::copyParams(const TextTool* from, TextTool* to)\n{\n    CaptureTool::copyParams(from, to);\n    to-&gt;m_font = from-&gt;m_font;\n    to-&gt;m_alignment = from-&gt;m_alignment;\n    to-&gt;m_text = from-&gt;m_text;\n    to-&gt;m_size = from-&gt;m_size;\n    to-&gt;m_color = from-&gt;m_color;\n    to-&gt;m_textArea = from-&gt;m_textArea;\n    to-&gt;m_currentPos = from-&gt;m_currentPos;\n}\n\nbool TextTool::isValid() const\n{\n    return !m_text.isEmpty();\n}\n\nbool TextTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nbool TextTool::isSelectable() const\n{\n    return true;\n}\n\nbool TextTool::showMousePreview() const\n{\n    return false;\n}\n\nQRect TextTool::boundingRect() const\n{\n    return m_textArea;\n}\n\nQIcon TextTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"text.svg\");\n}\n\nQString TextTool::name() const\n{\n    return tr(\"Text\");\n}\n\nQString TextTool::info()\n{\n    if (m_text.length() &gt; 0) {\n        m_tempString = QString(\"%1 - %2\").arg(name()).arg(m_text.trimmed());\n        m_tempString = m_tempString.split(\"\\n\").at(0);\n        if (m_tempString.length() &gt; MAX_INFO_LENGTH) {\n            m_tempString.truncate(MAX_INFO_LENGTH);\n            m_tempString += \"\u2026\";\n        }\n        return m_tempString;\n    }\n    return name();\n}\n\nCaptureTool::Type TextTool::type() const\n{\n    return CaptureTool::TYPE_TEXT;\n}\n\nQString TextTool::description() const\n{\n    return tr(\"Add text to your capture\");\n}\n\nQWidget* TextTool::widget()\n{\n    closeEditor();\n    m_widget = new TextWidget();\n    m_widget-&gt;setTextColor(m_color);\n    m_font.setPointSize(m_size + BASE_POINT_SIZE);\n    m_widget-&gt;setFont(m_font);\n    m_widget-&gt;setAlignment(m_alignment);\n    m_widget-&gt;setText(m_text);\n    m_widget-&gt;selectAll();\n    connect(m_widget, &amp;TextWidget::textUpdated, this, &amp;TextTool::updateText);\n    return m_widget;\n}\n\nvoid TextTool::closeEditor()\n{\n    if (!m_widget.isNull()) {\n        m_widget-&gt;hide();\n        delete m_widget;\n        m_widget = nullptr;\n    }\n    if (!m_confW.isNull()) {\n        m_confW-&gt;hide();\n        delete m_confW;\n        m_confW = nullptr;\n    }\n}\n\nQWidget* TextTool::configurationWidget()\n{\n    m_confW = new TextConfig();\n    connect(\n      m_confW, &amp;TextConfig::fontFamilyChanged, this, &amp;TextTool::updateFamily);\n    connect(m_confW,\n            &amp;TextConfig::fontItalicChanged,\n            this,\n            &amp;TextTool::updateFontItalic);\n    connect(m_confW,\n            &amp;TextConfig::fontStrikeOutChanged,\n            this,\n            &amp;TextTool::updateFontStrikeOut);\n    connect(m_confW,\n            &amp;TextConfig::fontUnderlineChanged,\n            this,\n            &amp;TextTool::updateFontUnderline);\n    connect(m_confW,\n            &amp;TextConfig::fontWeightChanged,\n            this,\n            &amp;TextTool::updateFontWeight);\n\n    connect(\n      m_confW, &amp;TextConfig::alignmentChanged, this, &amp;TextTool::updateAlignment);\n\n    m_confW-&gt;setFontFamily(m_font.family());\n    m_confW-&gt;setItalic(m_font.italic());\n    m_confW-&gt;setUnderline(m_font.underline());\n    m_confW-&gt;setStrikeOut(m_font.strikeOut());\n    m_confW-&gt;setWeight(m_font.weight());\n    m_confW-&gt;setTextAlignment(m_alignment);\n    return m_confW;\n}\n\nCaptureTool* TextTool::copy(QObject* parent)\n{\n    auto* textTool = new TextTool(parent);\n    if (m_confW != nullptr) {\n        connect(m_confW,\n                &amp;TextConfig::fontFamilyChanged,\n                textTool,\n                &amp;TextTool::updateFamily);\n        connect(m_confW,\n                &amp;TextConfig::fontItalicChanged,\n                textTool,\n                &amp;TextTool::updateFontItalic);\n        connect(m_confW,\n                &amp;TextConfig::fontStrikeOutChanged,\n                textTool,\n                &amp;TextTool::updateFontStrikeOut);\n        connect(m_confW,\n                &amp;TextConfig::fontUnderlineChanged,\n                textTool,\n                &amp;TextTool::updateFontUnderline);\n        connect(m_confW,\n                &amp;TextConfig::fontWeightChanged,\n                textTool,\n                &amp;TextTool::updateFontWeight);\n\n        connect(m_confW,\n                &amp;TextConfig::alignmentChanged,\n                textTool,\n                &amp;TextTool::updateAlignment);\n    }\n    copyParams(this, textTool);\n    return textTool;\n}\n\nvoid TextTool::process(QPainter&amp; painter, const QPixmap&amp; pixmap)\n{\n    Q_UNUSED(pixmap)\n    if (m_text.isEmpty()) {\n        return;\n    }\n    const int val = 5;\n    QFont orig_font = painter.font();\n    QPen orig_pen = painter.pen();\n    QFontMetrics fm(m_font);\n    QSize fontsize(fm.boundingRect(QRect(), 0, m_text).size());\n    fontsize.setWidth(fontsize.width() + val * 2);\n    fontsize.setHeight(fontsize.height() + val * 2);\n    m_textArea.setSize(fontsize);\n    // draw text\n    painter.setFont(m_font);\n    painter.setPen(m_color);\n    if (!editMode()) {\n        painter.drawText(\n          m_textArea + QMargins(-val, -val, val, val), m_alignment, m_text);\n    }\n    painter.setFont(orig_font);\n    painter.setPen(orig_pen);\n\n    if (m_widget != nullptr) {\n        m_widget-&gt;setAlignment(m_alignment);\n    }\n}\n\nvoid TextTool::drawObjectSelection(QPainter&amp; painter)\n{\n    if (m_text.isEmpty()) {\n        return;\n    }\n    drawObjectSelectionRect(painter, boundingRect());\n}\n\nvoid TextTool::paintMousePreview(QPainter&amp; painter,\n                                 const CaptureContext&amp; context)\n{\n    Q_UNUSED(painter)\n    Q_UNUSED(context)\n}\n\nvoid TextTool::drawEnd(const QPoint&amp; point)\n{\n    m_textArea.moveTo(point);\n}\n\nvoid TextTool::drawMove(const QPoint&amp; point)\n{\n    m_widget-&gt;move(point);\n}\n\nvoid TextTool::drawStart(const CaptureContext&amp; context)\n{\n    m_color = context.color;\n    m_size = context.toolSize;\n    emit requestAction(REQ_ADD_CHILD_WIDGET);\n}\n\nvoid TextTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n}\n\nvoid TextTool::onColorChanged(const QColor&amp; color)\n{\n    m_color = color;\n    if (m_widget != nullptr) {\n        m_widget-&gt;setTextColor(color);\n    }\n}\n\nvoid TextTool::onSizeChanged(int size)\n{\n    m_size = size;\n    m_font.setPointSize(m_size + BASE_POINT_SIZE);\n    if (m_widget != nullptr) {\n        m_widget-&gt;setFont(m_font);\n    }\n}\n\nvoid TextTool::updateText(const QString&amp; newText)\n{\n    m_text = newText;\n}\n\nvoid TextTool::updateFamily(const QString&amp; text)\n{\n    m_font.setFamily(text);\n    if (m_textOld.isEmpty()) {\n        ConfigHandler().setFontFamily(m_font.family());\n    }\n    if (m_widget != nullptr) {\n        m_widget-&gt;setFont(m_font);\n    }\n}\n\nvoid TextTool::updateFontUnderline(const bool underlined)\n{\n    m_font.setUnderline(underlined);\n    if (m_widget != nullptr) {\n        m_widget-&gt;setFont(m_font);\n    }\n}\n\nvoid TextTool::updateFontStrikeOut(const bool strikeout)\n{\n    m_font.setStrikeOut(strikeout);\n    if (m_widget != nullptr) {\n        m_widget-&gt;setFont(m_font);\n    }\n}\n\nvoid TextTool::updateFontWeight(const QFont::Weight weight)\n{\n    m_font.setWeight(weight);\n    if (m_widget != nullptr) {\n        m_widget-&gt;setFont(m_font);\n    }\n}\n\nvoid TextTool::updateFontItalic(const bool italic)\n{\n    m_font.setItalic(italic);\n    if (m_widget != nullptr) {\n        m_widget-&gt;setFont(m_font);\n    }\n}\n\nvoid TextTool::move(const QPoint&amp; pos)\n{\n    m_textArea.moveTo(pos);\n}\n\nvoid TextTool::updateAlignment(Qt::AlignmentFlag alignment)\n{\n    m_alignment = alignment;\n    if (m_widget != nullptr) {\n        m_widget-&gt;setAlignment(m_alignment);\n    }\n}\n\nconst QPoint* TextTool::pos()\n{\n    m_currentPos = m_textArea.topLeft();\n    return &amp;m_currentPos;\n}\n\nvoid TextTool::setEditMode(bool editMode)\n{\n    if (editMode) {\n        m_textOld = m_text;\n    }\n    CaptureTool::setEditMode(editMode);\n}\n\nbool TextTool::isChanged()\n{\n    return QString::compare(m_text, m_textOld, Qt::CaseInsensitive) != 0;\n}\n\n</code></pre>"},{"location":"flameshot/texttool_8h/","title":"File texttool.h","text":"<p>FileList &gt; src &gt; tools &gt; text &gt; texttool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include \"textconfig.h\"</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QPointer&gt;</code></li> </ul>"},{"location":"flameshot/texttool_8h/#classes","title":"Classes","text":"Type Name class TextTool"},{"location":"flameshot/texttool_8h_source/","title":"File texttool.h","text":"<p>File List &gt; src &gt; tools &gt; text &gt; texttool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/capturetool.h\"\n#include \"textconfig.h\"\n#include &lt;QPoint&gt;\n#include &lt;QPointer&gt;\nclass TextWidget;\nclass TextConfig;\n\nclass TextTool : public CaptureTool\n{\n    Q_OBJECT\npublic:\n    explicit TextTool(QObject* parent = nullptr);\n    ~TextTool() override;\n\n    [[nodiscard]] bool isValid() const override;\n    [[nodiscard]] bool closeOnButtonPressed() const override;\n    [[nodiscard]] bool isSelectable() const override;\n    [[nodiscard]] bool showMousePreview() const override;\n    [[nodiscard]] QRect boundingRect() const override;\n\n    [[nodiscard]] QIcon icon(const QColor&amp; background,\n                             bool inEditor) const override;\n    [[nodiscard]] QString name() const override;\n    [[nodiscard]] QString description() const override;\n    QString info() override;\n\n    QWidget* widget() override;\n    QWidget* configurationWidget() override;\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\n    void process(QPainter&amp; painter, const QPixmap&amp; pixmap) override;\n    void paintMousePreview(QPainter&amp; painter,\n                           const CaptureContext&amp; context) override;\n    void move(const QPoint&amp; pos) override;\n    const QPoint* pos() override;\n    void drawObjectSelection(QPainter&amp; painter) override;\n\n    void setEditMode(bool editMode) override;\n    bool isChanged() override;\n\nprotected:\n    void copyParams(const TextTool* from, TextTool* to);\n    [[nodiscard]] CaptureTool::Type type() const override;\n\npublic slots:\n    void drawEnd(const QPoint&amp; point) override;\n    void drawMove(const QPoint&amp; point) override;\n    void drawStart(const CaptureContext&amp; context) override;\n    void pressed(CaptureContext&amp; context) override;\n    void onColorChanged(const QColor&amp; color) override;\n    void onSizeChanged(int size) override;\n    int size() const override { return m_size; };\n\nprivate slots:\n    void updateText(const QString&amp; string);\n    void updateFamily(const QString&amp; string);\n    void updateFontUnderline(bool underlined);\n    void updateFontStrikeOut(bool strikeout);\n    void updateFontWeight(QFont::Weight weight);\n    void updateFontItalic(bool italic);\n    void updateAlignment(Qt::AlignmentFlag alignment);\n\nprivate:\n    void closeEditor();\n\n    QFont m_font;\n    Qt::AlignmentFlag m_alignment;\n    QString m_text;\n    QString m_textOld;\n    int m_size;\n    QColor m_color;\n    QRect m_textArea;\n    QPointer&lt;TextWidget&gt; m_widget;\n    QPointer&lt;TextConfig&gt; m_confW;\n    QPoint m_currentPos;\n\n    QString m_tempString;\n};\n\n</code></pre>"},{"location":"flameshot/textwidget_8cpp/","title":"File textwidget.cpp","text":"<p>FileList &gt; src &gt; tools &gt; text &gt; textwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"textwidget.h\"</code></li> </ul>"},{"location":"flameshot/textwidget_8cpp_source/","title":"File textwidget.cpp","text":"<p>File List &gt; src &gt; tools &gt; text &gt; textwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"textwidget.h\"\n\nTextWidget::TextWidget(QWidget* parent)\n  : QTextEdit(parent)\n{\n    setStyleSheet(QStringLiteral(\"TextWidget { background: transparent; }\"));\n    connect(this, &amp;TextWidget::textChanged, this, &amp;TextWidget::adjustSize);\n    connect(this, &amp;TextWidget::textChanged, this, &amp;TextWidget::emitTextUpdated);\n    setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n    setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\n    setContextMenuPolicy(Qt::NoContextMenu);\n}\n\nvoid TextWidget::showEvent(QShowEvent* e)\n{\n    QFont font;\n    QFontMetrics fm(font);\n    setFixedWidth(fm.lineSpacing() * 6);\n    setFixedHeight(fm.lineSpacing() * 2.5);\n    m_baseSize = size();\n    m_minSize = m_baseSize;\n    QTextEdit::showEvent(e);\n    adjustSize();\n}\n\nvoid TextWidget::resizeEvent(QResizeEvent* e)\n{\n    m_minSize.setHeight(qMin(m_baseSize.height(), height()));\n    m_minSize.setWidth(qMin(m_baseSize.width(), width()));\n    QTextEdit::resizeEvent(e);\n}\n\nvoid TextWidget::setFont(const QFont&amp; f)\n{\n    QTextEdit::setFont(f);\n    adjustSize();\n}\n\nvoid TextWidget::setAlignment(Qt::AlignmentFlag alignment)\n{\n    QTextEdit::setAlignment(alignment);\n    adjustSize();\n}\nvoid TextWidget::setTextColor(const QColor&amp; c)\n{\n    QString s(\n      QStringLiteral(\"TextWidget { background: transparent; color: %1; }\"));\n    setStyleSheet(s.arg(c.name()));\n}\n\nvoid TextWidget::adjustSize()\n{\n    QString&amp;&amp; text = this-&gt;toPlainText();\n\n    QFontMetrics fm(font());\n    QRect bounds = fm.boundingRect(QRect(), 0, text);\n    int pixelsWide = bounds.width() + fm.lineSpacing();\n    int pixelsHigh = bounds.height() * 1.15 + fm.lineSpacing();\n    if (pixelsWide &lt; m_minSize.width()) {\n        pixelsWide = m_minSize.width();\n    }\n    if (pixelsHigh &lt; m_minSize.height()) {\n        pixelsHigh = m_minSize.height();\n    }\n\n    this-&gt;setFixedSize(pixelsWide, pixelsHigh);\n}\n\nvoid TextWidget::emitTextUpdated()\n{\n    emit textUpdated(this-&gt;toPlainText());\n}\n\n</code></pre>"},{"location":"flameshot/textwidget_8h/","title":"File textwidget.h","text":"<p>FileList &gt; src &gt; tools &gt; text &gt; textwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QTextEdit&gt;</code></li> </ul>"},{"location":"flameshot/textwidget_8h/#classes","title":"Classes","text":"Type Name class TextWidget"},{"location":"flameshot/textwidget_8h_source/","title":"File textwidget.h","text":"<p>File List &gt; src &gt; tools &gt; text &gt; textwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QTextEdit&gt;\n\nclass TextWidget : public QTextEdit\n{\n    Q_OBJECT\npublic:\n    explicit TextWidget(QWidget* parent = nullptr);\n\n    void adjustSize();\n    void setFont(const QFont&amp; f);\n\nprotected:\n    void showEvent(QShowEvent* e);\n    void resizeEvent(QResizeEvent* e);\n\nsignals:\n    void textUpdated(const QString&amp; s);\n\npublic slots:\n    void setTextColor(const QColor&amp; c);\n    void setAlignment(Qt::AlignmentFlag alignment);\n\nprivate slots:\n    void emitTextUpdated();\n\nprivate:\n    QSize m_baseSize;\n    QSize m_minSize;\n};\n\n</code></pre>"},{"location":"flameshot/toolfactory_8cpp/","title":"File toolfactory.cpp","text":"<p>FileList &gt; src &gt; tools &gt; toolfactory.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"toolfactory.h\"</code></li> <li><code>#include \"accept/accepttool.h\"</code></li> <li><code>#include \"arrow/arrowtool.h\"</code></li> <li><code>#include \"circle/circletool.h\"</code></li> <li><code>#include \"circlecount/circlecounttool.h\"</code></li> <li><code>#include \"copy/copytool.h\"</code></li> <li><code>#include \"exit/exittool.h\"</code></li> <li><code>#include \"imgupload/imguploadertool.h\"</code></li> <li><code>#include \"invert/inverttool.h\"</code></li> <li><code>#include \"launcher/applaunchertool.h\"</code></li> <li><code>#include \"line/linetool.h\"</code></li> <li><code>#include \"marker/markertool.h\"</code></li> <li><code>#include \"move/movetool.h\"</code></li> <li><code>#include \"pencil/penciltool.h\"</code></li> <li><code>#include \"pin/pintool.h\"</code></li> <li><code>#include \"pixelate/pixelatetool.h\"</code></li> <li><code>#include \"rectangle/rectangletool.h\"</code></li> <li><code>#include \"redo/redotool.h\"</code></li> <li><code>#include \"save/savetool.h\"</code></li> <li><code>#include \"selection/selectiontool.h\"</code></li> <li><code>#include \"sizedecrease/sizedecreasetool.h\"</code></li> <li><code>#include \"sizeincrease/sizeincreasetool.h\"</code></li> <li><code>#include \"text/texttool.h\"</code></li> <li><code>#include \"undo/undotool.h\"</code></li> </ul>"},{"location":"flameshot/toolfactory_8cpp/#macros","title":"Macros","text":"Type Name define if_TYPE_return_TOOL (TYPE, TOOL)"},{"location":"flameshot/toolfactory_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/toolfactory_8cpp/#define-if_type_return_tool","title":"define if_TYPE_return_TOOL","text":"<pre><code>#define if_TYPE_return_TOOL (\n    TYPE,\n    TOOL\n) case CaptureTool::TYPE:                                                    \\\n        return new TOOL(parent)\n</code></pre>"},{"location":"flameshot/toolfactory_8cpp_source/","title":"File toolfactory.cpp","text":"<p>File List &gt; src &gt; tools &gt; toolfactory.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"toolfactory.h\"\n#include \"accept/accepttool.h\"\n#include \"arrow/arrowtool.h\"\n#include \"circle/circletool.h\"\n#include \"circlecount/circlecounttool.h\"\n#include \"copy/copytool.h\"\n#include \"exit/exittool.h\"\n#include \"imgupload/imguploadertool.h\"\n#include \"invert/inverttool.h\"\n#include \"launcher/applaunchertool.h\"\n#include \"line/linetool.h\"\n#include \"marker/markertool.h\"\n#include \"move/movetool.h\"\n#include \"pencil/penciltool.h\"\n#include \"pin/pintool.h\"\n#include \"pixelate/pixelatetool.h\"\n#include \"rectangle/rectangletool.h\"\n#include \"redo/redotool.h\"\n#include \"save/savetool.h\"\n#include \"selection/selectiontool.h\"\n#include \"sizedecrease/sizedecreasetool.h\"\n#include \"sizeincrease/sizeincreasetool.h\"\n#include \"text/texttool.h\"\n#include \"undo/undotool.h\"\n\nToolFactory::ToolFactory(QObject* parent)\n  : QObject(parent)\n{}\n\nCaptureTool* ToolFactory::CreateTool(CaptureTool::Type t, QObject* parent)\n{\n#define if_TYPE_return_TOOL(TYPE, TOOL)                                        \\\n    case CaptureTool::TYPE:                                                    \\\n        return new TOOL(parent)\n\n    switch (t) {\n        if_TYPE_return_TOOL(TYPE_PENCIL, PencilTool);\n        if_TYPE_return_TOOL(TYPE_DRAWER, LineTool);\n        if_TYPE_return_TOOL(TYPE_ARROW, ArrowTool);\n        if_TYPE_return_TOOL(TYPE_SELECTION, SelectionTool);\n        if_TYPE_return_TOOL(TYPE_RECTANGLE, RectangleTool);\n        if_TYPE_return_TOOL(TYPE_CIRCLE, CircleTool);\n        if_TYPE_return_TOOL(TYPE_MARKER, MarkerTool);\n        if_TYPE_return_TOOL(TYPE_MOVESELECTION, MoveTool);\n        if_TYPE_return_TOOL(TYPE_UNDO, UndoTool);\n        if_TYPE_return_TOOL(TYPE_COPY, CopyTool);\n        if_TYPE_return_TOOL(TYPE_SAVE, SaveTool);\n        if_TYPE_return_TOOL(TYPE_EXIT, ExitTool);\n        if_TYPE_return_TOOL(TYPE_IMAGEUPLOADER, ImgUploaderTool);\n#if !defined(Q_OS_MACOS)\n        if_TYPE_return_TOOL(TYPE_OPEN_APP, AppLauncher);\n#endif\n        if_TYPE_return_TOOL(TYPE_PIXELATE, PixelateTool);\n        if_TYPE_return_TOOL(TYPE_REDO, RedoTool);\n        if_TYPE_return_TOOL(TYPE_PIN, PinTool);\n        if_TYPE_return_TOOL(TYPE_TEXT, TextTool);\n        if_TYPE_return_TOOL(TYPE_CIRCLECOUNT, CircleCountTool);\n        if_TYPE_return_TOOL(TYPE_SIZEINCREASE, SizeIncreaseTool);\n        if_TYPE_return_TOOL(TYPE_SIZEDECREASE, SizeDecreaseTool);\n        if_TYPE_return_TOOL(TYPE_INVERT, InvertTool);\n        if_TYPE_return_TOOL(TYPE_ACCEPT, AcceptTool);\n        default:\n            return nullptr;\n    }\n}\n\n</code></pre>"},{"location":"flameshot/toolfactory_8h/","title":"File toolfactory.h","text":"<p>FileList &gt; src &gt; tools &gt; toolfactory.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include \"src/widgets/capture/capturetoolbutton.h\"</code></li> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/toolfactory_8h/#classes","title":"Classes","text":"Type Name class ToolFactory"},{"location":"flameshot/toolfactory_8h_source/","title":"File toolfactory.h","text":"<p>File List &gt; src &gt; tools &gt; toolfactory.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/capturetool.h\"\n#include \"src/widgets/capture/capturetoolbutton.h\"\n#include &lt;QObject&gt;\n\nclass CaptureTool;\n\nclass ToolFactory : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit ToolFactory(QObject* parent = nullptr);\n\n    ToolFactory(const ToolFactory&amp;) = delete;\n    ToolFactory&amp; operator=(const ToolFactory&amp;) = delete;\n\n    CaptureTool* CreateTool(CaptureTool::Type t, QObject* parent = nullptr);\n};\n\n</code></pre>"},{"location":"flameshot/dir_881e36e860689fc2ab48122781e8b3fb/","title":"Dir undo","text":"<p>FileList &gt; src &gt; tools &gt; undo</p>"},{"location":"flameshot/dir_881e36e860689fc2ab48122781e8b3fb/#files","title":"Files","text":"Type Name file undotool.cpp file undotool.h"},{"location":"flameshot/undotool_8cpp/","title":"File undotool.cpp","text":"<p>FileList &gt; src &gt; tools &gt; undo &gt; undotool.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"undotool.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/undotool_8cpp_source/","title":"File undotool.cpp","text":"<p>File List &gt; src &gt; tools &gt; undo &gt; undotool.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"undotool.h\"\n#include &lt;QPainter&gt;\n\nUndoTool::UndoTool(QObject* parent)\n  : AbstractActionTool(parent)\n{}\n\nbool UndoTool::closeOnButtonPressed() const\n{\n    return false;\n}\n\nQIcon UndoTool::icon(const QColor&amp; background, bool inEditor) const\n{\n    Q_UNUSED(inEditor)\n    return QIcon(iconPath(background) + \"undo-variant.svg\");\n}\nQString UndoTool::name() const\n{\n    return tr(\"Undo\");\n}\n\nCaptureTool::Type UndoTool::type() const\n{\n    return CaptureTool::TYPE_UNDO;\n}\n\nQString UndoTool::description() const\n{\n    return tr(\"Undo the last modification\");\n}\n\nCaptureTool* UndoTool::copy(QObject* parent)\n{\n    return new UndoTool(parent);\n}\n\nvoid UndoTool::pressed(CaptureContext&amp; context)\n{\n    Q_UNUSED(context)\n    emit requestAction(REQ_UNDO_MODIFICATION);\n}\n\n</code></pre>"},{"location":"flameshot/undotool_8h/","title":"File undotool.h","text":"<p>FileList &gt; src &gt; tools &gt; undo &gt; undotool.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/abstractactiontool.h\"</code></li> </ul>"},{"location":"flameshot/undotool_8h/#classes","title":"Classes","text":"Type Name class UndoTool"},{"location":"flameshot/undotool_8h_source/","title":"File undotool.h","text":"<p>File List &gt; src &gt; tools &gt; undo &gt; undotool.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/abstractactiontool.h\"\n\nclass UndoTool : public AbstractActionTool\n{\n    Q_OBJECT\npublic:\n    explicit UndoTool(QObject* parent = nullptr);\n\n    bool closeOnButtonPressed() const override;\n\n    QIcon icon(const QColor&amp; background, bool inEditor) const override;\n    QString name() const override;\n    QString description() const override;\n\n    CaptureTool* copy(QObject* parent = nullptr) override;\n\nprotected:\n    CaptureTool::Type type() const override;\n\npublic slots:\n    void pressed(CaptureContext&amp; context) override;\n};\n\n</code></pre>"},{"location":"flameshot/dir_313caf1132e152dd9b58bea13a4052ca/","title":"Dir utils","text":"<p>FileList &gt; src &gt; utils</p>"},{"location":"flameshot/dir_313caf1132e152dd9b58bea13a4052ca/#files","title":"Files","text":"Type Name file abstractlogger.cpp file abstractlogger.h file colorutils.cpp file colorutils.h file confighandler.cpp file confighandler.h file desktopfileparse.cpp file desktopfileparse.h file desktopinfo.cpp file desktopinfo.h file filenamehandler.cpp file filenamehandler.h file globalvalues.cpp file globalvalues.h file history.cpp file history.h file pathinfo.cpp file pathinfo.h file request.cpp file request.h file screengrabber.cpp file screengrabber.h file screenshotsaver.cpp file screenshotsaver.h file strfparse.cpp file strfparse.h file systemnotification.cpp file systemnotification.h file valuehandler.cpp file valuehandler.h file waylandutils.cpp file waylandutils.h file winlnkfileparse.cpp file winlnkfileparse.h"},{"location":"flameshot/abstractlogger_8cpp/","title":"File abstractlogger.cpp","text":"<p>FileList &gt; src &gt; utils &gt; abstractlogger.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"systemnotification.h\"</code></li> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;QFileInfo&gt;</code></li> </ul>"},{"location":"flameshot/abstractlogger_8cpp_source/","title":"File abstractlogger.cpp","text":"<p>File List &gt; src &gt; utils &gt; abstractlogger.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"abstractlogger.h\"\n#include \"systemnotification.h\"\n#include &lt;cassert&gt;\n\n#include &lt;QFileInfo&gt;\n\nAbstractLogger::AbstractLogger(Channel channel, int targets)\n  : m_defaultChannel(channel)\n  , m_targets(targets)\n{\n    if (targets &amp; LogFile) {\n        // TODO\n    }\n}\n\nAbstractLogger::AbstractLogger(QString&amp; str,\n                               Channel channel,\n                               int additionalChannels)\n  : AbstractLogger(channel, additionalChannels)\n{\n    m_textStreams &lt;&lt; new QTextStream(&amp;str);\n}\n\nAbstractLogger::~AbstractLogger()\n{\n    qDeleteAll(m_textStreams);\n}\n\nAbstractLogger AbstractLogger::info(int targets)\n{\n    return { Info, targets };\n}\n\nAbstractLogger AbstractLogger::warning(int targets)\n{\n    return { Warning, targets };\n}\n\nAbstractLogger AbstractLogger::error(int targets)\n{\n    return { Error, targets };\n}\n\nAbstractLogger&amp; AbstractLogger::sendMessage(const QString&amp; msg, Channel channel)\n{\n    if (m_targets &amp; Notification) {\n        SystemNotification().sendMessage(\n          msg, messageHeader(channel, Notification), m_notificationPath);\n    }\n    if (!m_textStreams.isEmpty()) {\n        foreach (auto* stream, m_textStreams) {\n            *stream &lt;&lt; messageHeader(channel, String) &lt;&lt; msg &lt;&lt; \"\\n\";\n        }\n    }\n    if (m_targets &amp; LogFile) {\n        // TODO\n    }\n    if (m_targets &amp; Stderr) {\n        QTextStream stream(stderr);\n        stream &lt;&lt; messageHeader(channel, Stderr) &lt;&lt; msg &lt;&lt; \"\\n\";\n    }\n\n    if (m_targets &amp; Stdout) {\n        QTextStream stream(stdout);\n        stream &lt;&lt; messageHeader(channel, Stdout) &lt;&lt; msg &lt;&lt; \"\\n\";\n    }\n\n    return *this;\n}\n\nAbstractLogger&amp; AbstractLogger::operator&lt;&lt;(const QString&amp; msg)\n{\n    sendMessage(msg, m_defaultChannel);\n    return *this;\n}\n\nAbstractLogger&amp; AbstractLogger::addOutputString(QString&amp; str)\n{\n    m_textStreams &lt;&lt; new QTextStream(&amp;str);\n    return *this;\n}\n\nAbstractLogger&amp; AbstractLogger::attachNotificationPath(const QString&amp; path)\n{\n    if (m_targets &amp; Notification) {\n        m_notificationPath = path;\n    } else {\n        assert(\"Cannot attach notification path to a logger without a \"\n               \"notification channel.\");\n    }\n    return *this;\n}\n\nAbstractLogger&amp; AbstractLogger::enableMessageHeader(bool enable)\n{\n    m_enableMessageHeader = enable;\n    return *this;\n}\n\nQString AbstractLogger::messageHeader(Channel channel, Target target)\n{\n    if (!m_enableMessageHeader) {\n        return \"\";\n    }\n    QString messageChannel;\n    if (channel == Info) {\n        messageChannel = \"info\";\n    } else if (channel == Warning) {\n        messageChannel = \"warning\";\n    } else if (channel == Error) {\n        messageChannel = \"error\";\n    }\n\n    if (target == Notification) {\n        messageChannel[0] = messageChannel[0].toUpper();\n        return \"Flameshot \" + messageChannel;\n    } else {\n        return \"flameshot: \" + messageChannel + \": \";\n    }\n}\n\n</code></pre>"},{"location":"flameshot/abstractlogger_8h/","title":"File abstractlogger.h","text":"<p>FileList &gt; src &gt; utils &gt; abstractlogger.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;QTextStream&gt;</code></li> </ul>"},{"location":"flameshot/abstractlogger_8h/#classes","title":"Classes","text":"Type Name class AbstractLogger A class that allows you to log events to where they need to go."},{"location":"flameshot/abstractlogger_8h_source/","title":"File abstractlogger.h","text":"<p>File List &gt; src &gt; utils &gt; abstractlogger.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#pragma once\n\n#include &lt;QString&gt;\n#include &lt;QTextStream&gt;\n\nclass AbstractLogger\n{\npublic:\n    enum Target\n    {\n        Notification = 0x01,\n        Stderr = 0x02,\n        LogFile = 0x08,\n        String = 0x10,\n        Stdout = 0x20,\n        Default = Notification | LogFile | Stderr,\n    };\n\n    enum Channel\n    {\n        Info,\n        Warning,\n        Error\n    };\n\n    AbstractLogger(Channel channel = Info, int targets = Default);\n    AbstractLogger(QString&amp; str,\n                   Channel channel,\n                   int additionalTargets = String);\n    ~AbstractLogger();\n\n    // Convenience functions\n    static AbstractLogger info(int targets = Default);\n    static AbstractLogger warning(int targets = Default);\n    static AbstractLogger error(int targets = Default);\n\n    AbstractLogger&amp; sendMessage(const QString&amp; msg, Channel channel);\n    AbstractLogger&amp; operator&lt;&lt;(const QString&amp; msg);\n    AbstractLogger&amp; addOutputString(QString&amp; str);\n    AbstractLogger&amp; attachNotificationPath(const QString&amp; path);\n    AbstractLogger&amp; enableMessageHeader(bool enable);\n\nprivate:\n    QString messageHeader(Channel channel, Target target);\n\n    int m_targets;\n    Channel m_defaultChannel;\n    QList&lt;QTextStream*&gt; m_textStreams;\n    QString m_notificationPath;\n    bool m_enableMessageHeader = true;\n};\n\n</code></pre>"},{"location":"flameshot/colorutils_8cpp/","title":"File colorutils.cpp","text":"<p>FileList &gt; src &gt; utils &gt; colorutils.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"colorutils.h\"</code></li> </ul>"},{"location":"flameshot/colorutils_8cpp/#public-functions","title":"Public Functions","text":"Type Name qreal getColorLuma (const QColor &amp; c)"},{"location":"flameshot/colorutils_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/colorutils_8cpp/#function-getcolorluma","title":"function getColorLuma","text":"<pre><code>inline qreal getColorLuma (\n    const QColor &amp; c\n) \n</code></pre>"},{"location":"flameshot/colorutils_8cpp_source/","title":"File colorutils.cpp","text":"<p>File List &gt; src &gt; utils &gt; colorutils.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"colorutils.h\"\n\ninline qreal getColorLuma(const QColor&amp; c)\n{\n    return 0.30 * c.redF() + 0.59 * c.greenF() + 0.11 * c.blueF();\n}\n\nbool ColorUtils::colorIsDark(const QColor&amp; c)\n{\n    // when luma &lt;= 0.5, we considor it as a dark color\n    return getColorLuma(c) &lt;= 0.5;\n}\n\nQColor ColorUtils::contrastColor(const QColor&amp; c)\n{\n    int change = colorIsDark(c) ? 30 : -45;\n\n    return { qBound(0, c.red() + change, 255),\n             qBound(0, c.green() + change, 255),\n             qBound(0, c.blue() + change, 255) };\n}\n\n</code></pre>"},{"location":"flameshot/colorutils_8h/","title":"File colorutils.h","text":"<p>FileList &gt; src &gt; utils &gt; colorutils.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QColor&gt;</code></li> </ul>"},{"location":"flameshot/colorutils_8h/#namespaces","title":"Namespaces","text":"Type Name namespace ColorUtils"},{"location":"flameshot/colorutils_8h_source/","title":"File colorutils.h","text":"<p>File List &gt; src &gt; utils &gt; colorutils.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QColor&gt;\n\nnamespace ColorUtils { // namespace\n\nbool colorIsDark(const QColor&amp; c);\n\nQColor contrastColor(const QColor&amp; c);\n\n} // namespace\n\n</code></pre>"},{"location":"flameshot/confighandler_8cpp/","title":"File confighandler.cpp","text":"<p>FileList &gt; src &gt; utils &gt; confighandler.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"confighandler.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include \"valuehandler.h\"</code></li> <li><code>#include &lt;QCoreApplication&gt;</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QFile&gt;</code></li> <li><code>#include &lt;QFileSystemWatcher&gt;</code></li> <li><code>#include &lt;QKeySequence&gt;</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QSharedPointer&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"flameshot/confighandler_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name QMap&lt; class QString, QSharedPointer&lt; ValueHandler &gt; &gt; recognizedGeneralOptions QMap&lt; QString, QSharedPointer&lt; KeySequence &gt; &gt; recognizedShortcuts"},{"location":"flameshot/confighandler_8cpp/#public-functions","title":"Public Functions","text":"Type Name bool verifyLaunchFile ()"},{"location":"flameshot/confighandler_8cpp/#macros","title":"Macros","text":"Type Name define OPTION (KEY, TYPE)  define SHORTCUT (NAME, DEFAULT_VALUE)"},{"location":"flameshot/confighandler_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"flameshot/confighandler_8cpp/#variable-recognizedgeneraloptions","title":"variable recognizedGeneralOptions","text":"<pre><code>QMap&lt;class QString, QSharedPointer&lt;ValueHandler&gt; &gt; recognizedGeneralOptions;\n</code></pre> <p>This map contains all the information that is needed to parse, verify and preprocess each configuration option in the General section. NOTE: Please keep it well structured </p>"},{"location":"flameshot/confighandler_8cpp/#variable-recognizedshortcuts","title":"variable recognizedShortcuts","text":"<pre><code>QMap&lt;QString, QSharedPointer&lt;KeySequence&gt; &gt; recognizedShortcuts;\n</code></pre>"},{"location":"flameshot/confighandler_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/confighandler_8cpp/#function-verifylaunchfile","title":"function verifyLaunchFile","text":"<pre><code>bool verifyLaunchFile () \n</code></pre>"},{"location":"flameshot/confighandler_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/confighandler_8cpp/#define-option","title":"define OPTION","text":"<pre><code>#define OPTION (\n    KEY,\n    TYPE\n) {                                                                          \\\n        QStringLiteral(KEY), QSharedPointer &lt; ValueHandler &gt;(new TYPE)            \\\n    }\n</code></pre> <p>Use this to declare a setting with a type that is either unrecognized by QVariant or if you need to place additional constraints on its value. </p> <p>Parameters:</p> <ul> <li><code>KEY</code> Name of the setting as in the config file (a C-style string literal) </li> <li><code>TYPE</code> An instance of a <code>ValueHandler</code> derivative. This must be specified in the form of a constructor, or the macro will misbehave. </li> </ul>"},{"location":"flameshot/confighandler_8cpp/#define-shortcut","title":"define SHORTCUT","text":"<pre><code>#define SHORTCUT (\n    NAME,\n    DEFAULT_VALUE\n) {                                                                          \\\n        QStringLiteral(NAME), QSharedPointer &lt; KeySequence &gt;(new KeySequence (     \\\n                                QKeySequence(QLatin1String(DEFAULT_VALUE))))   \\\n    }\n</code></pre>"},{"location":"flameshot/confighandler_8cpp_source/","title":"File confighandler.cpp","text":"<p>File List &gt; src &gt; utils &gt; confighandler.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"confighandler.h\"\n#include \"abstractlogger.h\"\n#include \"src/tools/capturetool.h\"\n#include \"valuehandler.h\"\n#include &lt;QCoreApplication&gt;\n#include &lt;QDebug&gt;\n#include &lt;QDir&gt;\n#include &lt;QFile&gt;\n#include &lt;QFileSystemWatcher&gt;\n#include &lt;QKeySequence&gt;\n#include &lt;QMap&gt;\n#include &lt;QSharedPointer&gt;\n#include &lt;QStandardPaths&gt;\n#include &lt;QVector&gt;\n#include &lt;algorithm&gt;\n#include &lt;stdexcept&gt;\n\n#if defined(Q_OS_MACOS)\n#include &lt;QProcess&gt;\n#endif\n\n// HELPER FUNCTIONS\n\nbool verifyLaunchFile()\n{\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    QString path = QStandardPaths::locate(QStandardPaths::GenericConfigLocation,\n                                          \"autostart/\",\n                                          QStandardPaths::LocateDirectory) +\n                   \"Flameshot.desktop\";\n    bool res = QFile(path).exists();\n#elif defined(Q_OS_WIN)\n    QSettings bootUpSettings(\n      \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n      QSettings::NativeFormat);\n    bool res =\n      bootUpSettings.value(\"Flameshot\").toString() ==\n      QDir::toNativeSeparators(QCoreApplication::applicationFilePath());\n#endif\n    return res;\n}\n\n// VALUE HANDLING\n\n#define OPTION(KEY, TYPE)                                                      \\\n    {                                                                          \\\n        QStringLiteral(KEY), QSharedPointer&lt;ValueHandler&gt;(new TYPE)            \\\n    }\n\n#define SHORTCUT(NAME, DEFAULT_VALUE)                                          \\\n    {                                                                          \\\n        QStringLiteral(NAME), QSharedPointer&lt;KeySequence&gt;(new KeySequence(     \\\n                                QKeySequence(QLatin1String(DEFAULT_VALUE))))   \\\n    }\n\n// clang-format off\nstatic QMap&lt;class QString, QSharedPointer&lt;ValueHandler&gt;&gt;\n        recognizedGeneralOptions = {\n//         KEY                            TYPE                 DEFAULT_VALUE\n    OPTION(\"showHelp\"                    ,Bool               ( true          )),\n    OPTION(\"showSidePanelButton\"         ,Bool               ( true          )),\n    OPTION(\"showDesktopNotification\"     ,Bool               ( true          )),\n    OPTION(\"disabledTrayIcon\"            ,Bool               ( false         )),\n    OPTION(\"disabledGrimWarning\"         ,Bool               ( false         )),\n    OPTION(\"historyConfirmationToDelete\" ,Bool               ( true          )),\n#if !defined(DISABLE_UPDATE_CHECKER)\n    OPTION(\"checkForUpdates\"             ,Bool               ( true          )),\n#endif\n    OPTION(\"allowMultipleGuiInstances\"   ,Bool               ( false         )),\n    OPTION(\"showMagnifier\"               ,Bool               ( false         )),\n    OPTION(\"squareMagnifier\"             ,Bool               ( false         )),\n#if !defined(Q_OS_WIN)\n    OPTION(\"autoCloseIdleDaemon\"         ,Bool               ( false         )),\n#endif\n    OPTION(\"startupLaunch\"               ,Bool               ( false         )),\n    OPTION(\"showStartupLaunchMessage\"    ,Bool               ( true          )),\n    OPTION(\"copyURLAfterUpload\"          ,Bool               ( true          )),\n    OPTION(\"copyPathAfterSave\"           ,Bool               ( false         )),\n    OPTION(\"antialiasingPinZoom\"         ,Bool               ( true          )),\n    OPTION(\"useJpgForClipboard\"          ,Bool               ( false         )),\n    OPTION(\"uploadWithoutConfirmation\"   ,Bool               ( false         )),\n    OPTION(\"saveAfterCopy\"               ,Bool               ( false         )),\n    OPTION(\"savePath\"                    ,ExistingDir        (                   )),\n    OPTION(\"savePathFixed\"               ,Bool               ( false         )),\n    OPTION(\"saveAsFileExtension\"         ,SaveFileExtension  (                   )),\n    OPTION(\"saveLastRegion\"              ,Bool               (false          )),\n    OPTION(\"uploadHistoryMax\"            ,LowerBoundedInt    (0, 25               )),\n    OPTION(\"undoLimit\"                   ,BoundedInt         (0, 999, 100    )),\n  // Interface tab\n    OPTION(\"uiColor\"                     ,Color              ( {116, 0, 150}   )),\n    OPTION(\"contrastUiColor\"             ,Color              ( {39, 0, 50}     )),\n    OPTION(\"contrastOpacity\"             ,BoundedInt         ( 0, 255, 190    )),\n    OPTION(\"buttons\"                     ,ButtonList         ( {}            )),\n    // Filename Editor tab\n    OPTION(\"filenamePattern\"             ,FilenamePattern    ( {}            )),\n    // Others\n    OPTION(\"drawThickness\"               ,LowerBoundedInt    (1  , 3             )),\n    OPTION(\"drawFontSize\"                ,LowerBoundedInt    (1  , 8             )),\n    OPTION(\"drawColor\"                   ,Color              ( Qt::red       )),\n    OPTION(\"userColors\"                  ,UserColors(3,        17            )),\n    OPTION(\"ignoreUpdateToVersion\"       ,String             ( \"\"            )),\n    OPTION(\"keepOpenAppLauncher\"         ,Bool               ( false         )),\n    OPTION(\"fontFamily\"                  ,String             ( \"\"            )),\n    // PREDEFINED_COLOR_PALETTE_LARGE is defined in src/CMakeList.txt file and can be overwritten in GitHub actions\n    OPTION(\"predefinedColorPaletteLarge\", Bool               ( PREDEFINED_COLOR_PALETTE_LARGE )),\n    // NOTE: If another tool size is added besides drawThickness and\n    // drawFontSize, remember to update ConfigHandler::toolSize\n    OPTION(\"copyOnDoubleClick\"           ,Bool               ( false         )),\n    OPTION(\"uploadClientSecret\"          ,String             ( \"313baf0c7b4d3ff\"            )),\n    OPTION(\"showSelectionGeometry\"  , BoundedInt               (0,5,4)),\n    OPTION(\"showSelectionGeometryHideTime\", LowerBoundedInt       (0, 3000)),\n    OPTION(\"jpegQuality\", BoundedInt     (0,100,75))\n};\n\nstatic QMap&lt;QString, QSharedPointer&lt;KeySequence&gt;&gt; recognizedShortcuts = {\n//           NAME                           DEFAULT_SHORTCUT\n    SHORTCUT(\"TYPE_PENCIL\"              ,   \"P\"                     ),\n    SHORTCUT(\"TYPE_DRAWER\"              ,   \"D\"                     ),\n    SHORTCUT(\"TYPE_ARROW\"               ,   \"A\"                     ),\n    SHORTCUT(\"TYPE_SELECTION\"           ,   \"S\"                     ),\n    SHORTCUT(\"TYPE_RECTANGLE\"           ,   \"R\"                     ),\n    SHORTCUT(\"TYPE_CIRCLE\"              ,   \"C\"                     ),\n    SHORTCUT(\"TYPE_MARKER\"              ,   \"M\"                     ),\n    SHORTCUT(\"TYPE_MOVESELECTION\"       ,   \"Ctrl+M\"                ),\n    SHORTCUT(\"TYPE_UNDO\"                ,   \"Ctrl+Z\"                ),\n    SHORTCUT(\"TYPE_COPY\"                ,   \"Ctrl+C\"                ),\n    SHORTCUT(\"TYPE_SAVE\"                ,   \"Ctrl+S\"                ),\n    SHORTCUT(\"TYPE_ACCEPT\"              ,   \"Return\"                ),\n    SHORTCUT(\"TYPE_EXIT\"                ,   \"Ctrl+Q\"                ),\n    SHORTCUT(\"TYPE_IMAGEUPLOADER\"       ,                           ),\n#if !defined(Q_OS_MACOS)\n    SHORTCUT(\"TYPE_OPEN_APP\"            ,   \"Ctrl+O\"                ),\n#endif\n    SHORTCUT(\"TYPE_PIXELATE\"            ,   \"B\"                     ),\n    SHORTCUT(\"TYPE_INVERT\"              ,   \"I\"                     ),\n    SHORTCUT(\"TYPE_REDO\"                ,   \"Ctrl+Shift+Z\"          ),\n    SHORTCUT(\"TYPE_TEXT\"                ,   \"T\"                     ),\n    SHORTCUT(\"TYPE_TOGGLE_PANEL\"        ,   \"Space\"                 ),\n    SHORTCUT(\"TYPE_RESIZE_LEFT\"         ,   \"Shift+Left\"            ),\n    SHORTCUT(\"TYPE_RESIZE_RIGHT\"        ,   \"Shift+Right\"           ),\n    SHORTCUT(\"TYPE_RESIZE_UP\"           ,   \"Shift+Up\"              ),\n    SHORTCUT(\"TYPE_RESIZE_DOWN\"         ,   \"Shift+Down\"            ),\n    SHORTCUT(\"TYPE_SYM_RESIZE_LEFT\"     ,   \"Ctrl+Shift+Left\"       ),\n    SHORTCUT(\"TYPE_SYM_RESIZE_RIGHT\"    ,   \"Ctrl+Shift+Right\"      ),\n    SHORTCUT(\"TYPE_SYM_RESIZE_UP\"       ,   \"Ctrl+Shift+Up\"         ),\n    SHORTCUT(\"TYPE_SYM_RESIZE_DOWN\"     ,   \"Ctrl+Shift+Down\"       ),\n    SHORTCUT(\"TYPE_SELECT_ALL\"          ,   \"Ctrl+A\"                ),\n    SHORTCUT(\"TYPE_MOVE_LEFT\"           ,   \"Left\"                  ),\n    SHORTCUT(\"TYPE_MOVE_RIGHT\"          ,   \"Right\"                 ),\n    SHORTCUT(\"TYPE_MOVE_UP\"             ,   \"Up\"                    ),\n    SHORTCUT(\"TYPE_MOVE_DOWN\"           ,   \"Down\"                  ),\n    SHORTCUT(\"TYPE_COMMIT_CURRENT_TOOL\" ,   \"Ctrl+Return\"           ),\n#if defined(Q_OS_MACOS)\n    SHORTCUT(\"TYPE_DELETE_CURRENT_TOOL\" ,   \"Backspace\"             ),\n    SHORTCUT(\"TAKE_SCREENSHOT\"          ,   \"Ctrl+Shift+X\"          ),\n    SHORTCUT(\"SCREENSHOT_HISTORY\"       ,   \"Alt+Shift+X\"           ),\n#else\n    SHORTCUT(\"TYPE_DELETE_CURRENT_TOOL\" ,   \"Delete\"                ),\n#endif\n    SHORTCUT(\"TYPE_PIN\"                 ,                           ),\n    SHORTCUT(\"TYPE_SELECTIONINDICATOR\"  ,                           ),\n    SHORTCUT(\"TYPE_SIZEINCREASE\"        ,                           ),\n    SHORTCUT(\"TYPE_SIZEDECREASE\"        ,                           ),\n    SHORTCUT(\"TYPE_CIRCLECOUNT\"         ,                           ),\n};\n// clang-format on\n\n// CLASS CONFIGHANDLER\n\nConfigHandler::ConfigHandler()\n  : m_settings(QSettings::IniFormat,\n               QSettings::UserScope,\n               qApp-&gt;organizationName(),\n               qApp-&gt;applicationName())\n{\n    static bool firstInitialization = true;\n    if (firstInitialization) {\n        // check for error every time the file changes\n        m_configWatcher.reset(new QFileSystemWatcher());\n        ensureFileWatched();\n        QObject::connect(m_configWatcher.data(),\n                         &amp;QFileSystemWatcher::fileChanged,\n                         [](const QString&amp; fileName) {\n                             emit getInstance()-&gt;fileChanged();\n\n                             if (QFile(fileName).exists()) {\n                                 m_configWatcher-&gt;addPath(fileName);\n                             }\n                             if (m_skipNextErrorCheck) {\n                                 m_skipNextErrorCheck = false;\n                                 return;\n                             }\n                             ConfigHandler().checkAndHandleError();\n                             if (!QFile(fileName).exists()) {\n                                 // File watcher stops watching a deleted file.\n                                 // Next time the config is accessed, force it\n                                 // to check for errors (and watch again).\n                                 m_errorCheckPending = true;\n                             }\n                         });\n    }\n    firstInitialization = false;\n}\n\nConfigHandler* ConfigHandler::getInstance()\n{\n    static ConfigHandler config;\n    return &amp;config;\n}\n\n// SPECIAL CASES\n\nbool ConfigHandler::startupLaunch()\n{\n    bool res = value(QStringLiteral(\"startupLaunch\")).toBool();\n    if (res != verifyLaunchFile()) {\n        setStartupLaunch(res);\n    }\n    return res;\n}\n\nvoid ConfigHandler::setStartupLaunch(const bool start)\n{\n    if (start == value(QStringLiteral(\"startupLaunch\")).toBool()) {\n        return;\n    }\n    setValue(QStringLiteral(\"startupLaunch\"), start);\n#if defined(Q_OS_MACOS)\n    /* TODO - there should be more correct way via API, but didn't find it\n     without extra dependencies, there should be something like that:\n     https://stackoverflow.com/questions/3358410/programmatically-run-at-startup-on-mac-os-x\n     But files with this features differs on different MacOS versions and it\n     doesn't work not on a BigSur at lease.\n     */\n    QProcess process;\n    if (start) {\n        process.start(\"osascript\",\n                      QStringList()\n                        &lt;&lt; \"-e\"\n                        &lt;&lt; \"tell application \\\"System Events\\\" to make login \"\n                           \"item at end with properties {name: \"\n                           \"\\\"Flameshot\\\",path:\\\"/Applications/\"\n                           \"flameshot.app\\\", hidden:false}\");\n    } else {\n        process.start(\"osascript\",\n                      QStringList() &lt;&lt; \"-e\"\n                                    &lt;&lt; \"tell application \\\"System Events\\\" to \"\n                                       \"delete login item \\\"Flameshot\\\"\");\n    }\n    if (!process.waitForFinished()) {\n        qWarning() &lt;&lt; \"Login items is changed. \" &lt;&lt; process.errorString();\n    } else {\n        qWarning() &lt;&lt; \"Unable to change login items, error:\"\n                   &lt;&lt; process.readAll();\n    }\n#elif defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    QString path =\n      QStandardPaths::writableLocation(QStandardPaths::GenericConfigLocation) +\n      \"/autostart/\";\n    QDir autostartDir(path);\n    if (!autostartDir.exists()) {\n        autostartDir.mkpath(\".\");\n    }\n\n    QFile file(path + \"Flameshot.desktop\");\n    if (start) {\n        if (file.open(QIODevice::WriteOnly)) {\n            QByteArray data(\"[Desktop Entry]\\nName=flameshot\\nIcon=flameshot\"\n                            \"\\nExec=flameshot\\nTerminal=false\\nType=Application\"\n                            \"\\nX-GNOME-Autostart-enabled=true\\n\");\n            file.write(data);\n        }\n    } else {\n        file.remove();\n    }\n#elif defined(Q_OS_WIN)\n    QSettings bootUpSettings(\n      \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\",\n      QSettings::NativeFormat);\n    // set workdir for flameshot on startup\n    QSettings bootUpPath(\n      \"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\App \"\n      \"Paths\",\n      QSettings::NativeFormat);\n    if (start) {\n        QString app_path =\n          QDir::toNativeSeparators(QCoreApplication::applicationFilePath());\n        bootUpSettings.setValue(\"Flameshot\", app_path);\n\n        // set application workdir\n        bootUpPath.beginGroup(\"flameshot.exe\");\n        bootUpPath.setValue(\"Path\", QCoreApplication::applicationDirPath());\n        bootUpPath.endGroup();\n\n    } else {\n        bootUpSettings.remove(\"Flameshot\");\n\n        // remove application workdir\n        bootUpPath.beginGroup(\"flameshot.exe\");\n        bootUpPath.remove(\"\");\n        bootUpPath.endGroup();\n    }\n#endif\n}\n\nvoid ConfigHandler::setAllTheButtons()\n{\n    QList&lt;CaptureTool::Type&gt; buttonlist =\n      CaptureToolButton::getIterableButtonTypes();\n    setValue(QStringLiteral(\"buttons\"), QVariant::fromValue(buttonlist));\n}\n\nvoid ConfigHandler::setToolSize(CaptureTool::Type toolType, int size)\n{\n    if (toolType == CaptureTool::TYPE_TEXT) {\n        setDrawFontSize(size);\n    } else if (toolType != CaptureTool::NONE) {\n        setDrawThickness(size);\n    }\n}\n\nint ConfigHandler::toolSize(CaptureTool::Type toolType)\n{\n    if (toolType == CaptureTool::TYPE_TEXT) {\n        return drawFontSize();\n    } else {\n        return drawThickness();\n    }\n}\n\n// DEFAULTS\n\nQString ConfigHandler::filenamePatternDefault()\n{\n    return QStringLiteral(\"%F_%H-%M\");\n}\n\nvoid ConfigHandler::setDefaultSettings()\n{\n    foreach (const QString&amp; key, m_settings.allKeys()) {\n        if (isShortcut(key)) {\n            // Do not reset Shortcuts\n            continue;\n        }\n        m_settings.remove(key);\n    }\n    m_settings.sync();\n}\n\nQString ConfigHandler::configFilePath() const\n{\n    return m_settings.fileName();\n}\n\n// GENERIC GETTERS AND SETTERS\n\nbool ConfigHandler::setShortcut(const QString&amp; actionName,\n                                const QString&amp; shortcut)\n{\n    qDebug() &lt;&lt; actionName;\n    static QVector&lt;QKeySequence&gt; reservedShortcuts = {\n#if defined(Q_OS_MACOS)\n        Qt::CTRL + Qt::Key_Backspace,\n        Qt::Key_Escape,\n#else\n        Qt::Key_Backspace,\n        Qt::Key_Escape,\n#endif\n    };\n\n    if (hasError()) {\n        return false;\n    }\n\n    bool errorFlag = false;\n\n    m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS);\n    if (shortcut.isEmpty()) {\n        setValue(actionName, \"\");\n    } else if (reservedShortcuts.contains(QKeySequence(shortcut))) {\n        // do not allow to set reserved shortcuts\n        errorFlag = true;\n    } else {\n        errorFlag = false;\n        // Make no difference for Return and Enter keys\n        QString newShortcut = KeySequence().value(shortcut).toString();\n        for (auto&amp; otherAction : m_settings.allKeys()) {\n            if (actionName == otherAction) {\n                continue;\n            }\n            QString existingShortcut =\n              KeySequence().value(m_settings.value(otherAction)).toString();\n            if (newShortcut == existingShortcut) {\n                errorFlag = true;\n                goto done;\n            }\n        }\n        m_settings.setValue(actionName, KeySequence().value(shortcut));\n    }\ndone:\n    m_settings.endGroup();\n    return !errorFlag;\n}\n\nQString ConfigHandler::shortcut(const QString&amp; actionName)\n{\n    QString setting = CONFIG_GROUP_SHORTCUTS \"/\" + actionName;\n    QString shortcut = value(setting).toString();\n    if (!m_settings.contains(setting)) {\n        // The action uses a shortcut that is a flameshot default\n        // (not set explicitly by user)\n        m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS);\n        for (auto&amp; otherAction : m_settings.allKeys()) {\n            if (m_settings.value(otherAction) == shortcut) {\n                // We found an explicit shortcut - it will take precedence\n                m_settings.endGroup();\n                return {};\n            }\n        }\n        m_settings.endGroup();\n    }\n    return shortcut;\n}\n\nvoid ConfigHandler::setValue(const QString&amp; key, const QVariant&amp; value)\n{\n    assertKeyRecognized(key);\n    if (!hasError()) {\n        // don't let the file watcher initiate another error check\n        m_skipNextErrorCheck = true;\n        auto val = valueHandler(key)-&gt;representation(value);\n        m_settings.setValue(key, val);\n    }\n}\n\nQVariant ConfigHandler::value(const QString&amp; key) const\n{\n    assertKeyRecognized(key);\n\n    auto val = m_settings.value(key);\n\n    auto handler = valueHandler(key);\n\n    // Check the value for semantic errors\n    if (val.isValid() &amp;&amp; !handler-&gt;check(val)) {\n        setErrorState(true);\n    }\n    if (m_hasError) {\n        return handler-&gt;fallback();\n    }\n\n    return handler-&gt;value(val);\n}\n\nvoid ConfigHandler::remove(const QString&amp; key)\n{\n    m_settings.remove(key);\n}\n\nvoid ConfigHandler::resetValue(const QString&amp; key)\n{\n    m_settings.setValue(key, valueHandler(key)-&gt;fallback());\n}\n\nQSet&lt;QString&gt;&amp; ConfigHandler::recognizedGeneralOptions()\n{\n#if QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0)\n    auto keys = ::recognizedGeneralOptions.keys();\n    static QSet&lt;QString&gt; options = QSet&lt;QString&gt;(keys.begin(), keys.end());\n#else\n    static QSet&lt;QString&gt; options =\n      QSet&lt;QString&gt;::fromList(::recognizedGeneralOptions.keys());\n#endif\n    return options;\n}\n\nQSet&lt;QString&gt;&amp; ConfigHandler::recognizedShortcutNames()\n{\n#if QT_VERSION &gt;= QT_VERSION_CHECK(5, 14, 0)\n    auto keys = recognizedShortcuts.keys();\n    static QSet&lt;QString&gt; names = QSet&lt;QString&gt;(keys.begin(), keys.end());\n#else\n    static QSet&lt;QString&gt; names =\n      QSet&lt;QString&gt;::fromList(recognizedShortcuts.keys());\n#endif\n    return names;\n}\n\nQSet&lt;QString&gt; ConfigHandler::keysFromGroup(const QString&amp; group) const\n{\n    QSet&lt;QString&gt; keys;\n    for (const QString&amp; key : m_settings.allKeys()) {\n        if (group == CONFIG_GROUP_GENERAL &amp;&amp; !key.contains('/')) {\n            keys.insert(key);\n        } else if (key.startsWith(group + \"/\")) {\n            keys.insert(baseName(key));\n        }\n    }\n    return keys;\n}\n\n// ERROR HANDLING\n\nbool ConfigHandler::checkForErrors(AbstractLogger* log) const\n{\n    return checkUnrecognizedSettings(log) &amp;&amp; checkShortcutConflicts(log) &amp;&amp;\n           checkSemantics(log);\n}\n\nbool ConfigHandler::checkUnrecognizedSettings(AbstractLogger* log,\n                                              QList&lt;QString&gt;* offenders) const\n{\n    // sort the config keys by group\n    QSet&lt;QString&gt; generalKeys = keysFromGroup(CONFIG_GROUP_GENERAL),\n                  shortcutKeys = keysFromGroup(CONFIG_GROUP_SHORTCUTS),\n                  recognizedGeneralKeys = recognizedGeneralOptions(),\n                  recognizedShortcutKeys = recognizedShortcutNames();\n\n    // subtract recognized keys\n    generalKeys.subtract(recognizedGeneralKeys);\n    shortcutKeys.subtract(recognizedShortcutKeys);\n\n    // what is left are the unrecognized keys - hopefully empty\n    bool ok = generalKeys.isEmpty() &amp;&amp; shortcutKeys.isEmpty();\n    if (log != nullptr || offenders != nullptr) {\n        for (const QString&amp; key : generalKeys) {\n            if (log) {\n                *log &lt;&lt; tr(\"Unrecognized setting: '%1'\\n\").arg(key);\n            }\n            if (offenders) {\n                offenders-&gt;append(key);\n            }\n        }\n        for (const QString&amp; key : shortcutKeys) {\n            if (log) {\n                *log &lt;&lt; tr(\"Unrecognized shortcut name: '%1'.\\n\").arg(key);\n            }\n            if (offenders) {\n                offenders-&gt;append(CONFIG_GROUP_SHORTCUTS \"/\" + key);\n            }\n        }\n    }\n    return ok;\n}\n\nbool ConfigHandler::checkShortcutConflicts(AbstractLogger* log) const\n{\n    bool ok = true;\n    m_settings.beginGroup(CONFIG_GROUP_SHORTCUTS);\n    QStringList shortcuts = m_settings.allKeys();\n    QStringList reportedInLog;\n    for (auto key1 = shortcuts.begin(); key1 != shortcuts.end(); ++key1) {\n        for (auto key2 = key1 + 1; key2 != shortcuts.end(); ++key2) {\n            // values stored in variables are useful when running debugger\n            QString value1 = m_settings.value(*key1).toString(),\n                    value2 = m_settings.value(*key2).toString();\n            // The check will pass if:\n            // - one shortcut is empty (the action doesn't use a shortcut)\n            // - or one of the settings is not found in m_settings, i.e.\n            //   user wants to use flameshot's default shortcut for the action\n            // - or the shortcuts for both actions are different\n            if (!(value1.isEmpty() || !m_settings.contains(*key1) ||\n                  !m_settings.contains(*key2) || value1 != value2)) {\n                ok = false;\n                if (log == nullptr) {\n                    break;\n                } else if (!reportedInLog.contains(*key1) &amp;&amp; // No duplicate\n                           !reportedInLog.contains(*key2)) { // log entries\n                    reportedInLog.append(*key1);\n                    reportedInLog.append(*key2);\n                    *log &lt;&lt; tr(\"Shortcut conflict: '%1' and '%2' \"\n                               \"have the same shortcut: %3\\n\")\n                              .arg(*key1)\n                              .arg(*key2)\n                              .arg(value1);\n                }\n            }\n        }\n    }\n    m_settings.endGroup();\n    return ok;\n}\n\nbool ConfigHandler::checkSemantics(AbstractLogger* log,\n                                   QList&lt;QString&gt;* offenders) const\n{\n    QStringList allKeys = m_settings.allKeys();\n    bool ok = true;\n    for (const QString&amp; key : allKeys) {\n        // Test if the key is recognized\n        if (!recognizedGeneralOptions().contains(key) &amp;&amp;\n            (!isShortcut(key) ||\n             !recognizedShortcutNames().contains(baseName(key)))) {\n            continue;\n        }\n        QVariant val = m_settings.value(key);\n        auto valueHandler = this-&gt;valueHandler(key);\n        if (val.isValid() &amp;&amp; !valueHandler-&gt;check(val)) {\n            // Key does not pass the check\n            ok = false;\n            if (log == nullptr &amp;&amp; offenders == nullptr) {\n                break;\n            }\n            if (log != nullptr) {\n                *log &lt;&lt; tr(\"Bad value in '%1'. Expected: %2\\n\")\n                          .arg(key)\n                          .arg(valueHandler-&gt;expected());\n            }\n            if (offenders != nullptr) {\n                offenders-&gt;append(key);\n            }\n        }\n    }\n    return ok;\n}\n\nvoid ConfigHandler::checkAndHandleError() const\n{\n    if (!QFile(m_settings.fileName()).exists()) {\n        setErrorState(false);\n    } else {\n        setErrorState(!checkForErrors());\n    }\n\n    ensureFileWatched();\n}\n\nvoid ConfigHandler::setErrorState(bool error) const\n{\n    bool hadError = m_hasError;\n    m_hasError = error;\n    // Notify user every time m_hasError changes\n    if (!hadError &amp;&amp; m_hasError) {\n        QString msg = errorMessage();\n        AbstractLogger::error() &lt;&lt; msg;\n        emit getInstance()-&gt;error();\n    } else if (hadError &amp;&amp; !m_hasError) {\n        auto msg =\n          tr(\"You have successfully resolved the configuration error.\");\n        AbstractLogger::info() &lt;&lt; msg;\n        emit getInstance()-&gt;errorResolved();\n    }\n}\n\nbool ConfigHandler::hasError() const\n{\n    if (m_errorCheckPending) {\n        checkAndHandleError();\n        m_errorCheckPending = false;\n    }\n    return m_hasError;\n}\n\nQString ConfigHandler::errorMessage() const\n{\n    return tr(\n      \"The configuration contains an error. Open configuration to resolve.\");\n}\n\nvoid ConfigHandler::ensureFileWatched() const\n{\n    QFile file(m_settings.fileName());\n    if (!file.exists()) {\n        file.open(QFileDevice::WriteOnly);\n        file.close();\n    }\n    if (m_configWatcher != nullptr &amp;&amp; m_configWatcher-&gt;files().isEmpty() &amp;&amp;\n        qApp != nullptr // ensures that the organization name can be accessed\n    ) {\n        m_configWatcher-&gt;addPath(m_settings.fileName());\n    }\n}\n\nQSharedPointer&lt;ValueHandler&gt; ConfigHandler::valueHandler(\n  const QString&amp; key) const\n{\n    QSharedPointer&lt;ValueHandler&gt; handler;\n    if (isShortcut(key)) {\n        handler = recognizedShortcuts.value(\n          baseName(key), QSharedPointer&lt;KeySequence&gt;(new KeySequence()));\n    } else { // General group\n        handler = ::recognizedGeneralOptions.value(key);\n    }\n    return handler;\n}\n\nvoid ConfigHandler::assertKeyRecognized(const QString&amp; key) const\n{\n    bool recognized = isShortcut(key)\n                        ? recognizedShortcutNames().contains(baseName(key))\n                        : ::recognizedGeneralOptions.contains(key);\n    if (!recognized) {\n#if defined(QT_DEBUG)\n        // This should never happen, but just in case\n        throw std::logic_error(\n          tr(\"Bad config key '%1' in ConfigHandler. Please report \"\n             \"this as a bug.\")\n            .arg(key)\n            .toStdString());\n#else\n        setErrorState(true);\n#endif\n    }\n}\n\nbool ConfigHandler::isShortcut(const QString&amp; key) const\n{\n    return m_settings.group() == QStringLiteral(CONFIG_GROUP_SHORTCUTS) ||\n           key.startsWith(QStringLiteral(CONFIG_GROUP_SHORTCUTS \"/\"));\n}\n\nQString ConfigHandler::baseName(const QString&amp; key) const\n{\n    return QFileInfo(key).baseName();\n}\n\n// STATIC MEMBER DEFINITIONS\n\nbool ConfigHandler::m_hasError = false;\nbool ConfigHandler::m_errorCheckPending = true;\nbool ConfigHandler::m_skipNextErrorCheck = false;\n\nQSharedPointer&lt;QFileSystemWatcher&gt; ConfigHandler::m_configWatcher;\n\n</code></pre>"},{"location":"flameshot/confighandler_8h/","title":"File confighandler.h","text":"<p>FileList &gt; src &gt; utils &gt; confighandler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/widgets/capture/capturetoolbutton.h\"</code></li> <li><code>#include &lt;QSettings&gt;</code></li> <li><code>#include &lt;QStringList&gt;</code></li> <li><code>#include &lt;QVariant&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> </ul>"},{"location":"flameshot/confighandler_8h/#classes","title":"Classes","text":"Type Name class ConfigHandler"},{"location":"flameshot/confighandler_8h/#macros","title":"Macros","text":"Type Name define CONFIG_GETTER (KEY, TYPE)  define CONFIG_GETTER_SETTER (GETFUNC, SETFUNC, TYPE)  define CONFIG_GROUP_GENERAL  \"General\" define CONFIG_GROUP_SHORTCUTS  \"Shortcuts\" define CONFIG_SETTER (FUNC, KEY, TYPE)"},{"location":"flameshot/confighandler_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/confighandler_8h/#define-config_getter","title":"define CONFIG_GETTER","text":"<pre><code>#define CONFIG_GETTER (\n    KEY,\n    TYPE\n) TYPE KEY()                                                                 \\\n    {                                                                          \\\n        return value(QStringLiteral(#KEY)).value&lt;TYPE&gt;();                      \\\n    }\n</code></pre> <p>Declare and implement a getter for a config option. <code>KEY</code> is the option key as it appears in the config file, <code>TYPE</code> is the C++ type. At the same time <code>KEY</code> is the name of the generated getter function. </p>"},{"location":"flameshot/confighandler_8h/#define-config_getter_setter","title":"define CONFIG_GETTER_SETTER","text":"<pre><code>#define CONFIG_GETTER_SETTER (\n    GETFUNC,\n    SETFUNC,\n    TYPE\n) CONFIG_GETTER(GETFUNC, TYPE)                                               \\\n    CONFIG_SETTER(SETFUNC, GETFUNC, TYPE)\n</code></pre> <p>Combines the functionality of <code>CONFIG_GETTER</code> and <code>CONFIG_SETTER</code>. <code>GETFUNC</code> is simultaneously the name of the getter function and the option key as it appears in the config file. <code>SETFUNC</code> is the name of the setter function. <code>TYPE</code> is the C++ type of the value. </p>"},{"location":"flameshot/confighandler_8h/#define-config_group_general","title":"define CONFIG_GROUP_GENERAL","text":"<pre><code>#define CONFIG_GROUP_GENERAL \"General\"\n</code></pre>"},{"location":"flameshot/confighandler_8h/#define-config_group_shortcuts","title":"define CONFIG_GROUP_SHORTCUTS","text":"<pre><code>#define CONFIG_GROUP_SHORTCUTS \"Shortcuts\"\n</code></pre>"},{"location":"flameshot/confighandler_8h/#define-config_setter","title":"define CONFIG_SETTER","text":"<pre><code>#define CONFIG_SETTER (\n    FUNC,\n    KEY,\n    TYPE\n) void FUNC(const TYPE&amp; val)                                                 \\\n    {                                                                          \\\n        QString key = QStringLiteral(#KEY);                                    \\\n        /* Without this check, multiple `flameshot gui` instances running */   \\\n        /* simultaneously would cause an endless loop of fileWatcher calls */  \\\n        if (QVariant::fromValue(val) != value(key)) {                          \\\n            setValue(key, QVariant::fromValue(val));                           \\\n        }                                                                      \\\n    }\n</code></pre> <p>Declare and implement a setter for a config option. <code>FUNC</code> is the name of the generated function, <code>KEY</code> is the option key as it appears in the config file and <code>TYPE</code> is the C++ type. </p>"},{"location":"flameshot/confighandler_8h_source/","title":"File confighandler.h","text":"<p>File List &gt; src &gt; utils &gt; confighandler.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/widgets/capture/capturetoolbutton.h\"\n#include &lt;QSettings&gt;\n#include &lt;QStringList&gt;\n#include &lt;QVariant&gt;\n#include &lt;QVector&gt;\n\n#define CONFIG_GROUP_GENERAL \"General\"\n#define CONFIG_GROUP_SHORTCUTS \"Shortcuts\"\n\nclass QFileSystemWatcher;\nclass ValueHandler;\ntemplate&lt;class T&gt;\nclass QSharedPointer;\nclass QTextStream;\nclass AbstractLogger;\n\n// clang-format off\n#define CONFIG_GETTER(KEY, TYPE)                                               \\\n    TYPE KEY()                                                                 \\\n    {                                                                          \\\n        return value(QStringLiteral(#KEY)).value&lt;TYPE&gt;();                      \\\n    }\n// clang-format on\n\n#define CONFIG_SETTER(FUNC, KEY, TYPE)                                         \\\n    void FUNC(const TYPE&amp; val)                                                 \\\n    {                                                                          \\\n        QString key = QStringLiteral(#KEY);                                    \\\n        /* Without this check, multiple `flameshot gui` instances running */   \\\n        /* simultaneously would cause an endless loop of fileWatcher calls */  \\\n        if (QVariant::fromValue(val) != value(key)) {                          \\\n            setValue(key, QVariant::fromValue(val));                           \\\n        }                                                                      \\\n    }\n\n#define CONFIG_GETTER_SETTER(GETFUNC, SETFUNC, TYPE)                           \\\n    CONFIG_GETTER(GETFUNC, TYPE)                                               \\\n    CONFIG_SETTER(SETFUNC, GETFUNC, TYPE)\n\nclass ConfigHandler : public QObject\n{\n    Q_OBJECT\n\npublic:\n    explicit ConfigHandler();\n\n    static ConfigHandler* getInstance();\n\n    // Definitions of getters and setters for config options\n    // Some special cases are implemented regularly, without the macro\n    // NOTE: When adding new options, make sure to add an entry in\n    // recognizedGeneralOptions in the cpp file.\n    CONFIG_GETTER_SETTER(userColors, setUserColors, QVector&lt;QColor&gt;);\n    CONFIG_GETTER_SETTER(savePath, setSavePath, QString)\n    CONFIG_GETTER_SETTER(savePathFixed, setSavePathFixed, bool)\n    CONFIG_GETTER_SETTER(uiColor, setUiColor, QColor)\n    CONFIG_GETTER_SETTER(contrastUiColor, setContrastUiColor, QColor)\n    CONFIG_GETTER_SETTER(drawColor, setDrawColor, QColor)\n    CONFIG_GETTER_SETTER(predefinedColorPaletteLarge,\n                         setPredefinedColorPaletteLarge,\n                         bool)\n    CONFIG_GETTER_SETTER(fontFamily, setFontFamily, QString)\n    CONFIG_GETTER_SETTER(showHelp, setShowHelp, bool)\n    CONFIG_GETTER_SETTER(showSidePanelButton, setShowSidePanelButton, bool)\n    CONFIG_GETTER_SETTER(showDesktopNotification,\n                         setShowDesktopNotification,\n                         bool)\n    CONFIG_GETTER_SETTER(filenamePattern, setFilenamePattern, QString)\n    CONFIG_GETTER_SETTER(disabledTrayIcon, setDisabledTrayIcon, bool)\n    CONFIG_GETTER_SETTER(disabledGrimWarning, disabledGrimWarning, bool)\n    CONFIG_GETTER_SETTER(drawThickness, setDrawThickness, int)\n    CONFIG_GETTER_SETTER(drawFontSize, setDrawFontSize, int)\n    CONFIG_GETTER_SETTER(keepOpenAppLauncher, setKeepOpenAppLauncher, bool)\n#if !defined(DISABLE_UPDATE_CHECKER)\n    CONFIG_GETTER_SETTER(checkForUpdates, setCheckForUpdates, bool)\n#endif\n    CONFIG_GETTER_SETTER(allowMultipleGuiInstances,\n                         setAllowMultipleGuiInstances,\n                         bool)\n    CONFIG_GETTER_SETTER(autoCloseIdleDaemon, setAutoCloseIdleDaemon, bool)\n    CONFIG_GETTER_SETTER(showStartupLaunchMessage,\n                         setShowStartupLaunchMessage,\n                         bool)\n    CONFIG_GETTER_SETTER(contrastOpacity, setContrastOpacity, int)\n    CONFIG_GETTER_SETTER(copyURLAfterUpload, setCopyURLAfterUpload, bool)\n    CONFIG_GETTER_SETTER(historyConfirmationToDelete,\n                         setHistoryConfirmationToDelete,\n                         bool)\n    CONFIG_GETTER_SETTER(uploadHistoryMax, setUploadHistoryMax, int)\n    CONFIG_GETTER_SETTER(saveAfterCopy, setSaveAfterCopy, bool)\n    CONFIG_GETTER_SETTER(copyPathAfterSave, setCopyPathAfterSave, bool)\n    CONFIG_GETTER_SETTER(saveAsFileExtension, setSaveAsFileExtension, QString)\n    CONFIG_GETTER_SETTER(antialiasingPinZoom, setAntialiasingPinZoom, bool)\n    CONFIG_GETTER_SETTER(useJpgForClipboard, setUseJpgForClipboard, bool)\n    CONFIG_GETTER_SETTER(uploadWithoutConfirmation,\n                         setUploadWithoutConfirmation,\n                         bool)\n    CONFIG_GETTER_SETTER(ignoreUpdateToVersion,\n                         setIgnoreUpdateToVersion,\n                         QString)\n    CONFIG_GETTER_SETTER(undoLimit, setUndoLimit, int)\n    CONFIG_GETTER_SETTER(buttons, setButtons, QList&lt;CaptureTool::Type&gt;)\n    CONFIG_GETTER_SETTER(showMagnifier, setShowMagnifier, bool)\n    CONFIG_GETTER_SETTER(squareMagnifier, setSquareMagnifier, bool)\n    CONFIG_GETTER_SETTER(copyOnDoubleClick, setCopyOnDoubleClick, bool)\n    CONFIG_GETTER_SETTER(uploadClientSecret, setUploadClientSecret, QString)\n    CONFIG_GETTER_SETTER(saveLastRegion, setSaveLastRegion, bool)\n    CONFIG_GETTER_SETTER(showSelectionGeometry, setShowSelectionGeometry, int)\n    CONFIG_GETTER_SETTER(jpegQuality, setJpegQuality, int)\n    CONFIG_GETTER_SETTER(showSelectionGeometryHideTime,\n                         showSelectionGeometryHideTime,\n                         int)\n\n    // SPECIAL CASES\n    bool startupLaunch();\n    void setStartupLaunch(const bool);\n    void setAllTheButtons();\n    void setToolSize(CaptureTool::Type toolType, int size);\n    int toolSize(CaptureTool::Type toolType);\n\n    // DEFAULTS\n    QString filenamePatternDefault();\n    void setDefaultSettings();\n    QString configFilePath() const;\n\n    // GENERIC GETTERS AND SETTERS\n    bool setShortcut(const QString&amp; actionName, const QString&amp; shortcut);\n    QString shortcut(const QString&amp; actionName);\n    void setValue(const QString&amp; key, const QVariant&amp; value);\n    QVariant value(const QString&amp; key) const;\n    void remove(const QString&amp; key);\n    void resetValue(const QString&amp; key);\n\n    // INFO\n    static QSet&lt;QString&gt;&amp; recognizedGeneralOptions();\n    static QSet&lt;QString&gt;&amp; recognizedShortcutNames();\n    QSet&lt;QString&gt; keysFromGroup(const QString&amp; group) const;\n\n    // ERROR HANDLING\n    bool checkForErrors(AbstractLogger* log = nullptr) const;\n    bool checkUnrecognizedSettings(AbstractLogger* log = nullptr,\n                                   QList&lt;QString&gt;* offenders = nullptr) const;\n    bool checkShortcutConflicts(AbstractLogger* log = nullptr) const;\n    bool checkSemantics(AbstractLogger* log = nullptr,\n                        QList&lt;QString&gt;* offenders = nullptr) const;\n    void checkAndHandleError() const;\n    void setErrorState(bool error) const;\n    bool hasError() const;\n    QString errorMessage() const;\n\nsignals:\n    void error() const;\n    void errorResolved() const;\n    void fileChanged() const;\n\nprivate:\n    mutable QSettings m_settings;\n\n    static bool m_hasError, m_errorCheckPending, m_skipNextErrorCheck;\n    static QSharedPointer&lt;QFileSystemWatcher&gt; m_configWatcher;\n\n    void ensureFileWatched() const;\n    QSharedPointer&lt;ValueHandler&gt; valueHandler(const QString&amp; key) const;\n    void assertKeyRecognized(const QString&amp; key) const;\n    bool isShortcut(const QString&amp; key) const;\n    QString baseName(const QString&amp; key) const;\n    void cleanUnusedKeys(const QString&amp; group, const QSet&lt;QString&gt;&amp; keys) const;\n};\n\n</code></pre>"},{"location":"flameshot/desktopfileparse_8cpp/","title":"File desktopfileparse.cpp","text":"<p>FileList &gt; src &gt; utils &gt; desktopfileparse.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"desktopfileparse.h\"</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QFile&gt;</code></li> <li><code>#include &lt;QLocale&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;QTextStream&gt;</code></li> </ul>"},{"location":"flameshot/desktopfileparse_8cpp_source/","title":"File desktopfileparse.cpp","text":"<p>File List &gt; src &gt; utils &gt; desktopfileparse.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"desktopfileparse.h\"\n#include &lt;QDir&gt;\n#include &lt;QFile&gt;\n#include &lt;QLocale&gt;\n#include &lt;QString&gt;\n#include &lt;QTextStream&gt;\n\nDesktopFileParser::DesktopFileParser()\n{\n    QString locale = QLocale().name();\n    QString localeShort = QLocale().name().left(2);\n    m_localeName = QStringLiteral(\"Name[%1]\").arg(locale);\n    m_localeDescription = QStringLiteral(\"Comment[%1]\").arg(locale);\n    m_localeNameShort = QStringLiteral(\"Name[%1]\").arg(localeShort);\n    m_localeDescriptionShort = QStringLiteral(\"Comment[%1]\").arg(localeShort);\n    m_defaultIcon =\n      QIcon::fromTheme(QStringLiteral(\"application-x-executable\"));\n}\n\nDesktopAppData DesktopFileParser::parseDesktopFile(const QString&amp; fileName,\n                                                   bool&amp; ok) const\n{\n    DesktopAppData res;\n    ok = true;\n    QFile file(fileName);\n    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        ok = false;\n        return res;\n    }\n    bool nameLocaleSet = false;\n    bool descriptionLocaleSet = false;\n    bool isApplication = false;\n    bool isService = false;\n    QTextStream in(&amp;file);\n    // enter the desktop entry definition\n    while (!in.atEnd() &amp;&amp; in.readLine() != QLatin1String(\"[Desktop Entry]\")) {\n    }\n    // start parsing\n    while (!in.atEnd()) {\n        QString line = in.readLine();\n        if (line.startsWith(QLatin1String(\"Icon\"))) {\n            res.icon = QIcon::fromTheme(\n              line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed(),\n              m_defaultIcon);\n        } else if (!nameLocaleSet &amp;&amp; line.startsWith(QLatin1String(\"Name\"))) {\n            if (line.startsWith(m_localeName) ||\n                line.startsWith(m_localeNameShort)) {\n                res.name =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n                nameLocaleSet = true;\n            } else if (line.startsWith(QLatin1String(\"Name=\"))) {\n                res.name =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n            }\n        } else if (!descriptionLocaleSet &amp;&amp;\n                   line.startsWith(QLatin1String(\"Comment\"))) {\n            if (line.startsWith(m_localeDescription) ||\n                line.startsWith(m_localeDescriptionShort)) {\n                res.description =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n                descriptionLocaleSet = true;\n            } else if (line.startsWith(QLatin1String(\"Comment=\"))) {\n                res.description =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n            }\n        } else if (line.startsWith(QLatin1String(\"Exec\"))) {\n            if (line.contains(QLatin1String(\"%\"))) {\n                res.exec =\n                  line.mid(line.indexOf(QLatin1String(\"=\")) + 1).trimmed();\n            } else {\n                ok = false;\n                break;\n            }\n        } else if (line.startsWith(QLatin1String(\"Type\"))) {\n            if (line.contains(QLatin1String(\"Application\"))) {\n                isApplication = true;\n            }\n            if (line.contains(QLatin1String(\"Service\"))) {\n                isService = true;\n            }\n        } else if (line.startsWith(QLatin1String(\"Categories\"))) {\n            res.categories = line.mid(line.indexOf(QLatin1String(\"=\")) + 1)\n                               .split(QStringLiteral(\";\"));\n        } else if (line == QLatin1String(\"NoDisplay=true\")) {\n            ok = false;\n            break;\n        } else if (line == QLatin1String(\"Terminal=true\")) {\n            res.showInTerminal = true;\n        }\n        // ignore the other entries\n        else if (line.startsWith(QLatin1String(\"[\"))) {\n            break;\n        }\n    }\n    file.close();\n    if (res.exec.isEmpty() || res.name.isEmpty() ||\n        (!isApplication &amp;&amp; !isService)) {\n        ok = false;\n    }\n    return res;\n}\n\nint DesktopFileParser::processDirectory(const QDir&amp; dir)\n{\n    // Note that\n    // https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html\n    // says files must end in .desktop or .directory\n    // So filtering by .desktop stops us reading things like editor backups\n    // .kdelnk is long deprecated\n    QStringList entries =\n      dir.entryList({ \"*.desktop\" }, QDir::NoDotAndDotDot | QDir::Files);\n    bool ok;\n    int length = m_appList.length();\n    for (const QString&amp; file : entries) {\n        DesktopAppData app = parseDesktopFile(dir.absoluteFilePath(file), ok);\n        if (ok) {\n            m_appList.append(app);\n        }\n    }\n    return m_appList.length() - length;\n}\n\nQVector&lt;DesktopAppData&gt; DesktopFileParser::getAppsByCategory(\n  const QString&amp; category)\n{\n    QVector&lt;DesktopAppData&gt; res;\n    for (const DesktopAppData&amp; app : qAsConst(m_appList)) {\n        if (app.categories.contains(category)) {\n            res.append(app);\n        }\n    }\n    return res;\n}\n\nQMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; DesktopFileParser::getAppsByCategory(\n  const QStringList&amp; categories)\n{\n    QMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; res;\n    for (const DesktopAppData&amp; app : qAsConst(m_appList)) {\n        for (const QString&amp; category : categories) {\n            if (app.categories.contains(category)) {\n                res[category].append(app);\n            }\n        }\n    }\n    return res;\n}\n\n</code></pre>"},{"location":"flameshot/desktopfileparse_8h/","title":"File desktopfileparse.h","text":"<p>FileList &gt; src &gt; utils &gt; desktopfileparse.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QStringList&gt;</code></li> </ul>"},{"location":"flameshot/desktopfileparse_8h/#classes","title":"Classes","text":"Type Name struct DesktopAppData struct DesktopFileParser"},{"location":"flameshot/desktopfileparse_8h_source/","title":"File desktopfileparse.h","text":"<p>File List &gt; src &gt; utils &gt; desktopfileparse.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QIcon&gt;\n#include &lt;QMap&gt;\n#include &lt;QStringList&gt;\n\nclass QDir;\nclass QString;\nclass QTextStream;\n\nstruct DesktopAppData\n{\n    DesktopAppData()\n      : showInTerminal()\n    {}\n\n    DesktopAppData(const QString&amp; name,\n                   const QString&amp; description,\n                   const QString&amp; exec,\n                   QIcon icon)\n      : name(name)\n      , description(description)\n      , exec(exec)\n      , icon(icon)\n      , showInTerminal(false)\n    {}\n\n    bool operator==(const DesktopAppData&amp; other) const\n    {\n        return name == other.name;\n    }\n\n    QString name;\n    QString description;\n    QString exec;\n    QStringList categories;\n    QIcon icon;\n    bool showInTerminal;\n};\n\nstruct DesktopFileParser\n{\n    DesktopFileParser();\n    DesktopAppData parseDesktopFile(const QString&amp; fileName, bool&amp; ok) const;\n    int processDirectory(const QDir&amp; dir);\n\n    QVector&lt;DesktopAppData&gt; getAppsByCategory(const QString&amp; category);\n    QMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; getAppsByCategory(\n      const QStringList&amp; categories);\n\nprivate:\n    QString m_localeName;\n    QString m_localeDescription;\n    QString m_localeNameShort;\n    QString m_localeDescriptionShort;\n\n    QIcon m_defaultIcon;\n    QVector&lt;DesktopAppData&gt; m_appList;\n};\n\n</code></pre>"},{"location":"flameshot/desktopinfo_8cpp/","title":"File desktopinfo.cpp","text":"<p>FileList &gt; src &gt; utils &gt; desktopinfo.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"desktopinfo.h\"</code></li> <li><code>#include &lt;QProcessEnvironment&gt;</code></li> </ul>"},{"location":"flameshot/desktopinfo_8cpp_source/","title":"File desktopinfo.cpp","text":"<p>File List &gt; src &gt; utils &gt; desktopinfo.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"desktopinfo.h\"\n#include &lt;QProcessEnvironment&gt;\n\nDesktopInfo::DesktopInfo()\n{\n    auto e = QProcessEnvironment::systemEnvironment();\n    XDG_CURRENT_DESKTOP = e.value(QStringLiteral(\"XDG_CURRENT_DESKTOP\"));\n    XDG_SESSION_TYPE = e.value(QStringLiteral(\"XDG_SESSION_TYPE\"));\n    WAYLAND_DISPLAY = e.value(QStringLiteral(\"WAYLAND_DISPLAY\"));\n    KDE_FULL_SESSION = e.value(QStringLiteral(\"KDE_FULL_SESSION\"));\n    GNOME_DESKTOP_SESSION_ID =\n      e.value(QStringLiteral(\"GNOME_DESKTOP_SESSION_ID\"));\n    DESKTOP_SESSION = e.value(QStringLiteral(\"DESKTOP_SESSION\"));\n}\n\nbool DesktopInfo::waylandDetected()\n{\n    return XDG_SESSION_TYPE == QLatin1String(\"wayland\") ||\n           WAYLAND_DISPLAY.contains(QLatin1String(\"wayland\"),\n                                    Qt::CaseInsensitive);\n}\n\nDesktopInfo::WM DesktopInfo::windowManager()\n{\n    DesktopInfo::WM res = DesktopInfo::OTHER;\n    QStringList desktops = XDG_CURRENT_DESKTOP.split(QChar(':'));\n    for (auto&amp; desktop : desktops) {\n        if (desktop.contains(QLatin1String(\"GNOME\"), Qt::CaseInsensitive)) {\n            return DesktopInfo::GNOME;\n        }\n        if (desktop.contains(QLatin1String(\"qtile\"), Qt::CaseInsensitive)) {\n            return DesktopInfo::QTILE;\n        }\n        if (desktop.contains(QLatin1String(\"sway\"), Qt::CaseInsensitive)) {\n            return DesktopInfo::SWAY;\n        }\n        if (desktop.contains(QLatin1String(\"Hyprland\"), Qt::CaseInsensitive)) {\n            return DesktopInfo::HYPRLAND;\n        }\n        if (desktop.contains(QLatin1String(\"kde-plasma\"))) {\n            return DesktopInfo::KDE;\n        }\n    }\n\n    if (!GNOME_DESKTOP_SESSION_ID.isEmpty()) {\n        return DesktopInfo::GNOME;\n    }\n\n    if (!KDE_FULL_SESSION.isEmpty()) {\n        return DesktopInfo::KDE;\n    }\n\n    return res;\n}\n\n</code></pre>"},{"location":"flameshot/desktopinfo_8h/","title":"File desktopinfo.h","text":"<p>FileList &gt; src &gt; utils &gt; desktopinfo.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QString&gt;</code></li> </ul>"},{"location":"flameshot/desktopinfo_8h/#classes","title":"Classes","text":"Type Name class DesktopInfo"},{"location":"flameshot/desktopinfo_8h_source/","title":"File desktopinfo.h","text":"<p>File List &gt; src &gt; utils &gt; desktopinfo.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QString&gt;\n\nclass DesktopInfo\n{\npublic:\n    DesktopInfo();\n\n    enum WM\n    {\n        GNOME,\n        KDE,\n        OTHER,\n        QTILE,\n        SWAY,\n        HYPRLAND\n    };\n\n    bool waylandDetected();\n    WM windowManager();\n\nprivate:\n    QString XDG_CURRENT_DESKTOP;\n    QString XDG_SESSION_TYPE;\n    QString WAYLAND_DISPLAY;\n    QString KDE_FULL_SESSION;\n    QString GNOME_DESKTOP_SESSION_ID;\n    QString GDMSESSION;\n    QString DESKTOP_SESSION;\n};\n\n</code></pre>"},{"location":"flameshot/filenamehandler_8cpp/","title":"File filenamehandler.cpp","text":"<p>FileList &gt; src &gt; utils &gt; filenamehandler.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"filenamehandler.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/strfparse.h\"</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;exception&gt;</code></li> <li><code>#include &lt;locale&gt;</code></li> </ul>"},{"location":"flameshot/filenamehandler_8cpp_source/","title":"File filenamehandler.cpp","text":"<p>File List &gt; src &gt; utils &gt; filenamehandler.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"filenamehandler.h\"\n#include \"abstractlogger.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/strfparse.h\"\n#include &lt;QDir&gt;\n#include &lt;ctime&gt;\n#include &lt;exception&gt;\n#include &lt;locale&gt;\n\nFileNameHandler::FileNameHandler(QObject* parent)\n  : QObject(parent)\n{\n    auto err = AbstractLogger::error(AbstractLogger::Stderr);\n    try {\n        std::locale::global(std::locale());\n    } catch (std::exception&amp; e) {\n        err &lt;&lt; \"Locales on your system are not properly configured. Falling \"\n               \"back to defaults\";\n\n        std::locale::global(std::locale(\"en_US.UTF-8\"));\n    }\n}\n\nQString FileNameHandler::parsedPattern()\n{\n    return parseFilename(ConfigHandler().filenamePattern());\n}\n\nQString FileNameHandler::parseFilename(const QString&amp; name)\n{\n    QString res = name;\n    if (name.isEmpty()) {\n        res = ConfigHandler().filenamePatternDefault();\n    }\n\n    // remove trailing characters '%' in the pattern\n    while (res.endsWith('%')) {\n        res.chop(1);\n    }\n\n    res =\n      QString::fromStdString(strfparse::format_time_string(name.toStdString()));\n\n    // add the parsed pattern in a correct format for the filesystem\n    res = res.replace(QLatin1String(\"/\"), QStringLiteral(\"\u2044\"))\n            .replace(QLatin1String(\":\"), QLatin1String(\"-\"));\n    return res;\n}\n\nQString FileNameHandler::properScreenshotPath(QString path,\n                                              const QString&amp; format)\n{\n    QFileInfo info(path);\n    QString suffix = info.suffix();\n\n    if (info.isDir()) {\n        // path is a directory =&gt; generate filename from configured pattern\n        path = QDir(QDir(path).absolutePath() + \"/\" + parsedPattern()).path();\n    } else {\n        // path points to a file =&gt; strip it of its suffix for now\n        path = QDir(info.dir().absolutePath() + \"/\" + info.completeBaseName())\n                 .path();\n    }\n\n    if (!format.isEmpty()) {\n        // Override suffix to match format\n        path += \".\" + format;\n    } else if (!suffix.isEmpty()) {\n        // Leave the suffix as it was\n        path += \".\" + suffix;\n    } else {\n        path += \".png\";\n    }\n\n    if (!QFileInfo::exists(path)) {\n        return path;\n    } else {\n        return autoNumerateDuplicate(path);\n    }\n}\n\nQString FileNameHandler::autoNumerateDuplicate(const QString&amp; path)\n{\n    // add numeration in case of repeated filename in the directory\n    // find unused name adding _n where n is a number\n    QFileInfo checkFile(path);\n    QString directory = checkFile.dir().absolutePath(),\n            filename = checkFile.completeBaseName(),\n            suffix = checkFile.suffix();\n    if (!suffix.isEmpty()) {\n        suffix = QStringLiteral(\".\") + suffix;\n    }\n    if (checkFile.exists()) {\n        filename += QLatin1String(\"_\");\n        int i = 1;\n        while (true) {\n            checkFile.setFile(directory + \"/\" + filename + QString::number(i) +\n                              suffix);\n            if (!checkFile.exists()) {\n                filename += QString::number(i);\n                break;\n            }\n            ++i;\n        }\n    }\n    return checkFile.filePath();\n}\n\n</code></pre>"},{"location":"flameshot/filenamehandler_8h/","title":"File filenamehandler.h","text":"<p>FileList &gt; src &gt; utils &gt; filenamehandler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/filenamehandler_8h/#classes","title":"Classes","text":"Type Name class FileNameHandler"},{"location":"flameshot/filenamehandler_8h_source/","title":"File filenamehandler.h","text":"<p>File List &gt; src &gt; utils &gt; filenamehandler.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QObject&gt;\n\nclass FileNameHandler : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit FileNameHandler(QObject* parent = nullptr);\n\n    QString parsedPattern();\n    QString parseFilename(const QString&amp; name);\n\n    QString properScreenshotPath(QString filename,\n                                 const QString&amp; format = QString());\n\n    static const int MAX_CHARACTERS = 70;\n\nprivate:\n    QString autoNumerateDuplicate(const QString&amp; path);\n};\n\n</code></pre>"},{"location":"flameshot/globalvalues_8cpp/","title":"File globalvalues.cpp","text":"<p>FileList &gt; src &gt; utils &gt; globalvalues.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QFontMetrics&gt;</code></li> </ul>"},{"location":"flameshot/globalvalues_8cpp_source/","title":"File globalvalues.cpp","text":"<p>File List &gt; src &gt; utils &gt; globalvalues.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"globalvalues.h\"\n#include &lt;QApplication&gt;\n#include &lt;QFontMetrics&gt;\n\nint GlobalValues::buttonBaseSize()\n{\n    return QApplication::fontMetrics().lineSpacing() * 2.2;\n}\n\nQString GlobalValues::versionInfo()\n{\n    return QStringLiteral(\"Flameshot \" APP_VERSION \" (\" FLAMESHOT_GIT_HASH \")\"\n                          \"\\nCompiled with Qt \" QT_VERSION_STR);\n}\n\nQString GlobalValues::iconPath()\n{\n#if USE_MONOCHROME_ICON\n    return QString(\":img/app/flameshot.monochrome.svg\");\n#else\n    return { \":img/app/flameshot.svg\" };\n#endif\n}\n\nQString GlobalValues::iconPathPNG()\n{\n#if USE_MONOCHROME_ICON\n    return QString(\":img/app/flameshot.monochrome.png\");\n#else\n    return { \":img/app/flameshot.png\" };\n#endif\n}\n\n</code></pre>"},{"location":"flameshot/globalvalues_8h/","title":"File globalvalues.h","text":"<p>FileList &gt; src &gt; utils &gt; globalvalues.h</p> <p>Go to the source code of this file.</p>"},{"location":"flameshot/globalvalues_8h/#namespaces","title":"Namespaces","text":"Type Name namespace GlobalValues"},{"location":"flameshot/globalvalues_8h_source/","title":"File globalvalues.h","text":"<p>File List &gt; src &gt; utils &gt; globalvalues.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\nclass QString;\n\nnamespace GlobalValues {\n\nint buttonBaseSize();\nQString versionInfo();\nQString iconPath();\nQString iconPathPNG();\n}\n\n</code></pre>"},{"location":"flameshot/history_8cpp/","title":"File history.cpp","text":"<p>FileList &gt; src &gt; utils &gt; history.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"history.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QFile&gt;</code></li> <li><code>#include &lt;QProcessEnvironment&gt;</code></li> <li><code>#include &lt;QStringList&gt;</code></li> </ul>"},{"location":"flameshot/history_8cpp_source/","title":"File history.cpp","text":"<p>File List &gt; src &gt; utils &gt; history.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"history.h\"\n#include \"src/utils/confighandler.h\"\n#include &lt;QDir&gt;\n#include &lt;QFile&gt;\n#include &lt;QProcessEnvironment&gt;\n#include &lt;QStringList&gt;\n\nHistory::History()\n{\n    // Get cache history path\n    ConfigHandler config;\n#ifdef Q_OS_WIN\n    m_historyPath = QDir::homePath() + \"/AppData/Roaming/flameshot/history/\";\n#else\n    QString cachepath = QProcessEnvironment::systemEnvironment().value(\n      \"XDG_CACHE_HOME\", QDir::homePath() + \"/.cache\");\n    m_historyPath = cachepath + \"/flameshot/history/\";\n#endif\n\n    // Check if directory for history exists and create if doesn't\n    QDir dir = QDir(m_historyPath);\n    if (!dir.exists()) {\n        dir.mkpath(\".\");\n    }\n}\n\nconst QString&amp; History::path()\n{\n    return m_historyPath;\n}\n\nvoid History::save(const QPixmap&amp; pixmap, const QString&amp; fileName)\n{\n    // scale preview only in local disk\n    QPixmap pixmapScaled = QPixmap(pixmap);\n    if (pixmap.height() / HISTORYPIXMAP_MAX_PREVIEW_HEIGHT &gt;=\n        pixmap.width() / HISTORYPIXMAP_MAX_PREVIEW_WIDTH) {\n        pixmapScaled = pixmap.scaledToHeight(HISTORYPIXMAP_MAX_PREVIEW_HEIGHT,\n                                             Qt::SmoothTransformation);\n    } else {\n        pixmapScaled = pixmap.scaledToWidth(HISTORYPIXMAP_MAX_PREVIEW_WIDTH,\n                                            Qt::SmoothTransformation);\n    }\n\n    // save preview\n    QFile file(path() + fileName);\n    file.open(QIODevice::WriteOnly);\n    pixmapScaled.save(&amp;file, \"PNG\");\n\n    history();\n}\n\nconst QList&lt;QString&gt;&amp; History::history()\n{\n    QDir directory(path());\n    QStringList images = directory.entryList(QStringList() &lt;&lt; \"*.png\"\n                                                           &lt;&lt; \"*.PNG\",\n                                             QDir::Files,\n                                             QDir::Time);\n    int cnt = 0;\n    int max = ConfigHandler().uploadHistoryMax();\n    m_thumbs.clear();\n    foreach (QString fileName, images) {\n        if (++cnt &lt;= max) {\n            m_thumbs.append(fileName);\n        } else {\n            QFile file(path() + fileName);\n            file.remove();\n        }\n    }\n    return m_thumbs;\n}\n\nconst HistoryFileName&amp; History::unpackFileName(const QString&amp; fileNamePacked)\n{\n    int nPathIndex = fileNamePacked.lastIndexOf(\"/\");\n    QStringList unpackedFileName;\n    if (nPathIndex == -1) {\n        unpackedFileName = fileNamePacked.split(\"-\");\n    } else {\n        unpackedFileName = fileNamePacked.mid(nPathIndex + 1).split(\"-\");\n    }\n\n    switch (unpackedFileName.length()) {\n        case 3:\n            m_unpackedFileName.file = unpackedFileName[2];\n            m_unpackedFileName.token = unpackedFileName[1];\n            m_unpackedFileName.type = unpackedFileName[0];\n            break;\n        case 2:\n            m_unpackedFileName.file = unpackedFileName[1];\n            m_unpackedFileName.token = \"\";\n            m_unpackedFileName.type = unpackedFileName[0];\n            break;\n        default:\n            m_unpackedFileName.file = unpackedFileName[0];\n            m_unpackedFileName.token = \"\";\n            m_unpackedFileName.type = \"\";\n            break;\n    }\n    return m_unpackedFileName;\n}\n\nconst QString&amp; History::packFileName(const QString&amp; storageType,\n                                     const QString&amp; deleteToken,\n                                     const QString&amp; fileName)\n{\n    m_packedFileName = fileName;\n    if (storageType.length() &gt; 0) {\n        if (deleteToken.length() &gt; 0) {\n            m_packedFileName =\n              storageType + \"-\" + deleteToken + \"-\" + m_packedFileName;\n        } else {\n            m_packedFileName = storageType + \"-\" + m_packedFileName;\n        }\n    }\n    return m_packedFileName;\n}\n\n</code></pre>"},{"location":"flameshot/history_8h/","title":"File history.h","text":"<p>FileList &gt; src &gt; utils &gt; history.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QList&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> </ul>"},{"location":"flameshot/history_8h/#classes","title":"Classes","text":"Type Name class History struct HistoryFileName"},{"location":"flameshot/history_8h/#macros","title":"Macros","text":"Type Name define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT  100 define HISTORYPIXMAP_MAX_PREVIEW_WIDTH  250"},{"location":"flameshot/history_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/history_8h/#define-historypixmap_max_preview_height","title":"define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT","text":"<pre><code>#define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100\n</code></pre>"},{"location":"flameshot/history_8h/#define-historypixmap_max_preview_width","title":"define HISTORYPIXMAP_MAX_PREVIEW_WIDTH","text":"<pre><code>#define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250\n</code></pre>"},{"location":"flameshot/history_8h_source/","title":"File history.h","text":"<p>File List &gt; src &gt; utils &gt; history.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#ifndef HISTORY_H\n#define HISTORY_H\n\n#define HISTORYPIXMAP_MAX_PREVIEW_WIDTH 250\n#define HISTORYPIXMAP_MAX_PREVIEW_HEIGHT 100\n\n#include &lt;QList&gt;\n#include &lt;QPixmap&gt;\n#include &lt;QString&gt;\n\nstruct HistoryFileName\n{\n    QString file;\n    QString token;\n    QString type;\n};\n\nclass History\n{\npublic:\n    History();\n\n    void save(const QPixmap&amp;, const QString&amp;);\n    const QList&lt;QString&gt;&amp; history();\n    const QString&amp; path();\n\n    const HistoryFileName&amp; unpackFileName(const QString&amp;);\n    const QString&amp; packFileName(const QString&amp;, const QString&amp;, const QString&amp;);\n\nprivate:\n    QString m_historyPath;\n    QList&lt;QString&gt; m_thumbs;\n\n    // temporary variables\n    QString m_packedFileName;\n    HistoryFileName m_unpackedFileName;\n};\n\n#endif // HISTORY_H\n\n</code></pre>"},{"location":"flameshot/pathinfo_8cpp/","title":"File pathinfo.cpp","text":"<p>FileList &gt; src &gt; utils &gt; pathinfo.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"pathinfo.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QFileInfo&gt;</code></li> </ul>"},{"location":"flameshot/pathinfo_8cpp_source/","title":"File pathinfo.cpp","text":"<p>File List &gt; src &gt; utils &gt; pathinfo.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"pathinfo.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDir&gt;\n#include &lt;QFileInfo&gt;\n\nconst QString PathInfo::whiteIconPath()\n{\n    return QStringLiteral(\":/img/material/white/\");\n}\n\nconst QString PathInfo::blackIconPath()\n{\n    return QStringLiteral(\":/img/material/black/\");\n}\n\nQStringList PathInfo::translationsPaths()\n{\n    QString binaryPath =\n      QFileInfo(qApp-&gt;applicationDirPath()).absoluteFilePath();\n    QString trPath = QDir::toNativeSeparators(binaryPath + \"/translations\");\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    return QStringList()\n           &lt;&lt; QStringLiteral(APP_PREFIX) + \"/share/flameshot/translations\"\n           &lt;&lt; trPath &lt;&lt; QStringLiteral(\"/usr/share/flameshot/translations\")\n           &lt;&lt; QStringLiteral(\"/usr/local/share/flameshot/translations\");\n#endif\n    return QStringList() &lt;&lt; trPath;\n}\n\n</code></pre>"},{"location":"flameshot/pathinfo_8h/","title":"File pathinfo.h","text":"<p>FileList &gt; src &gt; utils &gt; pathinfo.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QStringList&gt;</code></li> </ul>"},{"location":"flameshot/pathinfo_8h/#namespaces","title":"Namespaces","text":"Type Name namespace PathInfo"},{"location":"flameshot/pathinfo_8h_source/","title":"File pathinfo.h","text":"<p>File List &gt; src &gt; utils &gt; pathinfo.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QStringList&gt;\n\nnamespace PathInfo { // namespace\n\nconst QString whiteIconPath();\n\nconst QString blackIconPath();\n\nQStringList translationsPaths();\n\n} // namespace\n\n</code></pre>"},{"location":"flameshot/request_8cpp/","title":"File request.cpp","text":"<p>FileList &gt; src &gt; utils &gt; request.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"request.h\"</code></li> </ul>"},{"location":"flameshot/request_8cpp_source/","title":"File request.cpp","text":"<p>File List &gt; src &gt; utils &gt; request.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n//\n// Created by nullobsi on 2021/02/01.\n//\n/*\n * Implementation of interface class OrgFreedesktopPortalRequestInterface\n */\n\n#include \"request.h\"\nOrgFreedesktopPortalRequestInterface::OrgFreedesktopPortalRequestInterface(\n  const QString&amp; service,\n  const QString&amp; path,\n  const QDBusConnection&amp; connection,\n  QObject* parent)\n  : QDBusAbstractInterface(service,\n                           path,\n                           staticInterfaceName(),\n                           connection,\n                           parent)\n{}\n\nOrgFreedesktopPortalRequestInterface::~OrgFreedesktopPortalRequestInterface() =\n  default;\n\n</code></pre>"},{"location":"flameshot/request_8h/","title":"File request.h","text":"<p>FileList &gt; src &gt; utils &gt; request.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QtCore/QByteArray&gt;</code></li> <li><code>#include &lt;QtCore/QList&gt;</code></li> <li><code>#include &lt;QtCore/QMap&gt;</code></li> <li><code>#include &lt;QtCore/QObject&gt;</code></li> <li><code>#include &lt;QtCore/QString&gt;</code></li> <li><code>#include &lt;QtCore/QStringList&gt;</code></li> <li><code>#include &lt;QtCore/QVariant&gt;</code></li> <li><code>#include &lt;QtDBus/QtDBus&gt;</code></li> </ul>"},{"location":"flameshot/request_8h/#namespaces","title":"Namespaces","text":"Type Name namespace org namespace freedesktop namespace portal"},{"location":"flameshot/request_8h/#classes","title":"Classes","text":"Type Name class OrgFreedesktopPortalRequestInterface"},{"location":"flameshot/request_8h_source/","title":"File request.h","text":"<p>File List &gt; src &gt; utils &gt; request.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n/*\n * This file was generated by qdbusxml2cpp version 0.8\n * Command line was: qdbusxml2cpp -p response.cpp resp.xml\n *\n * qdbusxml2cpp is Copyright (C) 2020 The Qt Company Ltd.\n *\n * This is an auto-generated file.\n * Do not edit! All changes made to it will be lost.\n */\n\n#ifndef RESPONSE_CPP\n#define RESPONSE_CPP\n#include &lt;QtCore/QByteArray&gt;\n#include &lt;QtCore/QList&gt;\n#include &lt;QtCore/QMap&gt;\n#include &lt;QtCore/QObject&gt;\n#include &lt;QtCore/QString&gt;\n#include &lt;QtCore/QStringList&gt;\n#include &lt;QtCore/QVariant&gt;\n#include &lt;QtDBus/QtDBus&gt;\n\n/*\n * Proxy class for interface org.freedesktop.portal.Request\n */\nclass OrgFreedesktopPortalRequestInterface : public QDBusAbstractInterface\n{\n    Q_OBJECT\npublic:\n    static inline const char* staticInterfaceName()\n    {\n        return \"org.freedesktop.portal.Request\";\n    }\n\npublic:\n    OrgFreedesktopPortalRequestInterface(const QString&amp; service,\n                                         const QString&amp; path,\n                                         const QDBusConnection&amp; connection,\n                                         QObject* parent = nullptr);\n\n    ~OrgFreedesktopPortalRequestInterface();\n\npublic Q_SLOTS: // METHODS\n    inline QDBusPendingReply&lt;&gt; Close()\n    {\n        QList&lt;QVariant&gt; argumentList;\n        return asyncCallWithArgumentList(QStringLiteral(\"Close\"), argumentList);\n    }\n\nQ_SIGNALS: // SIGNALS\n    void Response(uint response, QVariantMap results);\n};\n\nnamespace org {\nnamespace freedesktop {\nnamespace portal {\ntypedef ::OrgFreedesktopPortalRequestInterface Request;\n}\n}\n}\n#endif\n\n</code></pre>"},{"location":"flameshot/screengrabber_8cpp/","title":"File screengrabber.cpp","text":"<p>FileList &gt; src &gt; utils &gt; screengrabber.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"screengrabber.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/filenamehandler.h\"</code></li> <li><code>#include \"src/utils/systemnotification.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDesktopWidget&gt;</code></li> <li><code>#include &lt;QGuiApplication&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QProcess&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/screengrabber_8cpp_source/","title":"File screengrabber.cpp","text":"<p>File List &gt; src &gt; utils &gt; screengrabber.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"screengrabber.h\"\n#include \"abstractlogger.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/filenamehandler.h\"\n#include \"src/utils/systemnotification.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDesktopWidget&gt;\n#include &lt;QGuiApplication&gt;\n#include &lt;QPixmap&gt;\n#include &lt;QProcess&gt;\n#include &lt;QScreen&gt;\n\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n#include \"request.h\"\n#include &lt;QDBusInterface&gt;\n#include &lt;QDBusReply&gt;\n#include &lt;QDir&gt;\n#include &lt;QUrl&gt;\n#include &lt;QUuid&gt;\n#endif\n\nScreenGrabber::ScreenGrabber(QObject* parent)\n  : QObject(parent)\n{}\n\nvoid ScreenGrabber::generalGrimScreenshot(bool&amp; ok, QPixmap&amp; res)\n{\n#ifdef USE_WAYLAND_GRIM\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    QProcess Process;\n    QString program = \"grim\";\n    QStringList arguments;\n    arguments &lt;&lt; \"-\";\n    Process.start(program, arguments);\n    if (Process.waitForFinished()) {\n        res.loadFromData(Process.readAll());\n        ok = true;\n    } else {\n        ok = false;\n        AbstractLogger::error()\n          &lt;&lt; tr(\"The universal wayland screen capture adapter requires Grim as \"\n                \"the screen capture component of wayland. If the screen \"\n                \"capture component is missing, please install it!\");\n    }\n#endif\n#endif\n}\n\nvoid ScreenGrabber::freeDesktopPortal(bool&amp; ok, QPixmap&amp; res)\n{\n\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    QDBusInterface screenshotInterface(\n      QStringLiteral(\"org.freedesktop.portal.Desktop\"),\n      QStringLiteral(\"/org/freedesktop/portal/desktop\"),\n      QStringLiteral(\"org.freedesktop.portal.Screenshot\"));\n\n    // unique token\n    QString token =\n      QUuid::createUuid().toString().remove('-').remove('{').remove('}');\n\n    // premake interface\n    auto* request = new OrgFreedesktopPortalRequestInterface(\n      QStringLiteral(\"org.freedesktop.portal.Desktop\"),\n      \"/org/freedesktop/portal/desktop/request/\" +\n        QDBusConnection::sessionBus().baseService().remove(':').replace('.',\n                                                                        '_') +\n        \"/\" + token,\n      QDBusConnection::sessionBus(),\n      this);\n\n    QEventLoop loop;\n    const auto gotSignal = [&amp;res, &amp;loop](uint status, const QVariantMap&amp; map) {\n        if (status == 0) {\n            // Parse this as URI to handle unicode properly\n            QUrl uri = map.value(\"uri\").toString();\n            QString uriString = uri.toLocalFile();\n            res = QPixmap(uriString);\n            res.setDevicePixelRatio(qApp-&gt;devicePixelRatio());\n            QFile imgFile(uriString);\n            imgFile.remove();\n        }\n        loop.quit();\n    };\n\n    // prevent racy situations and listen before calling screenshot\n    QMetaObject::Connection conn = QObject::connect(\n      request, &amp;org::freedesktop::portal::Request::Response, gotSignal);\n\n    screenshotInterface.call(\n      QStringLiteral(\"Screenshot\"),\n      \"\",\n      QMap&lt;QString, QVariant&gt;({ { \"handle_token\", QVariant(token) },\n                                { \"interactive\", QVariant(false) } }));\n\n    loop.exec();\n    QObject::disconnect(conn);\n    request-&gt;Close().waitForFinished();\n    request-&gt;deleteLater();\n\n    if (res.isNull()) {\n        ok = false;\n    }\n#endif\n}\nQPixmap ScreenGrabber::grabEntireDesktop(bool&amp; ok)\n{\n    ok = true;\n#if defined(Q_OS_MACOS)\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    QPixmap screenPixmap(\n      currentScreen-&gt;grabWindow(QApplication::desktop()-&gt;winId(),\n                                currentScreen-&gt;geometry().x(),\n                                currentScreen-&gt;geometry().y(),\n                                currentScreen-&gt;geometry().width(),\n                                currentScreen-&gt;geometry().height()));\n    screenPixmap.setDevicePixelRatio(currentScreen-&gt;devicePixelRatio());\n    return screenPixmap;\n#elif defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n    if (m_info.waylandDetected()) {\n        QPixmap res;\n        // handle screenshot based on DE\n        switch (m_info.windowManager()) {\n            case DesktopInfo::GNOME:\n            case DesktopInfo::KDE:\n                freeDesktopPortal(ok, res);\n                break;\n            case DesktopInfo::QTILE:\n            case DesktopInfo::SWAY:\n            case DesktopInfo::HYPRLAND:\n            case DesktopInfo::OTHER: {\n#ifndef USE_WAYLAND_GRIM\n                AbstractLogger::warning() &lt;&lt; tr(\n                  \"If the USE_WAYLAND_GRIM option is not activated, the dbus \"\n                  \"protocol will be used. It should be noted that using the \"\n                  \"dbus protocol under wayland is not recommended. It is \"\n                  \"recommended to recompile with the USE_WAYLAND_GRIM flag to \"\n                  \"activate the grim-based general wayland screenshot adapter\");\n                freeDesktopPortal(ok, res);\n#else\n                if (!ConfigHandler().disabledGrimWarning()) {\n                    AbstractLogger::warning() &lt;&lt; tr(\n                      \"grim's screenshot component is implemented based on \"\n                      \"wlroots, it may not be used in GNOME or similar \"\n                      \"desktop environments\");\n                }\n                generalGrimScreenshot(ok, res);\n#endif\n                break;\n            }\n            default:\n                ok = false;\n                AbstractLogger::error()\n                  &lt;&lt; tr(\"Unable to detect desktop environment (GNOME? KDE? \"\n                        \"Qile? Sway? ...)\");\n                AbstractLogger::error()\n                  &lt;&lt; tr(\"Hint: try setting the XDG_CURRENT_DESKTOP environment \"\n                        \"variable.\");\n                break;\n        }\n        if (!ok) {\n            AbstractLogger::error() &lt;&lt; tr(\"Unable to capture screen\");\n        }\n        return res;\n    }\n#endif\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX) || defined(Q_OS_WIN)\n    QRect geometry = desktopGeometry();\n    QPixmap p(QApplication::primaryScreen()-&gt;grabWindow(\n      QApplication::desktop()-&gt;winId(),\n      geometry.x(),\n      geometry.y(),\n      geometry.width(),\n      geometry.height()));\n    auto screenNumber = QApplication::desktop()-&gt;screenNumber();\n    QScreen* screen = QApplication::screens()[screenNumber];\n    p.setDevicePixelRatio(screen-&gt;devicePixelRatio());\n    return p;\n#endif\n}\n\nQRect ScreenGrabber::screenGeometry(QScreen* screen)\n{\n    QPixmap p;\n    QRect geometry;\n    if (m_info.waylandDetected()) {\n        QPoint topLeft(0, 0);\n#ifdef Q_OS_WIN\n        for (QScreen* const screen : QGuiApplication::screens()) {\n            QPoint topLeftScreen = screen-&gt;geometry().topLeft();\n            if (topLeft.x() &gt; topLeftScreen.x() ||\n                topLeft.y() &gt; topLeftScreen.y()) {\n                topLeft = topLeftScreen;\n            }\n        }\n#endif\n        geometry = screen-&gt;geometry();\n        geometry.moveTo(geometry.topLeft() - topLeft);\n    } else {\n        QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n        geometry = currentScreen-&gt;geometry();\n    }\n    return geometry;\n}\n\nQPixmap ScreenGrabber::grabScreen(QScreen* screen, bool&amp; ok)\n{\n    QPixmap p;\n    QRect geometry = screenGeometry(screen);\n    if (m_info.waylandDetected()) {\n        p = grabEntireDesktop(ok);\n        if (ok) {\n            return p.copy(geometry);\n        }\n    } else {\n        ok = true;\n        return screen-&gt;grabWindow(QApplication::desktop()-&gt;winId(),\n                                  geometry.x(),\n                                  geometry.y(),\n                                  geometry.width(),\n                                  geometry.height());\n    }\n    return p;\n}\n\nQRect ScreenGrabber::desktopGeometry()\n{\n    QRect geometry;\n\n    for (QScreen* const screen : QGuiApplication::screens()) {\n        QRect scrRect = screen-&gt;geometry();\n        scrRect.moveTo(scrRect.x() / screen-&gt;devicePixelRatio(),\n                       scrRect.y() / screen-&gt;devicePixelRatio());\n        geometry = geometry.united(scrRect);\n    }\n    return geometry;\n}\n\n</code></pre>"},{"location":"flameshot/screengrabber_8h/","title":"File screengrabber.h","text":"<p>FileList &gt; src &gt; utils &gt; screengrabber.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/utils/desktopinfo.h\"</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/screengrabber_8h/#classes","title":"Classes","text":"Type Name class ScreenGrabber"},{"location":"flameshot/screengrabber_8h_source/","title":"File screengrabber.h","text":"<p>File List &gt; src &gt; utils &gt; screengrabber.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/utils/desktopinfo.h\"\n#include &lt;QObject&gt;\n#include &lt;QScreen&gt;\n\nclass ScreenGrabber : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit ScreenGrabber(QObject* parent = nullptr);\n    QPixmap grabEntireDesktop(bool&amp; ok);\n    QRect screenGeometry(QScreen* screen);\n    QPixmap grabScreen(QScreen* screenNumber, bool&amp; ok);\n    void freeDesktopPortal(bool&amp; ok, QPixmap&amp; res);\n    void generalGrimScreenshot(bool&amp; ok, QPixmap&amp; res);\n    QRect desktopGeometry();\n\nprivate:\n    DesktopInfo m_info;\n};\n\n</code></pre>"},{"location":"flameshot/screenshotsaver_8cpp/","title":"File screenshotsaver.cpp","text":"<p>FileList &gt; src &gt; utils &gt; screenshotsaver.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"screenshotsaver.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/filenamehandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"utils/desktopinfo.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QBuffer&gt;</code></li> <li><code>#include &lt;QClipboard&gt;</code></li> <li><code>#include &lt;QFileDialog&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QMimeData&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> <li><code>#include &lt;qimagewriter.h&gt;</code></li> <li><code>#include &lt;qmimedatabase.h&gt;</code></li> </ul>"},{"location":"flameshot/screenshotsaver_8cpp/#public-functions","title":"Public Functions","text":"Type Name QString ShowSaveFileDialog (const QString &amp; title, const QString &amp; directory)  void saveToClipboard (const QPixmap &amp; capture)  void saveToClipboardMime (const QPixmap &amp; capture, const QString &amp; imageType)  bool saveToFilesystem (const QPixmap &amp; capture, const QString &amp; path, const QString &amp; messagePrefix)  bool saveToFilesystemGUI (const QPixmap &amp; capture)"},{"location":"flameshot/screenshotsaver_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/screenshotsaver_8cpp/#function-showsavefiledialog","title":"function ShowSaveFileDialog","text":"<pre><code>QString ShowSaveFileDialog (\n    const QString &amp; title,\n    const QString &amp; directory\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetoclipboard","title":"function saveToClipboard","text":"<pre><code>void saveToClipboard (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetoclipboardmime","title":"function saveToClipboardMime","text":"<pre><code>void saveToClipboardMime (\n    const QPixmap &amp; capture,\n    const QString &amp; imageType\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetofilesystem","title":"function saveToFilesystem","text":"<pre><code>bool saveToFilesystem (\n    const QPixmap &amp; capture,\n    const QString &amp; path,\n    const QString &amp; messagePrefix\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8cpp/#function-savetofilesystemgui","title":"function saveToFilesystemGUI","text":"<pre><code>bool saveToFilesystemGUI (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8cpp_source/","title":"File screenshotsaver.cpp","text":"<p>File List &gt; src &gt; utils &gt; screenshotsaver.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"screenshotsaver.h\"\n#include \"abstractlogger.h\"\n#include \"src/core/flameshot.h\"\n#include \"src/core/flameshotdaemon.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/filenamehandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"utils/desktopinfo.h\"\n\n#if USE_WAYLAND_CLIPBOARD\n#include &lt;KSystemClipboard&gt;\n#endif\n\n#include &lt;QApplication&gt;\n#include &lt;QBuffer&gt;\n#include &lt;QClipboard&gt;\n#include &lt;QFileDialog&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QMimeData&gt;\n#include &lt;QStandardPaths&gt;\n#include &lt;qimagewriter.h&gt;\n#include &lt;qmimedatabase.h&gt;\n#if defined(Q_OS_MACOS)\n#include \"src/widgets/capture/capturewidget.h\"\n#endif\n\nbool saveToFilesystem(const QPixmap&amp; capture,\n                      const QString&amp; path,\n                      const QString&amp; messagePrefix)\n{\n    QString completePath = FileNameHandler().properScreenshotPath(\n      path, ConfigHandler().saveAsFileExtension());\n    QFile file{ completePath };\n    file.open(QIODevice::WriteOnly);\n\n    bool okay;\n    QString saveExtension;\n    saveExtension = QFileInfo(completePath).suffix().toLower();\n    if (saveExtension == \"jpg\" || saveExtension == \"jpeg\") {\n        okay = capture.save(&amp;file, nullptr, ConfigHandler().jpegQuality());\n    } else {\n        okay = capture.save(&amp;file);\n    }\n\n    QString saveMessage = messagePrefix;\n    QString notificationPath = completePath;\n    if (!saveMessage.isEmpty()) {\n        saveMessage += \" \";\n    }\n\n    if (okay) {\n        saveMessage += QObject::tr(\"Capture saved as \") + completePath;\n        AbstractLogger::info().attachNotificationPath(notificationPath)\n          &lt;&lt; saveMessage;\n    } else {\n        saveMessage += QObject::tr(\"Error trying to save as \") + completePath;\n        if (file.error() != QFile::NoError) {\n            saveMessage += \": \" + file.errorString();\n        }\n        notificationPath = \"\";\n        AbstractLogger::error().attachNotificationPath(notificationPath)\n          &lt;&lt; saveMessage;\n    }\n\n    return okay;\n}\n\nQString ShowSaveFileDialog(const QString&amp; title, const QString&amp; directory)\n{\n    QFileDialog dialog(nullptr, title, directory);\n    dialog.setAcceptMode(QFileDialog::AcceptSave);\n\n    // Build string list of supported image formats\n    QStringList mimeTypeList;\n    foreach (auto mimeType, QImageWriter::supportedMimeTypes()) {\n        // image/heif has several aliases and they cause glitch in save dialog\n        // It is necessary to keep the image/heif (otherwise HEIF plug-in from\n        // kimageformats will not work) but the aliases could be filtered out.\n        if (mimeType != \"image/heic\" &amp;&amp; mimeType != \"image/heic-sequence\" &amp;&amp;\n            mimeType != \"image/heif-sequence\") {\n            mimeTypeList.append(mimeType);\n        }\n    }\n    dialog.setMimeTypeFilters(mimeTypeList);\n\n    QString suffix = ConfigHandler().saveAsFileExtension();\n    if (suffix.isEmpty()) {\n        suffix = \"png\";\n    }\n    QString defaultMimeType =\n      QMimeDatabase().mimeTypeForFile(\"image.\" + suffix).name();\n    dialog.selectMimeTypeFilter(defaultMimeType);\n    dialog.setDefaultSuffix(suffix);\n    if (dialog.exec() == QDialog::Accepted) {\n        return dialog.selectedFiles().constFirst();\n    } else {\n        return {};\n    }\n}\n\nvoid saveToClipboardMime(const QPixmap&amp; capture, const QString&amp; imageType)\n{\n    QByteArray array;\n    QBuffer buffer{ &amp;array };\n    QImageWriter imageWriter{ &amp;buffer, imageType.toUpper().toUtf8() };\n    if (imageType == \"jpeg\") {\n        imageWriter.setQuality(ConfigHandler().jpegQuality());\n    }\n    imageWriter.write(capture.toImage());\n\n    QPixmap formattedPixmap;\n    bool isLoaded =\n      formattedPixmap.loadFromData(reinterpret_cast&lt;uchar*&gt;(array.data()),\n                                   array.size(),\n                                   imageType.toUpper().toUtf8());\n    if (isLoaded) {\n\n        auto* mimeData = new QMimeData();\n\n#ifdef USE_WAYLAND_CLIPBOARD\n        mimeData-&gt;setImageData(formattedPixmap.toImage());\n        mimeData-&gt;setData(QStringLiteral(\"x-kde-force-image-copy\"),\n                          QByteArray());\n        KSystemClipboard::instance()-&gt;setMimeData(mimeData,\n                                                  QClipboard::Clipboard);\n#else\n        mimeData-&gt;setData(\"image/\" + imageType, array);\n        QApplication::clipboard()-&gt;setMimeData(mimeData);\n#endif\n\n    } else {\n        AbstractLogger::error()\n          &lt;&lt; QObject::tr(\"Error while saving to clipboard\");\n    }\n}\n\n// If data is saved to the clipboard before the notification is sent via\n// dbus, the application freezes.\nvoid saveToClipboard(const QPixmap&amp; capture)\n{\n    // If we are able to properly save the file, save the file and copy to\n    // clipboard.\n    if ((ConfigHandler().saveAfterCopy()) &amp;&amp;\n        (!ConfigHandler().savePath().isEmpty())) {\n        saveToFilesystem(capture,\n                         ConfigHandler().savePath(),\n                         QObject::tr(\"Capture saved to clipboard.\"));\n    } else {\n        AbstractLogger() &lt;&lt; QObject::tr(\"Capture saved to clipboard.\");\n    }\n    if (ConfigHandler().useJpgForClipboard()) {\n        // FIXME - it doesn't work on MacOS\n        saveToClipboardMime(capture, \"jpeg\");\n    } else {\n        // Need to send message before copying to clipboard\n#if defined(Q_OS_LINUX) || defined(Q_OS_UNIX)\n        if (DesktopInfo().waylandDetected()) {\n            saveToClipboardMime(capture, \"png\");\n        } else {\n            QApplication::clipboard()-&gt;setPixmap(capture);\n        }\n#else\n        QApplication::clipboard()-&gt;setPixmap(capture);\n#endif\n    }\n}\n\nbool saveToFilesystemGUI(const QPixmap&amp; capture)\n{\n    bool okay = false;\n    ConfigHandler config;\n    QString defaultSavePath = ConfigHandler().savePath();\n    if (defaultSavePath.isEmpty() || !QDir(defaultSavePath).exists() ||\n        !QFileInfo(defaultSavePath).isWritable()) {\n        defaultSavePath =\n          QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);\n    }\n    QString savePath = FileNameHandler().properScreenshotPath(\n      defaultSavePath, ConfigHandler().saveAsFileExtension());\n#if defined(Q_OS_MACOS)\n    for (QWidget* widget : qApp-&gt;topLevelWidgets()) {\n        QString className(widget-&gt;metaObject()-&gt;className());\n        if (0 ==\n            className.compare(CaptureWidget::staticMetaObject.className())) {\n            widget-&gt;showNormal();\n            widget-&gt;hide();\n            break;\n        }\n    }\n#endif\n    if (!config.savePathFixed()) {\n        savePath = QDir::toNativeSeparators(\n          ShowSaveFileDialog(QObject::tr(\"Save screenshot\"), savePath));\n    }\n    if (savePath == \"\") {\n        return okay;\n    }\n\n    QFile file{ savePath };\n    file.open(QIODevice::WriteOnly);\n\n    QString saveExtension;\n    saveExtension = QFileInfo(savePath).suffix().toLower();\n    if (saveExtension == \"jpg\" || saveExtension == \"jpeg\") {\n        okay = capture.save(&amp;file, nullptr, ConfigHandler().jpegQuality());\n    } else {\n        okay = capture.save(&amp;file);\n    }\n\n    if (okay) {\n        QString pathNoFile =\n          savePath.left(savePath.lastIndexOf(QDir::separator()));\n\n        ConfigHandler().setSavePath(pathNoFile);\n\n        QString msg = QObject::tr(\"Capture saved as \") + savePath;\n        AbstractLogger().attachNotificationPath(savePath) &lt;&lt; msg;\n\n        if (config.copyPathAfterSave()) {\n            FlameshotDaemon::copyToClipboard(\n              savePath, QObject::tr(\"Path copied to clipboard as \") + savePath);\n        }\n\n    } else {\n        QString msg = QObject::tr(\"Error trying to save as \") + savePath;\n\n        if (file.error() != QFile::NoError) {\n            msg += \": \" + file.errorString();\n        }\n\n        QMessageBox saveErrBox(\n          QMessageBox::Warning, QObject::tr(\"Save Error\"), msg);\n        saveErrBox.setWindowIcon(QIcon(GlobalValues::iconPath()));\n        saveErrBox.exec();\n    }\n\n    return okay;\n}\n\n</code></pre>"},{"location":"flameshot/screenshotsaver_8h/","title":"File screenshotsaver.h","text":"<p>FileList &gt; src &gt; utils &gt; screenshotsaver.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QString&gt;</code></li> </ul>"},{"location":"flameshot/screenshotsaver_8h/#public-functions","title":"Public Functions","text":"Type Name QString ShowSaveFileDialog (const QString &amp; title, const QString &amp; directory)  void saveToClipboard (const QPixmap &amp; capture)  void saveToClipboardMime (const QPixmap &amp; capture, const QString &amp; imageType)  bool saveToFilesystem (const QPixmap &amp; capture, const QString &amp; path, const QString &amp; messagePrefix=\"\")  bool saveToFilesystemGUI (const QPixmap &amp; capture)"},{"location":"flameshot/screenshotsaver_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/screenshotsaver_8h/#function-showsavefiledialog","title":"function ShowSaveFileDialog","text":"<pre><code>QString ShowSaveFileDialog (\n    const QString &amp; title,\n    const QString &amp; directory\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8h/#function-savetoclipboard","title":"function saveToClipboard","text":"<pre><code>void saveToClipboard (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8h/#function-savetoclipboardmime","title":"function saveToClipboardMime","text":"<pre><code>void saveToClipboardMime (\n    const QPixmap &amp; capture,\n    const QString &amp; imageType\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8h/#function-savetofilesystem","title":"function saveToFilesystem","text":"<pre><code>bool saveToFilesystem (\n    const QPixmap &amp; capture,\n    const QString &amp; path,\n    const QString &amp; messagePrefix=\"\"\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8h/#function-savetofilesystemgui","title":"function saveToFilesystemGUI","text":"<pre><code>bool saveToFilesystemGUI (\n    const QPixmap &amp; capture\n) \n</code></pre>"},{"location":"flameshot/screenshotsaver_8h_source/","title":"File screenshotsaver.h","text":"<p>File List &gt; src &gt; utils &gt; screenshotsaver.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QString&gt;\n\nclass QPixmap;\n\nbool saveToFilesystem(const QPixmap&amp; capture,\n                      const QString&amp; path,\n                      const QString&amp; messagePrefix = \"\");\nQString ShowSaveFileDialog(const QString&amp; title, const QString&amp; directory);\nvoid saveToClipboardMime(const QPixmap&amp; capture, const QString&amp; imageType);\nvoid saveToClipboard(const QPixmap&amp; capture);\nbool saveToFilesystemGUI(const QPixmap&amp; capture);\n\n</code></pre>"},{"location":"flameshot/strfparse_8cpp/","title":"File strfparse.cpp","text":"<p>FileList &gt; src &gt; utils &gt; strfparse.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"strfparse.h\"</code></li> </ul>"},{"location":"flameshot/strfparse_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace strfparse"},{"location":"flameshot/strfparse_8cpp_source/","title":"File strfparse.cpp","text":"<p>File List &gt; src &gt; utils &gt; strfparse.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Jeremy Borgman\n\n#include \"strfparse.h\"\n\nnamespace strfparse {\nstd::vector&lt;std::string&gt; split(std::string const&amp; s, char delimiter)\n{\n    std::vector&lt;std::string&gt; tokens;\n    std::string token;\n    std::istringstream tokenStream(s);\n    while (std::getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nstd::vector&lt;char&gt; create_specifier_list()\n{\n\n    std::vector&lt;char&gt; allowed_specifier{ 'Y', 'H', 'a', 'A', 'b', 'B', 'c', 'C',\n                                         'd', 'D', 'e', 'F', 'g', 'G', 'h', 'H',\n                                         'I', 'j', 'm', 'M', 'n', 'p', 'r', 'R',\n                                         'S', 't', 'T', 'u', 'U', 'V', 'w', 'W',\n                                         'x', 'X', 'y', 'Y', 'z', 'Z' };\n    return allowed_specifier;\n}\n\nstd::string replace_all(std::string input,\n                        std::string const&amp; to_find,\n                        std::string const&amp; to_replace)\n{\n    size_t pos = 0;\n    while ((pos = input.find(to_find, pos)) != std::string::npos) {\n        input.replace(pos, to_find.length(), to_replace);\n        pos += to_replace.length();\n    }\n\n    return input;\n}\n\nstd::vector&lt;char&gt; match_specifiers(std::string const&amp; specifier,\n                                   std::vector&lt;char&gt; allowed_specifier)\n{\n\n    std::vector&lt;char&gt; spec_list;\n\n    for (size_t i = 0; i &lt; specifier.size() - 1; i++) {\n        if (specifier[i] == '%') {\n            spec_list.push_back(specifier[i + 1]);\n        }\n    }\n\n    std::sort(spec_list.begin(), spec_list.end());\n    std::sort(allowed_specifier.begin(), allowed_specifier.end());\n\n    std::vector&lt;char&gt; overlap;\n    std::set_intersection(spec_list.begin(),\n                          spec_list.end(),\n                          allowed_specifier.begin(),\n                          allowed_specifier.end(),\n                          back_inserter(overlap));\n\n    return overlap;\n}\n\nstd::string format_time_string(std::string const&amp; specifier)\n{\n\n    if (specifier.empty()) {\n        return \"\";\n    }\n\n    std::time_t t = std::time(nullptr);\n    char buff[100];\n\n    auto allowed_specifier = create_specifier_list();\n\n    auto overlap = match_specifiers(specifier, allowed_specifier);\n\n    // Create \"Safe\" string for strftime which is the specfiers delimited by *\n    std::string lookup_string;\n    for (auto const&amp; e : overlap) {\n        lookup_string.push_back('%');\n        lookup_string.push_back(e);\n        lookup_string.push_back('*');\n    }\n\n    std::strftime(\n      buff, sizeof(buff), lookup_string.c_str(), std::localtime(&amp;t));\n\n    std::map&lt;char, std::string&gt; lookup_table;\n    auto result = split(buff, '*');\n\n    for (size_t i = 0; i &lt; result.size(); i++) {\n        lookup_table.emplace(std::make_pair(overlap[i], result[i]));\n    }\n\n    // Sub into original string\n    std::string delim = \"%\";\n    auto output_string = specifier;\n    for (auto const&amp; row : lookup_table) {\n        auto to_find = delim + row.first;\n        output_string = replace_all(output_string, to_find, row.second);\n    }\n    return output_string;\n}\n}\n\n</code></pre>"},{"location":"flameshot/strfparse_8h/","title":"File strfparse.h","text":"<p>FileList &gt; src &gt; utils &gt; strfparse.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"flameshot/strfparse_8h/#namespaces","title":"Namespaces","text":"Type Name namespace strfparse"},{"location":"flameshot/strfparse_8h_source/","title":"File strfparse.h","text":"<p>File List &gt; src &gt; utils &gt; strfparse.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Jeremy Borgman\n\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n\nnamespace strfparse {\nstd::vector&lt;std::string&gt; split(std::string const&amp; s, char delimiter);\n\nstd::vector&lt;char&gt; create_specifier_list();\n\nstd::string replace_all(std::string input,\n                        std::string const&amp; to_find,\n                        std::string const&amp; to_replace);\n\nstd::vector&lt;char&gt; match_specifiers(std::string const&amp; specifier,\n                                   std::vector&lt;char&gt; allowed_specifier);\n\nstd::string format_time_string(std::string const&amp; specifier);\n}\n\n</code></pre>"},{"location":"flameshot/systemnotification_8cpp/","title":"File systemnotification.cpp","text":"<p>FileList &gt; src &gt; utils &gt; systemnotification.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"systemnotification.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;QDBusConnection&gt;</code></li> <li><code>#include &lt;QDBusInterface&gt;</code></li> <li><code>#include &lt;QDBusMessage&gt;</code></li> </ul>"},{"location":"flameshot/systemnotification_8cpp/#macros","title":"Macros","text":"Type Name define FLAMESHOT_ICON  \"flameshot\""},{"location":"flameshot/systemnotification_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/systemnotification_8cpp/#define-flameshot_icon","title":"define FLAMESHOT_ICON","text":"<pre><code>#define FLAMESHOT_ICON \"flameshot\"\n</code></pre>"},{"location":"flameshot/systemnotification_8cpp_source/","title":"File systemnotification.cpp","text":"<p>File List &gt; src &gt; utils &gt; systemnotification.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"systemnotification.h\"\n#include \"src/core/flameshot.h\"\n#include \"src/utils/confighandler.h\"\n#include &lt;QApplication&gt;\n#include &lt;QUrl&gt;\n\n#if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN))\n#include &lt;QDBusConnection&gt;\n#include &lt;QDBusInterface&gt;\n#include &lt;QDBusMessage&gt;\n#else\n#include \"src/core/flameshotdaemon.h\"\n#endif\n\n// work-around for snap, which cannot install icons into\n// the system folder, so instead the absolute path to the\n// icon (saved somewhere in /snap/flameshot/...) is passed\n#ifndef FLAMESHOT_ICON\n#define FLAMESHOT_ICON \"flameshot\"\n#endif\n\nSystemNotification::SystemNotification(QObject* parent)\n  : QObject(parent)\n  , m_interface(nullptr)\n{\n#if !(defined(Q_OS_MACOS) || defined(Q_OS_WIN))\n    m_interface =\n      new QDBusInterface(QStringLiteral(\"org.freedesktop.Notifications\"),\n                         QStringLiteral(\"/org/freedesktop/Notifications\"),\n                         QStringLiteral(\"org.freedesktop.Notifications\"),\n                         QDBusConnection::sessionBus(),\n                         this);\n#endif\n}\n\nvoid SystemNotification::sendMessage(const QString&amp; text,\n                                     const QString&amp; savePath)\n{\n    sendMessage(text, tr(\"Flameshot Info\"), savePath);\n}\n\nvoid SystemNotification::sendMessage(const QString&amp; text,\n                                     const QString&amp; title,\n                                     const QString&amp; savePath,\n                                     const int timeout)\n{\n    if (!ConfigHandler().showDesktopNotification()) {\n        return;\n    }\n\n#if defined(Q_OS_MACOS) || defined(Q_OS_WIN)\n    QMetaObject::invokeMethod(\n      this,\n      [&amp;]() {\n          // The call is queued to avoid recursive static initialization of\n          // Flameshot and ConfigHandler.\n          if (FlameshotDaemon::instance())\n              FlameshotDaemon::instance()-&gt;sendTrayNotification(\n                text, title, timeout);\n      },\n      Qt::QueuedConnection);\n#else\n    QList&lt;QVariant&gt; args;\n    QVariantMap hintsMap;\n    if (!savePath.isEmpty()) {\n        QUrl fullPath = QUrl::fromLocalFile(savePath);\n        // allows the notification to be dragged and dropped\n        hintsMap[QStringLiteral(\"x-kde-urls\")] =\n          QStringList({ fullPath.toString() });\n    }\n\n    args &lt;&lt; (qAppName())                 // appname\n         &lt;&lt; static_cast&lt;unsigned int&gt;(0) // id\n         &lt;&lt; FLAMESHOT_ICON               // icon\n         &lt;&lt; title                        // summary\n         &lt;&lt; text                         // body\n         &lt;&lt; QStringList()                // actions\n         &lt;&lt; hintsMap                     // hints\n         &lt;&lt; timeout;                     // timeout\n    m_interface-&gt;callWithArgumentList(\n      QDBus::AutoDetect, QStringLiteral(\"Notify\"), args);\n#endif\n}\n\n</code></pre>"},{"location":"flameshot/systemnotification_8h/","title":"File systemnotification.h","text":"<p>FileList &gt; src &gt; utils &gt; systemnotification.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/systemnotification_8h/#classes","title":"Classes","text":"Type Name class SystemNotification"},{"location":"flameshot/systemnotification_8h_source/","title":"File systemnotification.h","text":"<p>File List &gt; src &gt; utils &gt; systemnotification.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QObject&gt;\n\nclass QDBusInterface;\n\nclass SystemNotification : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit SystemNotification(QObject* parent = nullptr);\n\n    void sendMessage(const QString&amp; text, const QString&amp; savePath = {});\n\n    void sendMessage(const QString&amp; text,\n                     const QString&amp; title,\n                     const QString&amp; savePath,\n                     const int timeout = 5000);\n\nprivate:\n    QDBusInterface* m_interface;\n};\n\n</code></pre>"},{"location":"flameshot/valuehandler_8cpp/","title":"File valuehandler.cpp","text":"<p>FileList &gt; src &gt; utils &gt; valuehandler.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"valuehandler.h\"</code></li> <li><code>#include \"capturetool.h\"</code></li> <li><code>#include \"colorpickerwidget.h\"</code></li> <li><code>#include \"confighandler.h\"</code></li> <li><code>#include \"screengrabber.h\"</code></li> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QFileInfo&gt;</code></li> <li><code>#include &lt;QImageWriter&gt;</code></li> <li><code>#include &lt;QKeySequence&gt;</code></li> <li><code>#include &lt;QStandardPaths&gt;</code></li> <li><code>#include &lt;QVariant&gt;</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"flameshot/valuehandler_8cpp/#public-types","title":"Public Types","text":"Type Name typedef QList&lt; CaptureTool::Type &gt; BList typedef CaptureTool::Type BType"},{"location":"flameshot/valuehandler_8cpp/#public-functions","title":"Public Functions","text":"Type Name void sortButtons (BList &amp; buttons)"},{"location":"flameshot/valuehandler_8cpp/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"flameshot/valuehandler_8cpp/#typedef-blist","title":"typedef BList","text":"<pre><code>using BList =  QList&lt;CaptureTool::Type&gt;;\n</code></pre>"},{"location":"flameshot/valuehandler_8cpp/#typedef-btype","title":"typedef BType","text":"<pre><code>using BType =  CaptureTool::Type;\n</code></pre>"},{"location":"flameshot/valuehandler_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/valuehandler_8cpp/#function-sortbuttons","title":"function sortButtons","text":"<pre><code>void sortButtons (\n    BList &amp; buttons\n) \n</code></pre>"},{"location":"flameshot/valuehandler_8cpp_source/","title":"File valuehandler.cpp","text":"<p>File List &gt; src &gt; utils &gt; valuehandler.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"valuehandler.h\"\n#include \"capturetool.h\"\n#include \"colorpickerwidget.h\"\n#include \"confighandler.h\"\n#include \"screengrabber.h\"\n#include &lt;QColor&gt;\n#include &lt;QFileInfo&gt;\n#include &lt;QImageWriter&gt;\n#include &lt;QKeySequence&gt;\n#include &lt;QStandardPaths&gt;\n#include &lt;QVariant&gt;\n\n// VALUE HANDLER\n\nQVariant ValueHandler::value(const QVariant&amp; val)\n{\n    if (!val.isValid() || !check(val)) {\n        return fallback();\n    } else {\n        return process(val);\n    }\n}\n\nQVariant ValueHandler::fallback()\n{\n    return {};\n}\n\nQVariant ValueHandler::representation(const QVariant&amp; val)\n{\n    return val.toString();\n}\n\nQString ValueHandler::expected()\n{\n    return {};\n}\n\nQVariant ValueHandler::process(const QVariant&amp; val)\n{\n    return val;\n}\n\n// BOOL\n\nBool::Bool(bool def)\n  : m_def(def)\n{}\n\nbool Bool::check(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    if (str != \"true\" &amp;&amp; str != \"false\") {\n        return false;\n    }\n    return true;\n}\n\nQVariant Bool::fallback()\n{\n    return m_def;\n}\n\nQString Bool::expected()\n{\n    return QStringLiteral(\"true or false\");\n}\n\n// STRING\n\nString::String(QString def)\n  : m_def(std::move(def))\n{}\n\nbool String::check(const QVariant&amp;)\n{\n    return true;\n}\n\nQVariant String::fallback()\n{\n    return m_def;\n}\n\nQString String::expected()\n{\n    return QStringLiteral(\"string\");\n}\n\n// COLOR\n\nColor::Color(QColor def)\n  : m_def(std::move(def))\n{}\n\nbool Color::check(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    // Disable #RGB, #RRRGGGBBB and #RRRRGGGGBBBB formats that QColor supports\n    return QColor::isValidColor(str) &amp;&amp;\n           (str[0] != '#' ||\n            (str.length() != 4 &amp;&amp; str.length() != 10 &amp;&amp; str.length() != 13));\n}\n\nQVariant Color::process(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    QColor color(str);\n    if (str.length() == 9 &amp;&amp; str[0] == '#') {\n        // Convert #RRGGBBAA (flameshot) to #AARRGGBB (QColor)\n        int blue = color.blue();\n        color.setBlue(color.green());\n        color.setGreen(color.red());\n        color.setRed(color.alpha());\n        color.setAlpha(blue);\n    }\n    return color;\n}\n\nQVariant Color::fallback()\n{\n    return m_def;\n}\n\nQVariant Color::representation(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    QColor color(str);\n    if (str.length() == 9 &amp;&amp; str[0] == '#') {\n        // Convert #AARRGGBB (QColor) to #RRGGBBAA (flameshot)\n        int alpha = color.alpha();\n        color.setAlpha(color.red());\n        color.setRed(color.green());\n        color.setGreen(color.blue());\n        color.setBlue(alpha);\n    }\n    return color.name();\n}\n\nQString Color::expected()\n{\n    return QStringLiteral(\"color name or hex value\");\n}\n\n// BOUNDED INT\n\nBoundedInt::BoundedInt(int min, int max, int def)\n  : m_min(min)\n  , m_max(max)\n  , m_def(def)\n{}\n\nbool BoundedInt::check(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    bool conversionOk;\n    int num = str.toInt(&amp;conversionOk);\n    return conversionOk &amp;&amp; m_min &lt;= num &amp;&amp; num &lt;= m_max;\n}\n\nQVariant BoundedInt::fallback()\n{\n    return m_def;\n}\n\nQString BoundedInt::expected()\n{\n    return QStringLiteral(\"number between %1 and %2\").arg(m_min).arg(m_max);\n}\n\n// LOWER BOUNDED INT\n\nLowerBoundedInt::LowerBoundedInt(int min, int def)\n  : m_min(min)\n  , m_def(def)\n{}\n\nbool LowerBoundedInt::check(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    bool conversionOk;\n    int num = str.toInt(&amp;conversionOk);\n    return conversionOk &amp;&amp; num &gt;= m_min;\n}\n\nQVariant LowerBoundedInt::fallback()\n{\n    return m_def;\n}\n\nQString LowerBoundedInt::expected()\n{\n    return QStringLiteral(\"number &gt;= %1\").arg(m_min);\n}\n\n// KEY SEQUENCE\n\nKeySequence::KeySequence(const QKeySequence&amp; fallback)\n  : m_fallback(fallback)\n{}\n\nbool KeySequence::check(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    if (!str.isEmpty() &amp;&amp; QKeySequence(str).toString().isEmpty()) {\n        return false;\n    }\n    return true;\n}\n\nQVariant KeySequence::fallback()\n{\n    return process(m_fallback);\n}\n\nQString KeySequence::expected()\n{\n    return QStringLiteral(\"keyboard shortcut\");\n}\n\nQVariant KeySequence::representation(const QVariant&amp; val)\n{\n    QString str(val.toString());\n    if (QKeySequence(str) == QKeySequence(Qt::Key_Return)) {\n        return QStringLiteral(\"Enter\");\n    }\n    return str;\n}\n\nQVariant KeySequence::process(const QVariant&amp; val)\n{\n    QString str(val.toString());\n    if (str == \"Enter\") {\n        return QKeySequence(Qt::Key_Return).toString();\n    }\n    if (str.length() &gt; 0) {\n        // Make the \"main\" key in sequence (last one) lower-case.\n        const QCharRef&amp; lastChar = str[str.length() - 1];\n        str.replace(str.length() - 1, 1, lastChar.toLower());\n    }\n    return str;\n}\n\n// EXISTING DIR\n\nbool ExistingDir::check(const QVariant&amp; val)\n{\n    if (!val.canConvert(QVariant::String) || val.toString().isEmpty()) {\n        return false;\n    }\n    QFileInfo info(val.toString());\n    return info.isDir() &amp;&amp; info.exists();\n}\n\nQVariant ExistingDir::fallback()\n{\n    using SP = QStandardPaths;\n    for (auto location :\n         { SP::PicturesLocation, SP::HomeLocation, SP::TempLocation }) {\n        QString path = SP::writableLocation(location);\n        if (QFileInfo(path).isDir()) {\n            return path;\n        }\n    }\n    return {};\n}\n\nQString ExistingDir::expected()\n{\n    return QStringLiteral(\"existing directory\");\n}\n\n// FILENAME PATTERN\n\nbool FilenamePattern::check(const QVariant&amp;)\n{\n    return true;\n}\n\nQVariant FilenamePattern::fallback()\n{\n    return ConfigHandler().filenamePatternDefault();\n}\n\nQVariant FilenamePattern::process(const QVariant&amp; val)\n{\n    QString str = val.toString();\n    return !str.isEmpty() ? val : fallback();\n}\n\nQString FilenamePattern::expected()\n{\n    return QStringLiteral(\"please edit using the GUI\");\n}\n\n// BUTTON LIST\n\nusing BType = CaptureTool::Type;\nusing BList = QList&lt;CaptureTool::Type&gt;;\n\nbool ButtonList::check(const QVariant&amp; val)\n{\n    // TODO stop using CTB\n    using CTB = CaptureToolButton;\n    auto allButtons = CTB::getIterableButtonTypes();\n    for (int btn : val.value&lt;QList&lt;int&gt;&gt;()) {\n        if (!allButtons.contains(static_cast&lt;BType&gt;(btn))) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Helper\nvoid sortButtons(BList&amp; buttons)\n{\n    std::sort(buttons.begin(), buttons.end(), [](BType a, BType b) {\n        return CaptureToolButton::getPriorityByButton(a) &lt;\n               CaptureToolButton::getPriorityByButton(b);\n    });\n}\n\nQVariant ButtonList::process(const QVariant&amp; val)\n{\n    auto intButtons = val.value&lt;QList&lt;int&gt;&gt;();\n    auto buttons = ButtonList::fromIntList(intButtons);\n    sortButtons(buttons);\n    return QVariant::fromValue(buttons);\n}\n\nQVariant ButtonList::fallback()\n{\n    auto buttons = CaptureToolButton::getIterableButtonTypes();\n    buttons.removeOne(CaptureTool::TYPE_SIZEDECREASE);\n    buttons.removeOne(CaptureTool::TYPE_SIZEINCREASE);\n    sortButtons(buttons);\n    return QVariant::fromValue(buttons);\n}\n\nQVariant ButtonList::representation(const QVariant&amp; val)\n{\n    auto intList = toIntList(val.value&lt;BList&gt;());\n    normalizeButtons(intList);\n    return QVariant::fromValue(intList);\n}\n\nQString ButtonList::expected()\n{\n    return QStringLiteral(\"please don't edit by hand\");\n}\n\nQList&lt;CaptureTool::Type&gt; ButtonList::fromIntList(const QList&lt;int&gt;&amp; l)\n{\n    QList&lt;CaptureTool::Type&gt; buttons;\n    buttons.reserve(l.size());\n    for (auto const i : l) {\n        buttons &lt;&lt; static_cast&lt;CaptureTool::Type&gt;(i);\n    }\n    return buttons;\n}\n\nQList&lt;int&gt; ButtonList::toIntList(const QList&lt;CaptureTool::Type&gt;&amp; l)\n{\n    QList&lt;int&gt; buttons;\n    buttons.reserve(l.size());\n    for (auto const i : l) {\n        buttons &lt;&lt; static_cast&lt;int&gt;(i);\n    }\n    return buttons;\n}\n\nbool ButtonList::normalizeButtons(QList&lt;int&gt;&amp; buttons)\n{\n    QList&lt;int&gt; listTypesInt =\n      toIntList(CaptureToolButton::getIterableButtonTypes());\n\n    bool hasChanged = false;\n    for (int i = 0; i &lt; buttons.size(); i++) {\n        if (!listTypesInt.contains(buttons.at(i))) {\n            buttons.removeAt(i);\n            hasChanged = true;\n        }\n    }\n    return hasChanged;\n}\n\n// USER COLORS\n\nUserColors::UserColors(int min, int max)\n  : m_min(min)\n  , m_max(max)\n{}\n\nbool UserColors::check(const QVariant&amp; val)\n{\n    if (!val.isValid()) {\n        return false;\n    }\n    if (!val.canConvert(QVariant::StringList)) {\n        return false;\n    }\n    for (const QString&amp; str : val.toStringList()) {\n        if (!QColor::isValidColor(str) &amp;&amp; str != \"picker\") {\n            return false;\n        }\n    }\n\n    int sz = val.toStringList().size();\n\n    return sz &gt;= m_min &amp;&amp; sz &lt;= m_max;\n}\n\nQVariant UserColors::process(const QVariant&amp; val)\n{\n    QStringList strColors = val.toStringList();\n    if (strColors.isEmpty()) {\n        return fallback();\n    }\n\n    QVector&lt;QColor&gt; colors;\n    colors.reserve(strColors.size());\n\n    for (const QString&amp; str : strColors) {\n        if (str != \"picker\") {\n            colors.append(QColor(str));\n        } else {\n            colors.append(QColor());\n        }\n    }\n\n    return QVariant::fromValue(colors);\n}\n\nQVariant UserColors::fallback()\n{\n    if (ConfigHandler().predefinedColorPaletteLarge()) {\n        return QVariant::fromValue(\n          ColorPickerWidget::getDefaultLargeColorPalette());\n    } else {\n        return QVariant::fromValue(\n          ColorPickerWidget::getDefaultSmallColorPalette());\n    }\n}\n\nQString UserColors::expected()\n{\n    return QStringLiteral(\n             \"list of colors(min %1 and max %2) separated by comma\")\n      .arg(m_min - 1)\n      .arg(m_max - 1);\n}\n\nQVariant UserColors::representation(const QVariant&amp; val)\n{\n    auto colors = val.value&lt;QVector&lt;QColor&gt;&gt;();\n\n    QStringList strColors;\n\n    for (const auto&amp; col : colors) {\n        if (col.isValid()) {\n            strColors.append(col.name(QColor::HexRgb));\n        } else {\n            strColors.append(QStringLiteral(\"picker\"));\n        }\n    }\n\n    return QVariant::fromValue(strColors);\n}\n\n// SET SAVE FILE AS EXTENSION\n\nbool SaveFileExtension::check(const QVariant&amp; val)\n{\n    if (!val.canConvert(QVariant::String) || val.toString().isEmpty()) {\n        return false;\n    }\n\n    QString extension = val.toString();\n\n    if (extension.startsWith(\".\")) {\n        extension.remove(0, 1);\n    }\n\n    QStringList imageFormatList;\n    foreach (auto imageFormat, QImageWriter::supportedImageFormats())\n        imageFormatList.append(imageFormat);\n\n    if (!imageFormatList.contains(extension)) {\n        return false;\n    }\n\n    return true;\n}\n\nQVariant SaveFileExtension::process(const QVariant&amp; val)\n{\n    QString extension = val.toString();\n\n    if (extension.startsWith(\".\")) {\n        extension.remove(0, 1);\n    }\n\n    return QVariant::fromValue(extension);\n}\n\nQString SaveFileExtension::expected()\n{\n    return QStringLiteral(\"supported image extension\");\n}\n\n// REGION\n\nbool Region::check(const QVariant&amp; val)\n{\n    QVariant region = process(val);\n    return region.isValid();\n}\n\n#include &lt;QApplication&gt; // TODO remove after FIXME (see below)\n#include &lt;utility&gt;\n\nQVariant Region::process(const QVariant&amp; val)\n{\n    // FIXME: This is temporary, just before D-Bus is removed\n    char** argv = new char*[1];\n    int* argc = new int{ 0 };\n    if (QGuiApplication::screens().empty()) {\n        new QApplication(*argc, argv);\n    }\n\n    QString str = val.toString();\n\n    if (str == \"all\") {\n        return ScreenGrabber().desktopGeometry();\n    } else if (str.startsWith(\"screen\")) {\n        bool ok;\n        int number = str.midRef(6).toInt(&amp;ok);\n        if (!ok || number &lt; 0) {\n            return {};\n        }\n        return ScreenGrabber().screenGeometry(qApp-&gt;screens()[number]);\n    }\n\n    QRegExp regex(\"(-{,1}\\\\d+)\"   // number (any sign)\n                  \"[x,\\\\.\\\\s]\"    // separator ('x', ',', '.', or whitespace)\n                  \"(-{,1}\\\\d+)\"   // number (any sign)\n                  \"[\\\\+,\\\\.\\\\s]*\" // separator ('+',',', '.', or whitespace)\n                  \"(-{,1}\\\\d+)\"   // number (non-negative)\n                  \"[\\\\+,\\\\.\\\\s]*\" // separator ('+', ',', '.', or whitespace)\n                  \"(-{,1}\\\\d+)\"   // number (non-negative)\n    );\n\n    if (!regex.exactMatch(str)) {\n        return {};\n    }\n\n    int w, h, x, y;\n    bool w_ok, h_ok, x_ok, y_ok;\n    w = regex.cap(1).toInt(&amp;w_ok);\n    h = regex.cap(2).toInt(&amp;h_ok);\n    x = regex.cap(3).toInt(&amp;x_ok);\n    y = regex.cap(4).toInt(&amp;y_ok);\n\n    if (!(w_ok &amp;&amp; h_ok &amp;&amp; x_ok &amp;&amp; y_ok)) {\n        return {};\n    }\n\n    return QRect(x, y, w, h).normalized();\n}\n\n</code></pre>"},{"location":"flameshot/valuehandler_8h/","title":"File valuehandler.h","text":"<p>FileList &gt; src &gt; utils &gt; valuehandler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/widgets/capture/capturetoolbutton.h\"</code></li> <li><code>#include \"src/widgets/colorpickerwidget.h\"</code></li> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QList&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> </ul>"},{"location":"flameshot/valuehandler_8h/#classes","title":"Classes","text":"Type Name class Bool class BoundedInt class ButtonList class Color class ExistingDir class FilenamePattern class KeySequence class LowerBoundedInt class Region class SaveFileExtension class String class UserColors class ValueHandler Handles the value of a configuration option (abstract class)."},{"location":"flameshot/valuehandler_8h_source/","title":"File valuehandler.h","text":"<p>File List &gt; src &gt; utils &gt; valuehandler.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#pragma once\n\n#include \"src/widgets/capture/capturetoolbutton.h\"\n#include \"src/widgets/colorpickerwidget.h\"\n\n#include &lt;QColor&gt;\n#include &lt;QList&gt;\n#include &lt;QString&gt;\n\nclass QVariant;\n\nclass ValueHandler\n{\npublic:\n    virtual bool check(const QVariant&amp; val) = 0;\n    QVariant value(const QVariant&amp; val);\n    virtual QVariant fallback();\n    virtual QVariant representation(const QVariant&amp; val);\n    virtual QString expected();\n\nprotected:\n    virtual QVariant process(const QVariant&amp; val);\n};\n\nclass Bool : public ValueHandler\n{\npublic:\n    Bool(bool def);\n    bool check(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QString expected() override;\n\nprivate:\n    bool m_def;\n};\n\nclass String : public ValueHandler\n{\npublic:\n    String(QString def);\n    bool check(const QVariant&amp;) override;\n    QVariant fallback() override;\n    QString expected() override;\n\nprivate:\n    QString m_def;\n};\n\nclass Color : public ValueHandler\n{\npublic:\n    Color(QColor def);\n    bool check(const QVariant&amp; val) override;\n    QVariant process(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QVariant representation(const QVariant&amp; val) override;\n    QString expected() override;\n\nprivate:\n    QColor m_def;\n};\n\nclass BoundedInt : public ValueHandler\n{\npublic:\n    BoundedInt(int min, int max, int def);\n\n    bool check(const QVariant&amp; val) override;\n    virtual QVariant fallback() override;\n    QString expected() override;\n\nprivate:\n    int m_min, m_max, m_def;\n};\n\nclass LowerBoundedInt : public ValueHandler\n{\npublic:\n    LowerBoundedInt(int min, int def);\n    bool check(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QString expected() override;\n\nprivate:\n    int m_min, m_def;\n};\n\nclass KeySequence : public ValueHandler\n{\npublic:\n    KeySequence(const QKeySequence&amp; fallback = {});\n    bool check(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QString expected() override;\n    QVariant representation(const QVariant&amp; val) override;\n\nprivate:\n    QKeySequence m_fallback;\n\n    QVariant process(const QVariant&amp; val) override;\n};\n\nclass ExistingDir : public ValueHandler\n{\n    bool check(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QString expected() override;\n};\n\nclass FilenamePattern : public ValueHandler\n{\n    bool check(const QVariant&amp;) override;\n    QVariant fallback() override;\n    QVariant process(const QVariant&amp;) override;\n    QString expected() override;\n};\n\nclass ButtonList : public ValueHandler\n{\npublic:\n    bool check(const QVariant&amp; val) override;\n    QVariant process(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QVariant representation(const QVariant&amp; val) override;\n    QString expected() override;\n\n    // UTILITY FUNCTIONS\n    static QList&lt;CaptureTool::Type&gt; fromIntList(const QList&lt;int&gt;&amp;);\n    static QList&lt;int&gt; toIntList(const QList&lt;CaptureTool::Type&gt;&amp; l);\n    static bool normalizeButtons(QList&lt;int&gt;&amp; buttons);\n};\n\nclass UserColors : public ValueHandler\n{\npublic:\n    UserColors(int min, int max);\n    bool check(const QVariant&amp; val) override;\n    QVariant process(const QVariant&amp; val) override;\n    QVariant fallback() override;\n    QString expected() override;\n    QVariant representation(const QVariant&amp; val) override;\n\nprivate:\n    int m_min, m_max;\n};\n\nclass SaveFileExtension : public ValueHandler\n{\n    bool check(const QVariant&amp; val) override;\n    QVariant process(const QVariant&amp; val) override;\n    QString expected() override;\n};\n\nclass Region : public ValueHandler\n{\npublic:\n    bool check(const QVariant&amp; val) override;\n\nprivate:\n    QVariant process(const QVariant&amp; val) override;\n};\n\n</code></pre>"},{"location":"flameshot/waylandutils_8cpp/","title":"File waylandutils.cpp","text":"<p>FileList &gt; src &gt; utils &gt; waylandutils.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"waylandutils.h\"</code></li> </ul>"},{"location":"flameshot/waylandutils_8cpp_source/","title":"File waylandutils.cpp","text":"<p>File List &gt; src &gt; utils &gt; waylandutils.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"waylandutils.h\"\n\nWaylandUtils::WaylandUtils() {}\n\nbool WaylandUtils::waylandDetected() {}\n\n</code></pre>"},{"location":"flameshot/waylandutils_8h/","title":"File waylandutils.h","text":"<p>FileList &gt; src &gt; utils &gt; waylandutils.h</p> <p>Go to the source code of this file.</p>"},{"location":"flameshot/waylandutils_8h/#classes","title":"Classes","text":"Type Name class WaylandUtils"},{"location":"flameshot/waylandutils_8h_source/","title":"File waylandutils.h","text":"<p>File List &gt; src &gt; utils &gt; waylandutils.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#ifndef WAYLANDUTILS_H\n#define WAYLANDUTILS_H\n\nclass WaylandUtils\n{\npublic:\n    WaylandUtils();\n\n    static bool waylandDetected();\n\nprivate:\n};\n\n#endif // WAYLANDUTILS_H\n\n</code></pre>"},{"location":"flameshot/winlnkfileparse_8cpp/","title":"File winlnkfileparse.cpp","text":"<p>FileList &gt; src &gt; utils &gt; winlnkfileparse.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"winlnkfileparse.h\"</code></li> <li><code>#include &lt;QDir&gt;</code></li> <li><code>#include &lt;QDirIterator&gt;</code></li> <li><code>#include &lt;QFileSystemModel&gt;</code></li> <li><code>#include &lt;QImageWriter&gt;</code></li> <li><code>#include &lt;QRegularExpression&gt;</code></li> <li><code>#include &lt;QSettings&gt;</code></li> <li><code>#include &lt;QString&gt;</code></li> <li><code>#include &lt;shlobj.h&gt;</code></li> </ul>"},{"location":"flameshot/winlnkfileparse_8cpp_source/","title":"File winlnkfileparse.cpp","text":"<p>File List &gt; src &gt; utils &gt; winlnkfileparse.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"winlnkfileparse.h\"\n#include &lt;QDir&gt;\n#include &lt;QDirIterator&gt;\n#include &lt;QFileSystemModel&gt;\n#include &lt;QImageWriter&gt;\n#include &lt;QRegularExpression&gt;\n#include &lt;QSettings&gt;\n#include &lt;QString&gt;\n\n#include &lt;shlobj.h&gt;\n\nWinLnkFileParser::WinLnkFileParser()\n{\n    QStringList sListImgFileExt;\n    for (const auto&amp; ext : QImageWriter::supportedImageFormats()) {\n        sListImgFileExt.append(ext);\n    }\n    this-&gt;getImageFileExtAssociates(sListImgFileExt);\n}\n\nDesktopAppData WinLnkFileParser::parseLnkFile(const QFileInfo&amp; fiLnk,\n                                              bool&amp; ok) const\n{\n    DesktopAppData res;\n    ok = true;\n\n    QFileInfo fiSymlink(fiLnk.symLinkTarget());\n    if (!fiSymlink.exists() || !fiSymlink.fileName().endsWith(\".exe\") ||\n        fiSymlink.baseName().contains(\"unins\")) {\n        ok = false;\n        return res;\n    }\n\n    res.name = fiLnk.baseName();\n    res.exec = fiSymlink.absoluteFilePath();\n\n    // Get icon from exe\n    QFileSystemModel* model = new QFileSystemModel;\n    model-&gt;setRootPath(fiSymlink.path());\n    res.icon = model-&gt;fileIcon(model-&gt;index(fiSymlink.filePath()));\n\n    if (m_GraphicAppsList.contains(fiSymlink.fileName())) {\n        res.categories = QStringList() &lt;&lt; \"Graphics\";\n    } else {\n        res.categories = QStringList() &lt;&lt; \"Utility\";\n    }\n\n    for (const auto&amp; app : m_appList) {\n        if (app.exec == res.exec) {\n            ok = false;\n            break;\n        }\n    }\n\n    if (res.exec.isEmpty() || res.name.isEmpty()) {\n        ok = false;\n    }\n    return res;\n}\n\nint WinLnkFileParser::processDirectory(const QDir&amp; dir)\n{\n    QStringList sListMenuFilter;\n    sListMenuFilter &lt;&lt; \"Accessibility\"\n                    &lt;&lt; \"Administrative Tools\"\n                    &lt;&lt; \"Setup\"\n                    &lt;&lt; \"System Tools\"\n                    &lt;&lt; \"Uninstall\"\n                    &lt;&lt; \"Update\"\n                    &lt;&lt; \"Updater\"\n                    &lt;&lt; \"Windows PowerShell\";\n    const QString sMenuFilter(\"\\\\b(\" + sListMenuFilter.join('|') + \")\\\\b\");\n    QRegularExpression regexfilter(sMenuFilter);\n\n    bool ok;\n    int length = m_appList.length();\n    // Go through all subfolders and *.lnk files\n    QDirIterator it(dir.absolutePath(),\n                    { \"*.lnk\" },\n                    QDir::NoFilter,\n                    QDirIterator::Subdirectories);\n    while (it.hasNext()) {\n        QFileInfo fiLnk(it.next());\n        if (!regexfilter.match(fiLnk.absoluteFilePath()).hasMatch()) {\n            DesktopAppData app = parseLnkFile(fiLnk, ok);\n            if (ok) {\n                m_appList.append(app);\n            }\n        }\n    }\n\n    return m_appList.length() - length;\n}\n\nQVector&lt;DesktopAppData&gt; WinLnkFileParser::getAppsByCategory(\n  const QString&amp; category)\n{\n    QVector&lt;DesktopAppData&gt; res;\n    for (const DesktopAppData&amp; app : qAsConst(m_appList)) {\n        if (app.categories.contains(category)) {\n            res.append(app);\n        }\n    }\n\n    std::sort(res.begin(), res.end(), CompareAppByName());\n\n    return res;\n}\n\nQMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; WinLnkFileParser::getAppsByCategory(\n  const QStringList&amp; categories)\n{\n    QMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; res;\n\n    QVector&lt;DesktopAppData&gt; tmpAppList;\n    for (const QString&amp; category : categories) {\n        tmpAppList = getAppsByCategory(category);\n        for (const DesktopAppData&amp; app : qAsConst(tmpAppList)) {\n            res[category].append(app);\n        }\n    }\n\n    return res;\n}\n\nQString WinLnkFileParser::getAllUsersStartMenuPath()\n{\n    QString sRet(\"\");\n    WCHAR path[MAX_PATH];\n    HRESULT hr = SHGetFolderPathW(NULL, CSIDL_COMMON_PROGRAMS, NULL, 0, path);\n\n    if (SUCCEEDED(hr)) {\n        sRet = QDir(QString::fromWCharArray(path)).absolutePath();\n    }\n\n    return sRet;\n}\n\nvoid WinLnkFileParser::getImageFileExtAssociates(const QStringList&amp; sListImgExt)\n{\n    const QString sReg(\"HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\\"\n                       \"CurrentVersion\\\\Explorer\\\\FileExts\\\\.%1\\\\OpenWithList\");\n\n    for (const auto&amp; sExt : qAsConst(sListImgExt)) {\n        QString sPath(sReg.arg(sExt));\n        QSettings registry(sPath, QSettings::NativeFormat);\n        for (const auto&amp; key : registry.allKeys()) {\n            if (1 == key.size()) { // Keys for OpenWith apps are a, b, c, ...\n                QString sVal = registry.value(key, \"\").toString();\n                if (sVal.endsWith(\".exe\") &amp;&amp;\n                    !m_GraphicAppsList.contains(sVal)) {\n                    m_GraphicAppsList &lt;&lt; sVal;\n                }\n            }\n        }\n    }\n}\n\n</code></pre>"},{"location":"flameshot/winlnkfileparse_8h/","title":"File winlnkfileparse.h","text":"<p>FileList &gt; src &gt; utils &gt; winlnkfileparse.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"desktopfileparse.h\"</code></li> <li><code>#include &lt;QFileInfo&gt;</code></li> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QStringList&gt;</code></li> </ul>"},{"location":"flameshot/winlnkfileparse_8h/#classes","title":"Classes","text":"Type Name struct CompareAppByName struct WinLnkFileParser"},{"location":"flameshot/winlnkfileparse_8h_source/","title":"File winlnkfileparse.h","text":"<p>File List &gt; src &gt; utils &gt; winlnkfileparse.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"desktopfileparse.h\"\n#include &lt;QFileInfo&gt;\n#include &lt;QIcon&gt;\n#include &lt;QMap&gt;\n#include &lt;QStringList&gt;\n\nclass QDir;\nclass QString;\n\nstruct CompareAppByName\n{\n    bool operator()(const DesktopAppData a, const DesktopAppData b)\n    {\n        return (a.name &lt; b.name);\n    }\n};\n\nstruct WinLnkFileParser\n{\n    WinLnkFileParser();\n    DesktopAppData parseLnkFile(const QFileInfo&amp; fiLnk, bool&amp; ok) const;\n    int processDirectory(const QDir&amp; dir);\n    QString getAllUsersStartMenuPath();\n\n    QVector&lt;DesktopAppData&gt; getAppsByCategory(const QString&amp; category);\n    QMap&lt;QString, QVector&lt;DesktopAppData&gt;&gt; getAppsByCategory(\n      const QStringList&amp; categories);\n\nprivate:\n    void getImageFileExtAssociates(const QStringList&amp; sListImgExt);\n\n    QVector&lt;DesktopAppData&gt; m_appList;\n    QStringList m_GraphicAppsList;\n};\n\n</code></pre>"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/","title":"Dir widgets","text":"<p>FileList &gt; src &gt; widgets</p>"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/#files","title":"Files","text":"Type Name file capturelauncher.cpp file capturelauncher.h file colorpickerwidget.cpp file colorpickerwidget.h file draggablewidgetmaker.cpp file draggablewidgetmaker.h file imagelabel.cpp file imagelabel.h file imguploaddialog.cpp file imguploaddialog.h file infowindow.cpp file infowindow.h file loadspinner.cpp file loadspinner.h file notificationwidget.cpp file notificationwidget.h file orientablepushbutton.cpp file orientablepushbutton.h file trayicon.cpp file trayicon.h file updatenotificationwidget.cpp file updatenotificationwidget.h file uploadhistory.cpp file uploadhistory.h file uploadlineitem.cpp file uploadlineitem.h"},{"location":"flameshot/dir_0abdee562046be6f5823d1ca8c3fd13c/#directories","title":"Directories","text":"Type Name dir capture dir panel"},{"location":"flameshot/dir_50d9a3ace9e44a4976ace91594337bf4/","title":"Dir capture","text":"<p>FileList &gt; capture</p>"},{"location":"flameshot/dir_50d9a3ace9e44a4976ace91594337bf4/#files","title":"Files","text":"Type Name file buttonhandler.cpp file buttonhandler.h file capturebutton.cpp file capturebutton.h file capturetoolbutton.cpp file capturetoolbutton.h file capturetoolobjects.cpp file capturetoolobjects.h file capturewidget.cpp file capturewidget.h file colorpicker.cpp file colorpicker.h file hovereventfilter.cpp file hovereventfilter.h file magnifierwidget.cpp file magnifierwidget.h file modificationcommand.cpp file modificationcommand.h file notifierbox.cpp file notifierbox.h file overlaymessage.cpp file overlaymessage.h file selectionwidget.cpp file selectionwidget.h"},{"location":"flameshot/buttonhandler_8cpp/","title":"File buttonhandler.cpp","text":"<p>FileList &gt; capture &gt; buttonhandler.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"buttonhandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/buttonhandler_8cpp_source/","title":"File buttonhandler.cpp","text":"<p>File List &gt; capture &gt; buttonhandler.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"buttonhandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QPoint&gt;\n#include &lt;QScreen&gt;\n\n// ButtonHandler is a habdler for every active button. It makes easier to\n// manipulate the buttons as a unit.\n\nButtonHandler::ButtonHandler(const QVector&lt;CaptureToolButton*&gt;&amp; v,\n                             QObject* parent)\n  : QObject(parent)\n{\n    setButtons(v);\n    init();\n}\n\nButtonHandler::ButtonHandler(QObject* parent)\n  : QObject(parent)\n{\n    init();\n}\n\nvoid ButtonHandler::hide()\n{\n    for (CaptureToolButton* b : m_vectorButtons) {\n        b-&gt;hide();\n    }\n}\n\nvoid ButtonHandler::show()\n{\n    if (m_vectorButtons.isEmpty() || m_vectorButtons.first()-&gt;isVisible()) {\n        return;\n    }\n    for (CaptureToolButton* b : m_vectorButtons) {\n        b-&gt;animatedShow();\n    }\n}\n\nbool ButtonHandler::isVisible() const\n{\n    bool ret = true;\n    for (const CaptureToolButton* b : m_vectorButtons) {\n        if (!b-&gt;isVisible()) {\n            ret = false;\n            break;\n        }\n    }\n    return ret;\n}\n\nbool ButtonHandler::buttonsAreInside() const\n{\n    return m_buttonsAreInside;\n}\n\nsize_t ButtonHandler::size() const\n{\n    return m_vectorButtons.size();\n}\n\n// updatePosition updates the position of the buttons around the\n// selection area. Ignores the sides blocked by the end of the screen.\n// When the selection is too small it works on a virtual selection with\n// the original in the center.\nvoid ButtonHandler::updatePosition(const QRect&amp; selection)\n{\n    resetRegionTrack();\n    const int vecLength = m_vectorButtons.size();\n    if (vecLength == 0) {\n        return;\n    }\n    // Copy of the selection area for internal modifications\n    m_selection = intersectWithAreas(selection);\n    updateBlockedSides();\n    ensureSelectionMinimunSize();\n    // Indicates the actual button to be moved\n    int elemIndicator = 0;\n\n    while (elemIndicator &lt; vecLength) {\n\n        // Add them inside the area when there is no more space\n        if (m_allSidesBlocked) {\n            m_selection = selection;\n            positionButtonsInside(elemIndicator);\n            break; // the while\n        }\n        // Number of buttons per row column\n        int buttonsPerRow =\n          (m_selection.width() + m_separator) / (m_buttonExtendedSize);\n        int buttonsPerCol =\n          (m_selection.height() + m_separator) / (m_buttonExtendedSize);\n        // Buttons to be placed in the corners\n        int extraButtons =\n          (vecLength - elemIndicator) - (buttonsPerRow + buttonsPerCol) * 2;\n        int elemsAtCorners = extraButtons &gt; 4 ? 4 : extraButtons;\n        int maxExtra = 2;\n        if (m_oneHorizontalBlocked) {\n            maxExtra = 1;\n        } else if (m_horizontalyBlocked) {\n            maxExtra = 0;\n        }\n        int elemCornersTop = qBound(0, elemsAtCorners, maxExtra);\n        elemsAtCorners -= elemCornersTop;\n        int elemCornersBotton = qBound(0, elemsAtCorners, maxExtra);\n\n        // Add buttons at the button of the selection\n        if (!m_blockedBotton) {\n            int addCounter = buttonsPerRow + elemCornersBotton;\n            // Don't add more than we have\n            addCounter = qBound(0, addCounter, vecLength - elemIndicator);\n            QPoint center = QPoint(m_selection.center().x(),\n                                   m_selection.bottom() + m_separator);\n            if (addCounter &gt; buttonsPerRow) {\n                adjustHorizontalCenter(center);\n            }\n            // ElemIndicator, elemsAtCorners\n            QVector&lt;QPoint&gt; positions =\n              horizontalPoints(center, addCounter, true);\n            moveButtonsToPoints(positions, elemIndicator);\n        }\n        // Add buttons at the right side of the selection\n        if (!m_blockedRight &amp;&amp; elemIndicator &lt; vecLength) {\n            int addCounter = buttonsPerCol;\n            addCounter = qBound(0, addCounter, vecLength - elemIndicator);\n\n            QPoint center = QPoint(m_selection.right() + m_separator,\n                                   m_selection.center().y());\n            QVector&lt;QPoint&gt; positions =\n              verticalPoints(center, addCounter, false);\n            moveButtonsToPoints(positions, elemIndicator);\n        }\n        // Add buttons at the top of the selection\n        if (!m_blockedTop &amp;&amp; elemIndicator &lt; vecLength) {\n            int addCounter = buttonsPerRow + elemCornersTop;\n            addCounter = qBound(0, addCounter, vecLength - elemIndicator);\n            QPoint center = QPoint(m_selection.center().x(),\n                                   m_selection.top() - m_buttonExtendedSize);\n            if (addCounter == 1 + buttonsPerRow) {\n                adjustHorizontalCenter(center);\n            }\n            QVector&lt;QPoint&gt; positions =\n              horizontalPoints(center, addCounter, false);\n            moveButtonsToPoints(positions, elemIndicator);\n        }\n        // Add buttons at the left side of the selection\n        if (!m_blockedLeft &amp;&amp; elemIndicator &lt; vecLength) {\n            int addCounter = buttonsPerCol;\n            addCounter = qBound(0, addCounter, vecLength - elemIndicator);\n\n            QPoint center = QPoint(m_selection.left() - m_buttonExtendedSize,\n                                   m_selection.center().y());\n            QVector&lt;QPoint&gt; positions =\n              verticalPoints(center, addCounter, true);\n            moveButtonsToPoints(positions, elemIndicator);\n        }\n        // If there are elements for the next cycle, increase the size of the\n        // base area\n        if (elemIndicator &lt; vecLength &amp;&amp; !(m_allSidesBlocked)) {\n            expandSelection();\n        }\n        updateBlockedSides();\n    }\n}\n\nint ButtonHandler::calculateShift(int elements, bool reverse) const\n{\n    int shift = 0;\n    if (elements % 2 == 0) {\n        shift = m_buttonExtendedSize * (elements / 2) - (m_separator / 2);\n    } else {\n        shift =\n          m_buttonExtendedSize * ((elements - 1) / 2) + m_buttonBaseSize / 2;\n    }\n    if (!reverse) {\n        shift -= m_buttonBaseSize;\n    }\n\n    return shift;\n}\n// horizontalPoints is an auxiliary method for the button position computation.\n// starts from a known center and keeps adding elements horizontally\n// and returns the computed positions.\nQVector&lt;QPoint&gt; ButtonHandler::horizontalPoints(const QPoint&amp; center,\n                                                const int elements,\n                                                const bool leftToRight) const\n{\n    QVector&lt;QPoint&gt; res;\n    // Distance from the center to start adding buttons\n    int shift = calculateShift(elements, leftToRight);\n\n    int x = leftToRight ? center.x() - shift : center.x() + shift;\n    QPoint i(x, center.y());\n    while (elements &gt; res.length()) {\n        res.append(i);\n        leftToRight ? i.setX(i.x() + m_buttonExtendedSize)\n                    : i.setX(i.x() - m_buttonExtendedSize);\n    }\n    return res;\n}\n\n// verticalPoints is an auxiliary method for the button position computation.\n// starts from a known center and keeps adding elements vertically\n// and returns the computed positions.\nQVector&lt;QPoint&gt; ButtonHandler::verticalPoints(const QPoint&amp; center,\n                                              const int elements,\n                                              const bool upToDown) const\n{\n    QVector&lt;QPoint&gt; res;\n    // Distance from the center to start adding buttons\n    int shift = calculateShift(elements, upToDown);\n\n    int y = upToDown ? center.y() - shift : center.y() + shift;\n    QPoint i(center.x(), y);\n    while (elements &gt; res.length()) {\n        res.append(i);\n        upToDown ? i.setY(i.y() + m_buttonExtendedSize)\n                 : i.setY(i.y() - m_buttonExtendedSize);\n    }\n    return res;\n}\n\nQRect ButtonHandler::intersectWithAreas(const QRect&amp; rect)\n{\n    QRect res;\n    for (const QRect&amp; r : m_screenRegions) {\n        QRect temp = rect.intersected(r);\n        if (temp.height() * temp.width() &gt; res.height() * res.width()) {\n            res = temp;\n        }\n    }\n    return res;\n}\n\nvoid ButtonHandler::init()\n{\n    m_separator = GlobalValues::buttonBaseSize() / 4;\n}\n\nvoid ButtonHandler::resetRegionTrack()\n{\n    m_buttonsAreInside = false;\n}\n\nvoid ButtonHandler::updateBlockedSides()\n{\n    QRegion screenRegion{};\n    for (const QRect&amp; rect : m_screenRegions) {\n        screenRegion += rect;\n    }\n\n    const int EXTENSION = m_separator * 2 + m_buttonBaseSize;\n    // Right\n    QPoint pointA(m_selection.right() + EXTENSION, m_selection.bottom());\n    QPoint pointB(pointA.x(), m_selection.top());\n    m_blockedRight =\n      !(screenRegion.contains(pointA) &amp;&amp; screenRegion.contains(pointB));\n    // Left\n    pointA.setX(m_selection.left() - EXTENSION);\n    pointB.setX(pointA.x());\n    m_blockedLeft =\n      !(screenRegion.contains(pointA) &amp;&amp; screenRegion.contains(pointB));\n    // Bottom\n    pointA = QPoint(m_selection.left(), m_selection.bottom() + EXTENSION);\n    pointB = QPoint(m_selection.right(), pointA.y());\n    m_blockedBotton =\n      !(screenRegion.contains(pointA) &amp;&amp; screenRegion.contains(pointB));\n    // Top\n    pointA.setY(m_selection.top() - EXTENSION);\n    pointB.setY(pointA.y());\n    m_blockedTop =\n      !(screenRegion.contains(pointA) &amp;&amp; screenRegion.contains(pointB));\n    // Auxiliary\n    m_oneHorizontalBlocked =\n      (!m_blockedRight &amp;&amp; m_blockedLeft) || (m_blockedRight &amp;&amp; !m_blockedLeft);\n    m_horizontalyBlocked = (m_blockedRight &amp;&amp; m_blockedLeft);\n    m_allSidesBlocked =\n      (m_blockedBotton &amp;&amp; m_horizontalyBlocked &amp;&amp; m_blockedTop);\n}\n\nvoid ButtonHandler::expandSelection()\n{\n    int&amp; s = m_buttonExtendedSize;\n    m_selection = m_selection + QMargins(s, s, s, s);\n    m_selection = intersectWithAreas(m_selection);\n}\n\nvoid ButtonHandler::positionButtonsInside(int index)\n{\n    // Position the buttons in the botton-center of the main but inside of the\n    // selection.\n    QRect mainArea = m_selection;\n    mainArea = intersectWithAreas(mainArea);\n    const int buttonsPerRow = (mainArea.width()) / (m_buttonExtendedSize);\n    if (buttonsPerRow == 0) {\n        return;\n    }\n    QPoint center =\n      QPoint(mainArea.center().x(), mainArea.bottom() - m_buttonExtendedSize);\n\n    while (m_vectorButtons.size() &gt; index) {\n        int addCounter = buttonsPerRow;\n        addCounter = qBound(0, addCounter, m_vectorButtons.size() - index);\n        QVector&lt;QPoint&gt; positions = horizontalPoints(center, addCounter, true);\n        moveButtonsToPoints(positions, index);\n        center.setY(center.y() - m_buttonExtendedSize);\n    }\n\n    m_buttonsAreInside = true;\n}\n\nvoid ButtonHandler::ensureSelectionMinimunSize()\n{\n    // Detect if a side is smaller than a button in order to prevent collision\n    // and redimension the base area the the base size of a single button per\n    // side\n    if (m_selection.width() &lt; m_buttonBaseSize) {\n        if (!m_blockedLeft) {\n            m_selection.setX(m_selection.x() -\n                             (m_buttonBaseSize - m_selection.width()) / 2);\n        }\n        m_selection.setWidth(m_buttonBaseSize);\n    }\n    if (m_selection.height() &lt; m_buttonBaseSize) {\n        if (!m_blockedTop) {\n            m_selection.setY(m_selection.y() -\n                             (m_buttonBaseSize - m_selection.height()) / 2);\n        }\n        m_selection.setHeight(m_buttonBaseSize);\n    }\n}\n\nvoid ButtonHandler::moveButtonsToPoints(const QVector&lt;QPoint&gt;&amp; points,\n                                        int&amp; index)\n{\n    for (const QPoint&amp; p : points) {\n        auto* button = m_vectorButtons[index];\n        button-&gt;move(p);\n        ++index;\n    }\n}\n\nvoid ButtonHandler::adjustHorizontalCenter(QPoint&amp; center)\n{\n    if (m_blockedLeft) {\n        center.setX(center.x() + m_buttonExtendedSize / 2);\n    } else if (m_blockedRight) {\n        center.setX(center.x() - m_buttonExtendedSize / 2);\n    }\n}\n\n// setButtons redefines the buttons of the button handler\nvoid ButtonHandler::setButtons(const QVector&lt;CaptureToolButton*&gt;&amp; v)\n{\n    if (v.isEmpty()) {\n        return;\n    }\n\n    for (CaptureToolButton* b : m_vectorButtons) {\n        delete (b);\n    }\n    m_vectorButtons = v;\n    m_buttonBaseSize = GlobalValues::buttonBaseSize();\n    m_buttonExtendedSize = m_buttonBaseSize + m_separator;\n}\n\nbool ButtonHandler::contains(const QPoint&amp; p) const\n{\n    if (m_vectorButtons.isEmpty()) {\n        return false;\n    }\n    QPoint first(m_vectorButtons.first()-&gt;pos());\n    QPoint last(m_vectorButtons.last()-&gt;pos());\n    bool firstIsTopLeft = (first.x() &lt;= last.x() &amp;&amp; first.y() &lt;= last.y());\n    QPoint topLeft = firstIsTopLeft ? first : last;\n    QPoint bottonRight = firstIsTopLeft ? last : first;\n    topLeft += QPoint(-m_separator, -m_separator);\n    bottonRight += QPoint(m_buttonExtendedSize, m_buttonExtendedSize);\n    QRegion r(QRect(topLeft, bottonRight).normalized());\n    return r.contains(p);\n}\n\nvoid ButtonHandler::updateScreenRegions(const QVector&lt;QRect&gt;&amp; rects)\n{\n    m_screenRegions = rects;\n}\n\nvoid ButtonHandler::updateScreenRegions(const QRect&amp; rect)\n{\n    m_screenRegions = { rect };\n}\n\n</code></pre>"},{"location":"flameshot/buttonhandler_8h/","title":"File buttonhandler.h","text":"<p>FileList &gt; capture &gt; buttonhandler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetoolbutton.h\"</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QRegion&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> </ul>"},{"location":"flameshot/buttonhandler_8h/#classes","title":"Classes","text":"Type Name class ButtonHandler"},{"location":"flameshot/buttonhandler_8h_source/","title":"File buttonhandler.h","text":"<p>File List &gt; capture &gt; buttonhandler.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"capturetoolbutton.h\"\n#include &lt;QObject&gt;\n#include &lt;QRegion&gt;\n#include &lt;QVector&gt;\n\nclass CaptureToolButton;\nclass QRect;\nclass QPoint;\n\nclass ButtonHandler : public QObject\n{\n    Q_OBJECT\npublic:\n    ButtonHandler(const QVector&lt;CaptureToolButton*&gt;&amp;,\n                  QObject* parent = nullptr);\n    explicit ButtonHandler(QObject* parent = nullptr);\n\n    void hideSectionUnderMouse(const QPoint&amp; p);\n\n    bool isVisible() const;\n    bool buttonsAreInside() const;\n    size_t size() const;\n\n    void setButtons(const QVector&lt;CaptureToolButton*&gt;&amp;);\n    bool contains(const QPoint&amp; p) const;\n    void updateScreenRegions(const QVector&lt;QRect&gt;&amp; rects);\n    void updateScreenRegions(const QRect&amp; rect);\n\npublic slots:\n    void updatePosition(const QRect&amp; selection);\n    void hide();\n    void show();\n\nprivate:\n    QVector&lt;QPoint&gt; horizontalPoints(const QPoint&amp; center,\n                                     const int elements,\n                                     const bool leftToRight) const;\n    QVector&lt;QPoint&gt; verticalPoints(const QPoint&amp; center,\n                                   const int elements,\n                                   const bool upToDown) const;\n\n    int calculateShift(int elements, bool reverse) const;\n\n    QRect intersectWithAreas(const QRect&amp; rect);\n\n    QVector&lt;CaptureToolButton*&gt; m_vectorButtons;\n\n    QVector&lt;QRect&gt; m_screenRegions;\n\n    QRect m_selection;\n\n    int m_separator;\n    int m_buttonExtendedSize;\n    int m_buttonBaseSize;\n\n    bool m_buttonsAreInside;\n    bool m_blockedRight;\n    bool m_blockedLeft;\n    bool m_blockedBotton;\n    bool m_blockedTop;\n    bool m_oneHorizontalBlocked;\n    bool m_horizontalyBlocked;\n    bool m_allSidesBlocked;\n\n    // aux methods\n    void init();\n    void resetRegionTrack();\n    void updateBlockedSides();\n    void expandSelection();\n    void positionButtonsInside(int index);\n    void ensureSelectionMinimunSize();\n    void moveButtonsToPoints(const QVector&lt;QPoint&gt;&amp; points, int&amp; index);\n    void adjustHorizontalCenter(QPoint&amp; center);\n};\n\n</code></pre>"},{"location":"flameshot/capturebutton_8cpp/","title":"File capturebutton.cpp","text":"<p>FileList &gt; capture &gt; capturebutton.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturebutton.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QGraphicsDropShadowEffect&gt;</code></li> </ul>"},{"location":"flameshot/capturebutton_8cpp_source/","title":"File capturebutton.cpp","text":"<p>File List &gt; capture &gt; capturebutton.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"capturebutton.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QGraphicsDropShadowEffect&gt;\n\nCaptureButton::CaptureButton(QWidget* parent)\n  : QPushButton(parent)\n{\n    init();\n}\n\nCaptureButton::CaptureButton(const QString&amp; text, QWidget* parent)\n  : QPushButton(text, parent)\n{\n    init();\n}\n\nCaptureButton::CaptureButton(const QIcon&amp; icon,\n                             const QString&amp; text,\n                             QWidget* parent)\n  : QPushButton(icon, text, parent)\n{\n    init();\n}\n\nvoid CaptureButton::init()\n{\n    setCursor(Qt::ArrowCursor);\n    setFocusPolicy(Qt::NoFocus);\n\n    auto* dsEffect = new QGraphicsDropShadowEffect(this);\n    dsEffect-&gt;setBlurRadius(5);\n    dsEffect-&gt;setOffset(0);\n    dsEffect-&gt;setColor(QColor(Qt::black));\n\n    setGraphicsEffect(dsEffect);\n}\n\nQString CaptureButton::globalStyleSheet()\n{\n    return CaptureButton(nullptr).styleSheet();\n}\n\nQString CaptureButton::styleSheet() const\n{\n    QString baseSheet = \"CaptureButton { border: none;\"\n                        \"padding: 3px 8px;\"\n                        \"background-color: %1; color: %4 }\"\n                        \"CaptureToolButton { border-radius: %3;\"\n                        \"padding: 0; }\"\n                        \"CaptureButton:hover { background-color: %2; }\"\n                        \"CaptureButton:pressed:!hover { \"\n                        \"background-color: %1; }\";\n    // define color when mouse is hovering\n    QColor contrast = ColorUtils::contrastColor(m_mainColor);\n    // foreground color\n    QColor color = ColorUtils::colorIsDark(m_mainColor) ? Qt::white : Qt::black;\n\n    return baseSheet.arg(m_mainColor.name())\n      .arg(contrast.name())\n      .arg(GlobalValues::buttonBaseSize() / 2)\n      .arg(color.name());\n}\n\nvoid CaptureButton::setColor(const QColor&amp; c)\n{\n    m_mainColor = c;\n    setStyleSheet(styleSheet());\n}\n\nQColor CaptureButton::m_mainColor;\n\n</code></pre>"},{"location":"flameshot/capturebutton_8h/","title":"File capturebutton.h","text":"<p>FileList &gt; capture &gt; capturebutton.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QPushButton&gt;</code></li> </ul>"},{"location":"flameshot/capturebutton_8h/#classes","title":"Classes","text":"Type Name class CaptureButton"},{"location":"flameshot/capturebutton_8h_source/","title":"File capturebutton.h","text":"<p>File List &gt; capture &gt; capturebutton.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QPushButton&gt;\n\nclass CaptureButton : public QPushButton\n{\n    Q_OBJECT\n\npublic:\n    CaptureButton() = delete;\n    CaptureButton(QWidget* parent = nullptr);\n    CaptureButton(const QString&amp; text, QWidget* parent = nullptr);\n    CaptureButton(const QIcon&amp; icon,\n                  const QString&amp; text,\n                  QWidget* parent = nullptr);\n\n    static QString globalStyleSheet();\n\n    QString styleSheet() const;\n\n    void setColor(const QColor&amp; c);\n\nprivate:\n    static QColor m_mainColor;\n\n    void init();\n};\n\n</code></pre>"},{"location":"flameshot/capturetoolbutton_8cpp/","title":"File capturetoolbutton.cpp","text":"<p>FileList &gt; capture &gt; capturetoolbutton.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetoolbutton.h\"</code></li> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include \"src/tools/toolfactory.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPropertyAnimation&gt;</code></li> <li><code>#include &lt;QToolTip&gt;</code></li> </ul>"},{"location":"flameshot/capturetoolbutton_8cpp/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::map&lt; CaptureTool::Type, int &gt; buttonTypeOrder   = { { CaptureTool::TYPE_PENCIL, 0 }, { CaptureTool::TYPE_DRAWER, 1 }, { CaptureTool::TYPE_ARROW, 2 }, { CaptureTool::TYPE_SELECTION, 3 }, { CaptureTool::TYPE_RECTANGLE, 4 }, { CaptureTool::TYPE_CIRCLE, 5 }, { CaptureTool::TYPE_MARKER, 6 }, { CaptureTool::TYPE_TEXT, 7 }, { CaptureTool::TYPE_PIXELATE, 8 }, { CaptureTool::TYPE_INVERT, 9 }, { CaptureTool::TYPE_CIRCLECOUNT, 10 }, { CaptureTool::TYPE_SELECTIONINDICATOR, 11 }, { CaptureTool::TYPE_MOVESELECTION, 12 }, { CaptureTool::TYPE_UNDO, 13 }, { CaptureTool::TYPE_REDO, 14 }, { CaptureTool::TYPE_COPY, 15 }, { CaptureTool::TYPE_SAVE, 16 }, { CaptureTool::TYPE_IMAGEUPLOADER, 17 }, { CaptureTool::TYPE_ACCEPT, 18 }, <pre><code>  { CaptureTool::TYPE\\_OPEN\\_APP, 19 }, { CaptureTool::TYPE\\_EXIT, 20 },\n  { CaptureTool::TYPE\\_PIN, 21 },\n\n\n\n\n  { CaptureTool::TYPE\\_SIZEINCREASE, 22 },\n  { CaptureTool::TYPE\\_SIZEDECREASE, 23 },\n</code></pre> <p>} |</p>"},{"location":"flameshot/capturetoolbutton_8cpp/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"flameshot/capturetoolbutton_8cpp/#variable-buttontypeorder","title":"variable buttonTypeOrder","text":"<pre><code>std::map&lt;CaptureTool::Type, int&gt; buttonTypeOrder;\n</code></pre>"},{"location":"flameshot/capturetoolbutton_8cpp_source/","title":"File capturetoolbutton.cpp","text":"<p>File List &gt; capture &gt; capturetoolbutton.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"capturetoolbutton.h\"\n#include \"src/tools/capturetool.h\"\n#include \"src/tools/toolfactory.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QApplication&gt;\n#include &lt;QIcon&gt;\n#include &lt;QMouseEvent&gt;\n#include &lt;QPropertyAnimation&gt;\n#include &lt;QToolTip&gt;\n\n// Button represents a single button of the capture widget, it can enable\n// multiple functionality.\n\nCaptureToolButton::CaptureToolButton(const CaptureTool::Type t, QWidget* parent)\n  : CaptureButton(parent)\n  , m_buttonType(t)\n  , m_tool(nullptr)\n  , m_emergeAnimation(nullptr)\n{\n    initButton();\n    if (t == CaptureTool::TYPE_SELECTIONINDICATOR) {\n        QFont f = this-&gt;font();\n        setFont(QFont(f.family(), 7, QFont::Bold));\n    } else {\n        updateIcon();\n    }\n}\n\nCaptureToolButton::~CaptureToolButton()\n{\n    if (m_tool) {\n        delete m_tool;\n        m_tool = nullptr;\n    }\n    if (m_emergeAnimation) {\n        delete m_emergeAnimation;\n        m_emergeAnimation = nullptr;\n    }\n}\n\nvoid CaptureToolButton::initButton()\n{\n    if (m_tool) {\n        delete m_tool;\n        m_tool = nullptr;\n    }\n    m_tool = ToolFactory().CreateTool(m_buttonType, this);\n\n    resize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize());\n    setMask(QRegion(QRect(-1,\n                          -1,\n                          GlobalValues::buttonBaseSize() + 2,\n                          GlobalValues::buttonBaseSize() + 2),\n                    QRegion::Ellipse));\n\n    // Set a tooltip showing a shortcut in parentheses (if there is a shortcut)\n    QString tooltip = m_tool-&gt;description();\n    QString shortcut =\n      ConfigHandler().shortcut(QVariant::fromValue(m_buttonType).toString());\n    if (m_buttonType == CaptureTool::TYPE_COPY &amp;&amp;\n        ConfigHandler().copyOnDoubleClick()) {\n        tooltip += QStringLiteral(\" (%1Left Double-Click)\")\n                     .arg(shortcut.isEmpty() ? QString() : shortcut + \" or \");\n    } else if (!shortcut.isEmpty()) {\n        tooltip += QStringLiteral(\" (%1)\").arg(shortcut);\n    }\n    tooltip.replace(\"Return\", \"Enter\");\n    setToolTip(tooltip);\n\n    m_emergeAnimation = new QPropertyAnimation(this, \"size\", this);\n    m_emergeAnimation-&gt;setEasingCurve(QEasingCurve::InOutQuad);\n    m_emergeAnimation-&gt;setDuration(80);\n    m_emergeAnimation-&gt;setStartValue(QSize(0, 0));\n    m_emergeAnimation-&gt;setEndValue(\n      QSize(GlobalValues::buttonBaseSize(), GlobalValues::buttonBaseSize()));\n}\n\nvoid CaptureToolButton::updateIcon()\n{\n    setIcon(icon());\n    setIconSize(size() * 0.6);\n}\n\nconst QList&lt;CaptureTool::Type&gt;&amp; CaptureToolButton::getIterableButtonTypes()\n{\n    return iterableButtonTypes;\n}\n\n// get icon returns the icon for the type of button\nQIcon CaptureToolButton::icon() const\n{\n    return m_tool-&gt;icon(m_mainColor, true);\n}\n\nvoid CaptureToolButton::mousePressEvent(QMouseEvent* e)\n{\n    activateWindow();\n    if (e-&gt;button() == Qt::LeftButton) {\n        emit pressedButtonLeftClick(this);\n        emit pressed();\n    } else if (e-&gt;button() == Qt::RightButton) {\n        emit pressedButtonRightClick(this);\n        emit pressed();\n    }\n}\n\nvoid CaptureToolButton::animatedShow()\n{\n    if (!isVisible()) {\n        show();\n        m_emergeAnimation-&gt;start();\n        connect(m_emergeAnimation,\n                &amp;QPropertyAnimation::finished,\n                this,\n                [this]() { updateIcon(); });\n    }\n}\n\nCaptureTool* CaptureToolButton::tool() const\n{\n    return m_tool;\n}\n\nvoid CaptureToolButton::setColor(const QColor&amp; c)\n{\n    m_mainColor = c;\n    CaptureButton::setColor(c);\n    updateIcon();\n}\n\nQColor CaptureToolButton::m_mainColor;\n\nstatic std::map&lt;CaptureTool::Type, int&gt; buttonTypeOrder\n{\n    { CaptureTool::TYPE_PENCIL, 0 }, { CaptureTool::TYPE_DRAWER, 1 },\n      { CaptureTool::TYPE_ARROW, 2 }, { CaptureTool::TYPE_SELECTION, 3 },\n      { CaptureTool::TYPE_RECTANGLE, 4 }, { CaptureTool::TYPE_CIRCLE, 5 },\n      { CaptureTool::TYPE_MARKER, 6 }, { CaptureTool::TYPE_TEXT, 7 },\n      { CaptureTool::TYPE_PIXELATE, 8 }, { CaptureTool::TYPE_INVERT, 9 },\n      { CaptureTool::TYPE_CIRCLECOUNT, 10 },\n      { CaptureTool::TYPE_SELECTIONINDICATOR, 11 },\n      { CaptureTool::TYPE_MOVESELECTION, 12 }, { CaptureTool::TYPE_UNDO, 13 },\n      { CaptureTool::TYPE_REDO, 14 }, { CaptureTool::TYPE_COPY, 15 },\n      { CaptureTool::TYPE_SAVE, 16 }, { CaptureTool::TYPE_IMAGEUPLOADER, 17 },\n      { CaptureTool::TYPE_ACCEPT, 18 },\n#if !defined(Q_OS_MACOS)\n      { CaptureTool::TYPE_OPEN_APP, 19 }, { CaptureTool::TYPE_EXIT, 20 },\n      { CaptureTool::TYPE_PIN, 21 },\n#else\n      { CaptureTool::TYPE_EXIT, 19 }, { CaptureTool::TYPE_PIN, 20 },\n#endif\n\n      { CaptureTool::TYPE_SIZEINCREASE, 22 },\n      { CaptureTool::TYPE_SIZEDECREASE, 23 },\n};\n\nint CaptureToolButton::getPriorityByButton(CaptureTool::Type b)\n{\n    auto it = buttonTypeOrder.find(b);\n    return it == buttonTypeOrder.cend() ? (int)buttonTypeOrder.size()\n                                        : it-&gt;second;\n}\n\nQList&lt;CaptureTool::Type&gt; CaptureToolButton::iterableButtonTypes = {\n    CaptureTool::TYPE_PENCIL,        CaptureTool::TYPE_DRAWER,\n    CaptureTool::TYPE_ARROW,         CaptureTool::TYPE_SELECTION,\n    CaptureTool::TYPE_RECTANGLE,     CaptureTool::TYPE_CIRCLE,\n    CaptureTool::TYPE_MARKER,        CaptureTool::TYPE_TEXT,\n    CaptureTool::TYPE_CIRCLECOUNT,   CaptureTool::TYPE_PIXELATE,\n    CaptureTool::TYPE_MOVESELECTION, CaptureTool::TYPE_UNDO,\n    CaptureTool::TYPE_REDO,          CaptureTool::TYPE_COPY,\n    CaptureTool::TYPE_SAVE,          CaptureTool::TYPE_EXIT,\n    CaptureTool::TYPE_IMAGEUPLOADER,\n#if !defined(Q_OS_MACOS)\n    CaptureTool::TYPE_OPEN_APP,\n#endif\n    CaptureTool::TYPE_PIN,           CaptureTool::TYPE_SIZEINCREASE,\n    CaptureTool::TYPE_SIZEDECREASE,  CaptureTool::TYPE_ACCEPT,\n};\n\n</code></pre>"},{"location":"flameshot/capturetoolbutton_8h/","title":"File capturetoolbutton.h","text":"<p>FileList &gt; capture &gt; capturetoolbutton.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturebutton.h\"</code></li> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include &lt;QMap&gt;</code></li> <li><code>#include &lt;QVector&gt;</code></li> </ul>"},{"location":"flameshot/capturetoolbutton_8h/#classes","title":"Classes","text":"Type Name class CaptureToolButton"},{"location":"flameshot/capturetoolbutton_8h_source/","title":"File capturetoolbutton.h","text":"<p>File List &gt; capture &gt; capturetoolbutton.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"capturebutton.h\"\n#include \"src/tools/capturetool.h\"\n#include &lt;QMap&gt;\n#include &lt;QVector&gt;\n\nclass QWidget;\nclass QPropertyAnimation;\n\nclass CaptureToolButton : public CaptureButton\n{\n    Q_OBJECT\n\npublic:\n    explicit CaptureToolButton(const CaptureTool::Type,\n                               QWidget* parent = nullptr);\n    ~CaptureToolButton();\n\n    static const QList&lt;CaptureTool::Type&gt;&amp; getIterableButtonTypes();\n    static int getPriorityByButton(CaptureTool::Type);\n\n    QString name() const;\n    QString description() const;\n    QIcon icon() const;\n    CaptureTool* tool() const;\n\n    void setColor(const QColor&amp; c);\n    void animatedShow();\n\nprotected:\n    void mousePressEvent(QMouseEvent* e) override;\n    static QList&lt;CaptureTool::Type&gt; iterableButtonTypes;\n\n    CaptureTool* m_tool;\n\nsignals:\n    void pressedButtonLeftClick(CaptureToolButton*);\n    void pressedButtonRightClick(CaptureToolButton*);\n\nprivate:\n    CaptureToolButton(QWidget* parent = nullptr);\n    CaptureTool::Type m_buttonType;\n\n    QPropertyAnimation* m_emergeAnimation;\n\n    static QColor m_mainColor;\n\n    void initButton();\n    void updateIcon();\n};\n\n</code></pre>"},{"location":"flameshot/capturetoolobjects_8cpp/","title":"File capturetoolobjects.cpp","text":"<p>FileList &gt; capture &gt; capturetoolobjects.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetoolobjects.h\"</code></li> </ul>"},{"location":"flameshot/capturetoolobjects_8cpp/#macros","title":"Macros","text":"Type Name define SEARCH_RADIUS_FAR  5 define SEARCH_RADIUS_NEAR  3 define SEARCH_RADIUS_TEXT_HANDICAP  5"},{"location":"flameshot/capturetoolobjects_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/capturetoolobjects_8cpp/#define-search_radius_far","title":"define SEARCH_RADIUS_FAR","text":"<pre><code>#define SEARCH_RADIUS_FAR 5\n</code></pre>"},{"location":"flameshot/capturetoolobjects_8cpp/#define-search_radius_near","title":"define SEARCH_RADIUS_NEAR","text":"<pre><code>#define SEARCH_RADIUS_NEAR 3\n</code></pre>"},{"location":"flameshot/capturetoolobjects_8cpp/#define-search_radius_text_handicap","title":"define SEARCH_RADIUS_TEXT_HANDICAP","text":"<pre><code>#define SEARCH_RADIUS_TEXT_HANDICAP 5\n</code></pre>"},{"location":"flameshot/capturetoolobjects_8cpp_source/","title":"File capturetoolobjects.cpp","text":"<p>File List &gt; capture &gt; capturetoolobjects.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Yurii Puchkov &amp; Contributors\n\n#include \"capturetoolobjects.h\"\n\n#define SEARCH_RADIUS_NEAR 3\n#define SEARCH_RADIUS_FAR 5\n#define SEARCH_RADIUS_TEXT_HANDICAP 5\n\nCaptureToolObjects::CaptureToolObjects(QObject* parent)\n  : QObject(parent)\n{}\n\nvoid CaptureToolObjects::append(const QPointer&lt;CaptureTool&gt;&amp; captureTool)\n{\n    if (!captureTool.isNull()) {\n        m_captureToolObjects.append(captureTool-&gt;copy(captureTool-&gt;parent()));\n        m_imageCache.clear();\n    }\n}\n\nvoid CaptureToolObjects::insert(int index,\n                                const QPointer&lt;CaptureTool&gt;&amp; captureTool)\n{\n    if (!captureTool.isNull() &amp;&amp; index &gt;= 0 &amp;&amp;\n        index &lt;= m_captureToolObjects.size()) {\n        m_captureToolObjects.insert(index,\n                                    captureTool-&gt;copy(captureTool-&gt;parent()));\n        m_imageCache.clear();\n    }\n}\n\nQPointer&lt;CaptureTool&gt; CaptureToolObjects::at(int index)\n{\n    if (index &gt;= 0 &amp;&amp; index &lt; m_captureToolObjects.size()) {\n        return m_captureToolObjects[index];\n    }\n    return nullptr;\n}\n\nvoid CaptureToolObjects::clear()\n{\n    m_captureToolObjects.clear();\n}\n\nQList&lt;QPointer&lt;CaptureTool&gt;&gt; CaptureToolObjects::captureToolObjects()\n{\n    return m_captureToolObjects;\n}\n\nint CaptureToolObjects::size()\n{\n    return m_captureToolObjects.size();\n}\n\nvoid CaptureToolObjects::removeAt(int index)\n{\n    if (index &gt;= 0 &amp;&amp; index &lt; m_captureToolObjects.size()) {\n        m_captureToolObjects.removeAt(index);\n        m_imageCache.clear();\n    }\n}\n\nint CaptureToolObjects::find(const QPoint&amp; pos, QSize captureSize)\n{\n    if (m_captureToolObjects.empty()) {\n        return -1;\n    }\n    QPixmap pixmap(captureSize);\n    pixmap.fill(Qt::transparent);\n    QPainter painter(&amp;pixmap);\n    // first attempt to find at exact position\n    int radius = SEARCH_RADIUS_NEAR;\n    int index = findWithRadius(painter, pixmap, pos, radius);\n    if (-1 == index) {\n        // second attempt to find at position with radius\n        radius = SEARCH_RADIUS_FAR;\n        pixmap.fill(Qt::transparent);\n        index = findWithRadius(painter, pixmap, pos, radius);\n    }\n    return index;\n}\n\nint CaptureToolObjects::findWithRadius(QPainter&amp; painter,\n                                       QPixmap&amp; pixmap,\n                                       const QPoint&amp; pos,\n                                       int radius)\n{\n    int index = m_captureToolObjects.size() - 1;\n    bool useCache = true;\n    m_imageCache.clear();\n    if (m_imageCache.size() != m_captureToolObjects.size() &amp;&amp; index &gt;= 0) {\n        // TODO - is not optimal and cache will be used just after first tool\n        // object selecting\n        m_imageCache.clear();\n        useCache = false;\n    }\n    for (; index &gt;= 0; --index) {\n        int currentRadius = radius;\n        QImage image;\n        auto toolItem = m_captureToolObjects.at(index);\n        if (useCache) {\n            image = m_imageCache.at(index);\n        } else {\n            // create transparent image in memory and draw toolItem on it\n            toolItem-&gt;drawSearchArea(painter, pixmap);\n\n            // get color at mouse clicked position in area +/- currentRadius\n            image = pixmap.toImage();\n            m_imageCache.insert(0, image);\n        }\n\n        if (toolItem-&gt;type() == CaptureTool::TYPE_TEXT) {\n            if (currentRadius &gt; SEARCH_RADIUS_NEAR) {\n                // Text already has a big currentRadius and no need to search\n                // with a bit bigger currentRadius than\n                // SEARCH_RADIUS_TEXT_HANDICAP + SEARCH_RADIUS_NEAR\n                continue;\n            }\n\n            // Text has spaces inside to need to take a bigger currentRadius for\n            // text objects search\n            currentRadius += SEARCH_RADIUS_TEXT_HANDICAP;\n        }\n\n        for (int x = pos.x() - currentRadius; x &lt;= pos.x() + currentRadius;\n             ++x) {\n            for (int y = pos.y() - currentRadius; y &lt;= pos.y() + currentRadius;\n                 ++y) {\n                QRgb rgb = image.pixel(x, y);\n                if (rgb != 0) {\n                    // object was found, return it index (layer index)\n                    return index;\n                }\n            }\n        }\n    }\n    // no object at current pos found\n    return -1;\n}\n\nCaptureToolObjects&amp; CaptureToolObjects::operator=(\n  const CaptureToolObjects&amp; other)\n{\n    // remove extra items for this if size is bigger\n    while (this-&gt;m_captureToolObjects.size() &gt;\n           other.m_captureToolObjects.size()) {\n        this-&gt;m_captureToolObjects.removeLast();\n    }\n\n    int count = 0;\n    for (const auto&amp; item : other.m_captureToolObjects) {\n        QPointer&lt;CaptureTool&gt; itemCopy = item-&gt;copy(item-&gt;parent());\n        if (count &lt; this-&gt;m_captureToolObjects.size()) {\n            this-&gt;m_captureToolObjects[count] = itemCopy;\n        } else {\n            this-&gt;m_captureToolObjects.append(itemCopy);\n        }\n        count++;\n    }\n    return *this;\n}\n\n</code></pre>"},{"location":"flameshot/capturetoolobjects_8h/","title":"File capturetoolobjects.h","text":"<p>FileList &gt; capture &gt; capturetoolobjects.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include &lt;QList&gt;</code></li> <li><code>#include &lt;QPointer&gt;</code></li> </ul>"},{"location":"flameshot/capturetoolobjects_8h/#classes","title":"Classes","text":"Type Name class CaptureToolObjects"},{"location":"flameshot/capturetoolobjects_8h_source/","title":"File capturetoolobjects.h","text":"<p>File List &gt; capture &gt; capturetoolobjects.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021 Yurii Puchkov &amp; Contributors\n\n#ifndef FLAMESHOT_CAPTURETOOLOBJECTS_H\n#define FLAMESHOT_CAPTURETOOLOBJECTS_H\n\n#include \"src/tools/capturetool.h\"\n#include &lt;QList&gt;\n#include &lt;QPointer&gt;\n\nclass CaptureToolObjects : public QObject\n{\npublic:\n    explicit CaptureToolObjects(QObject* parent = nullptr);\n    QList&lt;QPointer&lt;CaptureTool&gt;&gt; captureToolObjects();\n    void append(const QPointer&lt;CaptureTool&gt;&amp; captureTool);\n    void insert(int index, const QPointer&lt;CaptureTool&gt;&amp; captureTool);\n    void removeAt(int index);\n    void clear();\n    int size();\n    int find(const QPoint&amp; pos, QSize captureSize);\n    QPointer&lt;CaptureTool&gt; at(int index);\n    CaptureToolObjects&amp; operator=(const CaptureToolObjects&amp; other);\n\nprivate:\n    int findWithRadius(QPainter&amp; painter,\n                       QPixmap&amp; pixmap,\n                       const QPoint&amp; pos,\n                       int radius = 0);\n\n    // class members\n    QList&lt;QPointer&lt;CaptureTool&gt;&gt; m_captureToolObjects;\n    QVector&lt;QImage&gt; m_imageCache;\n};\n\n#endif // FLAMESHOT_CAPTURETOOLOBJECTS_H\n\n</code></pre>"},{"location":"flameshot/capturewidget_8cpp/","title":"File capturewidget.cpp","text":"<p>FileList &gt; capture &gt; capturewidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturewidget.h\"</code></li> <li><code>#include \"abstractlogger.h\"</code></li> <li><code>#include \"copytool.h\"</code></li> <li><code>#include \"src/config/cacheutils.h\"</code></li> <li><code>#include \"src/config/generalconf.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/tools/toolfactory.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/screengrabber.h\"</code></li> <li><code>#include \"src/utils/screenshotsaver.h\"</code></li> <li><code>#include \"src/utils/systemnotification.h\"</code></li> <li><code>#include \"src/widgets/capture/colorpicker.h\"</code></li> <li><code>#include \"src/widgets/capture/hovereventfilter.h\"</code></li> <li><code>#include \"src/widgets/capture/modificationcommand.h\"</code></li> <li><code>#include \"src/widgets/capture/notifierbox.h\"</code></li> <li><code>#include \"src/widgets/capture/overlaymessage.h\"</code></li> <li><code>#include \"src/widgets/orientablepushbutton.h\"</code></li> <li><code>#include \"src/widgets/panel/sidepanelwidget.h\"</code></li> <li><code>#include \"src/widgets/panel/utilitypanel.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDateTime&gt;</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QDesktopWidget&gt;</code></li> <li><code>#include &lt;QFontMetrics&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QPaintEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> <li><code>#include &lt;QShortcut&gt;</code></li> <li><code>#include &lt;draggablewidgetmaker.h&gt;</code></li> <li><code>#include \"src/widgets/updatenotificationwidget.h\"</code></li> </ul>"},{"location":"flameshot/capturewidget_8cpp/#macros","title":"Macros","text":"Type Name define MOUSE_DISTANCE_TO_START_MOVING  3"},{"location":"flameshot/capturewidget_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/capturewidget_8cpp/#define-mouse_distance_to_start_moving","title":"define MOUSE_DISTANCE_TO_START_MOVING","text":"<pre><code>#define MOUSE_DISTANCE_TO_START_MOVING 3\n</code></pre>"},{"location":"flameshot/capturewidget_8cpp_source/","title":"File capturewidget.cpp","text":"<p>File List &gt; capture &gt; capturewidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// Based on Lightscreen areadialog.cpp, Copyright 2017  Christian Kaiser\n// &lt;info@ckaiser.com.ar&gt; released under the GNU GPL2\n// &lt;https://www.gnu.org/licenses/gpl-2.0.txt&gt;\n\n// Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007\n// Luca Gugelmann &lt;lucag@student.ethz.ch&gt; released under the GNU LGPL\n// &lt;http://www.gnu.org/licenses/old-licenses/library.txt&gt;\n\n#include \"capturewidget.h\"\n#include \"abstractlogger.h\"\n#include \"copytool.h\"\n#include \"src/config/cacheutils.h\"\n#include \"src/config/generalconf.h\"\n#include \"src/core/flameshot.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/tools/toolfactory.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/screengrabber.h\"\n#include \"src/utils/screenshotsaver.h\"\n#include \"src/utils/systemnotification.h\"\n#include \"src/widgets/capture/colorpicker.h\"\n#include \"src/widgets/capture/hovereventfilter.h\"\n#include \"src/widgets/capture/modificationcommand.h\"\n#include \"src/widgets/capture/notifierbox.h\"\n#include \"src/widgets/capture/overlaymessage.h\"\n#include \"src/widgets/orientablepushbutton.h\"\n#include \"src/widgets/panel/sidepanelwidget.h\"\n#include \"src/widgets/panel/utilitypanel.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDateTime&gt;\n#include &lt;QDebug&gt;\n#include &lt;QDesktopWidget&gt;\n#include &lt;QFontMetrics&gt;\n#include &lt;QLabel&gt;\n#include &lt;QPaintEvent&gt;\n#include &lt;QPainter&gt;\n#include &lt;QScreen&gt;\n#include &lt;QShortcut&gt;\n#include &lt;draggablewidgetmaker.h&gt;\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n#include \"src/widgets/updatenotificationwidget.h\"\n#endif\n\n#define MOUSE_DISTANCE_TO_START_MOVING 3\n\n// CaptureWidget is the main component used to capture the screen. It contains\n// an area of selection with its respective buttons.\n\n// enableSaveWindow\n\nCaptureWidget::CaptureWidget(const CaptureRequest&amp; req,\n                             bool fullScreen,\n                             QWidget* parent)\n  : QWidget(parent)\n  , m_toolSizeByKeyboard(0)\n  , m_mouseIsClicked(false)\n  , m_captureDone(false)\n  , m_previewEnabled(true)\n  , m_adjustmentButtonPressed(false)\n  , m_configError(false)\n  , m_configErrorResolved(false)\n#if !defined(DISABLE_UPDATE_CHECKER)\n  , m_updateNotificationWidget(nullptr)\n#endif\n  , m_lastMouseWheel(0)\n  , m_activeButton(nullptr)\n  , m_activeTool(nullptr)\n  , m_activeToolIsMoved(false)\n  , m_toolWidget(nullptr)\n  , m_panel(nullptr)\n  , m_sidePanel(nullptr)\n  , m_colorPicker(nullptr)\n  , m_selection(nullptr)\n  , m_magnifier(nullptr)\n  , m_xywhDisplay(false)\n  , m_existingObjectIsChanged(false)\n  , m_startMove(false)\n\n{\n    m_undoStack.setUndoLimit(ConfigHandler().undoLimit());\n    m_context.circleCount = 1;\n\n    // Base config of the widget\n    m_eventFilter = new HoverEventFilter(this);\n    connect(m_eventFilter,\n            &amp;HoverEventFilter::hoverIn,\n            this,\n            &amp;CaptureWidget::childEnter);\n    connect(m_eventFilter,\n            &amp;HoverEventFilter::hoverOut,\n            this,\n            &amp;CaptureWidget::childLeave);\n    connect(&amp;m_xywhTimer, &amp;QTimer::timeout, this, &amp;CaptureWidget::xywhTick);\n    // else xywhTick keeps triggering when not needed\n    m_xywhTimer.setSingleShot(true);\n    setAttribute(Qt::WA_DeleteOnClose);\n    setAttribute(Qt::WA_QuitOnClose, false);\n    m_opacity = m_config.contrastOpacity();\n    m_uiColor = m_config.uiColor();\n    m_contrastUiColor = m_config.contrastUiColor();\n    setMouseTracking(true);\n    initContext(fullScreen, req);\n#if (defined(Q_OS_WIN) || defined(Q_OS_MACOS))\n    // Top left of the whole set of screens\n    QPoint topLeft(0, 0);\n#endif\n    if (fullScreen) {\n        // Grab Screenshot\n        bool ok = true;\n        m_context.screenshot = ScreenGrabber().grabEntireDesktop(ok);\n        if (!ok) {\n            AbstractLogger::error() &lt;&lt; tr(\"Unable to capture screen\");\n            this-&gt;close();\n        }\n        m_context.origScreenshot = m_context.screenshot;\n\n#if defined(Q_OS_WIN)\n// Call cmake with -DFLAMESHOT_DEBUG_CAPTURE=ON to enable easier debugging\n#if !defined(FLAMESHOT_DEBUG_CAPTURE)\n        setWindowFlags(Qt::WindowStaysOnTopHint | Qt::FramelessWindowHint |\n                       Qt::SubWindow // Hides the taskbar icon\n        );\n#endif\n\n        for (QScreen* const screen : QGuiApplication::screens()) {\n            QPoint topLeftScreen = screen-&gt;geometry().topLeft();\n\n            if (topLeftScreen.x() &lt; topLeft.x()) {\n                topLeft.setX(topLeftScreen.x());\n            }\n            if (topLeftScreen.y() &lt; topLeft.y()) {\n                topLeft.setY(topLeftScreen.y());\n            }\n        }\n        move(topLeft);\n        resize(pixmap().size());\n#elif defined(Q_OS_MACOS)\n        // Emulate fullscreen mode\n        //        setWindowFlags(Qt::WindowStaysOnTopHint |\n        //        Qt::BypassWindowManagerHint |\n        //                       Qt::FramelessWindowHint |\n        //                       Qt::NoDropShadowWindowHint | Qt::ToolTip |\n        //                       Qt::Popup\n        //                       );\n        QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n        move(currentScreen-&gt;geometry().x(), currentScreen-&gt;geometry().y());\n        resize(currentScreen-&gt;size());\n#else\n// Call cmake with -DFLAMESHOT_DEBUG_CAPTURE=ON to enable easier debugging\n#if !defined(FLAMESHOT_DEBUG_CAPTURE)\n        setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint |\n                       Qt::FramelessWindowHint | Qt::Tool);\n        resize(pixmap().size());\n#endif\n#endif\n    }\n    QVector&lt;QRect&gt; areas;\n    if (m_context.fullscreen) {\n        QPoint topLeftOffset = QPoint(0, 0);\n#if defined(Q_OS_WIN)\n        topLeftOffset = topLeft;\n#endif\n\n#if defined(Q_OS_MACOS)\n        // MacOS works just with one active display, so we need to append\n        // just one current display and keep multiple displays logic for\n        // other OS\n        QRect r;\n        QScreen* screen = QGuiAppCurrentScreen().currentScreen();\n        r = screen-&gt;geometry();\n        // all calculations are processed according to (0, 0) start\n        // point so we need to move current object to (0, 0)\n        r.moveTo(0, 0);\n        areas.append(r);\n#else\n        for (QScreen* const screen : QGuiApplication::screens()) {\n            QRect r = screen-&gt;geometry();\n            r.moveTo(r.x() / screen-&gt;devicePixelRatio(),\n                     r.y() / screen-&gt;devicePixelRatio());\n            r.moveTo(r.topLeft() - topLeftOffset);\n            areas.append(r);\n        }\n#endif\n    } else {\n        areas.append(rect());\n    }\n\n    m_buttonHandler = new ButtonHandler(this);\n    m_buttonHandler-&gt;updateScreenRegions(areas);\n    m_buttonHandler-&gt;hide();\n\n    initButtons();\n    initSelection(); // button handler must be initialized before\n    initShortcuts(); // must be called after initSelection\n    // init magnify\n    if (m_config.showMagnifier()) {\n        m_magnifier = new MagnifierWidget(\n          m_context.screenshot, m_uiColor, m_config.squareMagnifier(), this);\n    }\n\n    // Init color picker\n    m_colorPicker = new ColorPicker(this);\n    connect(m_colorPicker,\n            &amp;ColorPicker::colorSelected,\n            this,\n            [this](const QColor&amp; c) {\n                m_context.mousePos = mapFromGlobal(QCursor::pos());\n                setDrawColor(c);\n            });\n    m_colorPicker-&gt;hide();\n\n    // Init tool size sigslots\n    connect(this,\n            &amp;CaptureWidget::toolSizeChanged,\n            this,\n            &amp;CaptureWidget::onToolSizeChanged);\n\n    // Init notification widget\n    m_notifierBox = new NotifierBox(this);\n    m_notifierBox-&gt;hide();\n    connect(m_notifierBox, &amp;NotifierBox::hidden, this, [this]() {\n        // Show cursor if it was hidden while adjusting tool size\n        updateCursor();\n        m_toolSizeByKeyboard = 0;\n        onToolSizeChanged(m_context.toolSize);\n        onToolSizeSettled(m_context.toolSize);\n    });\n\n    initPanel();\n\n    m_config.checkAndHandleError();\n    if (m_config.hasError()) {\n        m_configError = true;\n    }\n    connect(ConfigHandler::getInstance(), &amp;ConfigHandler::error, this, [=]() {\n        m_configError = true;\n        m_configErrorResolved = false;\n        OverlayMessage::instance()-&gt;update();\n    });\n    connect(\n      ConfigHandler::getInstance(), &amp;ConfigHandler::errorResolved, this, [=]() {\n          m_configError = false;\n          m_configErrorResolved = true;\n          OverlayMessage::instance()-&gt;update();\n      });\n\n    OverlayMessage::init(this,\n                         QGuiAppCurrentScreen().currentScreen()-&gt;geometry());\n\n    if (m_config.showHelp()) {\n        initHelpMessage();\n        OverlayMessage::push(m_helpMessage);\n    }\n\n    updateCursor();\n}\n\nCaptureWidget::~CaptureWidget()\n{\n#if defined(Q_OS_MACOS)\n    for (QWidget* widget : qApp-&gt;topLevelWidgets()) {\n        QString className(widget-&gt;metaObject()-&gt;className());\n        if (0 ==\n            className.compare(CaptureWidget::staticMetaObject.className())) {\n            widget-&gt;showNormal();\n            widget-&gt;hide();\n            break;\n        }\n    }\n#endif\n    if (m_captureDone) {\n        auto lastRegion = m_selection-&gt;geometry();\n        setLastRegion(lastRegion);\n        QRect geometry(m_context.selection);\n        geometry.setTopLeft(geometry.topLeft() + m_context.widgetOffset);\n        Flameshot::instance()-&gt;exportCapture(\n          pixmap(), geometry, m_context.request);\n    } else {\n        emit Flameshot::instance()-&gt;captureFailed();\n    }\n}\n\nvoid CaptureWidget::initButtons()\n{\n    auto allButtonTypes = CaptureToolButton::getIterableButtonTypes();\n    auto visibleButtonTypes = m_config.buttons();\n    if ((m_context.request.tasks() == CaptureRequest::NO_TASK) ||\n        (m_context.request.tasks() == CaptureRequest::PRINT_GEOMETRY)) {\n        allButtonTypes.removeOne(CaptureTool::TYPE_ACCEPT);\n        visibleButtonTypes.removeOne(CaptureTool::TYPE_ACCEPT);\n    } else {\n        // Remove irrelevant buttons from both lists\n        for (auto* buttonList : { &amp;allButtonTypes, &amp;visibleButtonTypes }) {\n            buttonList-&gt;removeOne(CaptureTool::TYPE_SAVE);\n            buttonList-&gt;removeOne(CaptureTool::TYPE_COPY);\n            buttonList-&gt;removeOne(CaptureTool::TYPE_IMAGEUPLOADER);\n            buttonList-&gt;removeOne(CaptureTool::TYPE_OPEN_APP);\n            buttonList-&gt;removeOne(CaptureTool::TYPE_PIN);\n        }\n    }\n    QVector&lt;CaptureToolButton*&gt; vectorButtons;\n\n    // Add all buttons but hide those that were disabled in the Interface config\n    // This will allow keyboard shortcuts for those buttons to work\n    for (CaptureTool::Type t : allButtonTypes) {\n        auto* b = new CaptureToolButton(t, this);\n        if (t == CaptureTool::TYPE_SELECTIONINDICATOR) {\n            m_sizeIndButton = b;\n        }\n        b-&gt;setColor(m_uiColor);\n        b-&gt;hide();\n        // must be enabled for SelectionWidget's eventFilter to work correctly\n        b-&gt;setAttribute(Qt::WA_NoMousePropagation);\n        makeChild(b);\n\n        switch (t) {\n            case CaptureTool::TYPE_UNDO:\n            case CaptureTool::TYPE_REDO:\n                // nothing to do, just skip non-dynamic buttons with existing\n                // hard coded slots\n                break;\n            default:\n                // Set shortcuts for a tool\n                QString shortcut =\n                  ConfigHandler().shortcut(QVariant::fromValue(t).toString());\n                if (!shortcut.isNull()) {\n                    auto shortcuts = newShortcut(shortcut, this, nullptr);\n                    for (auto* sc : shortcuts) {\n                        connect(sc, &amp;QShortcut::activated, this, [=]() {\n                            setState(b);\n                        });\n                    }\n                }\n                break;\n        }\n\n        m_tools[t] = b-&gt;tool();\n\n        connect(b-&gt;tool(),\n                &amp;CaptureTool::requestAction,\n                this,\n                &amp;CaptureWidget::handleToolSignal);\n\n        if (visibleButtonTypes.contains(t)) {\n            connect(b,\n                    &amp;CaptureToolButton::pressedButtonLeftClick,\n                    this,\n                    &amp;CaptureWidget::handleButtonLeftClick);\n\n            if (b-&gt;tool()-&gt;isSelectable()) {\n                connect(b,\n                        &amp;CaptureToolButton::pressedButtonRightClick,\n                        this,\n                        &amp;CaptureWidget::handleButtonRightClick);\n            }\n\n            vectorButtons &lt;&lt; b;\n        }\n    }\n    m_buttonHandler-&gt;setButtons(vectorButtons);\n}\n\nvoid CaptureWidget::handleButtonRightClick(CaptureToolButton* b)\n{\n    if (!b) {\n        return;\n    }\n\n    // if button already selected, do not deselect it on right click\n    if (!m_activeButton || m_activeButton != b) {\n        setState(b);\n    }\n    if (!m_panel-&gt;isVisible()) {\n        m_panel-&gt;show();\n    }\n}\n\nvoid CaptureWidget::handleButtonLeftClick(CaptureToolButton* b)\n{\n    if (!b) {\n        return;\n    }\n    setState(b);\n}\n\nvoid CaptureWidget::xywhTick()\n{\n    m_xywhDisplay = false;\n    update();\n}\n\nvoid CaptureWidget::onDisplayGridChanged(bool display)\n{\n    m_displayGrid = display;\n    repaint();\n}\n\nvoid CaptureWidget::onGridSizeChanged(int size)\n{\n    m_gridSize = size;\n    repaint();\n}\n\nvoid CaptureWidget::showxywh()\n{\n    m_xywhDisplay = true;\n    update();\n    int timeout = m_config.showSelectionGeometryHideTime();\n    if (timeout != 0) {\n        m_xywhTimer.start(timeout);\n    }\n}\n\nvoid CaptureWidget::initHelpMessage()\n{\n    QList&lt;QPair&lt;QString, QString&gt;&gt; keyMap;\n    keyMap &lt;&lt; QPair(tr(\"Mouse\"), tr(\"Select screenshot area\"));\n    using CT = CaptureTool;\n    for (auto toolType : { CT::TYPE_ACCEPT, CT::TYPE_SAVE, CT::TYPE_COPY }) {\n        if (!m_tools.contains(toolType)) {\n            continue;\n        }\n        auto* tool = m_tools[toolType];\n        QString shortcut =\n          ConfigHandler().shortcut(QVariant::fromValue(toolType).toString());\n        shortcut.replace(\"Return\", \"Enter\");\n        if (!shortcut.isEmpty()) {\n            keyMap &lt;&lt; QPair(shortcut, tool-&gt;description());\n        }\n    }\n    keyMap &lt;&lt; QPair(tr(\"Mouse Wheel\"), tr(\"Change tool size\"));\n    keyMap &lt;&lt; QPair(tr(\"Right Click\"), tr(\"Show color picker\"));\n    keyMap &lt;&lt; QPair(ConfigHandler().shortcut(\"TYPE_TOGGLE_PANEL\"),\n                    tr(\"Open side panel\"));\n    keyMap &lt;&lt; QPair(tr(\"Esc\"), tr(\"Exit\"));\n\n    m_helpMessage = OverlayMessage::compileFromKeyMap(keyMap);\n}\n\nQPixmap CaptureWidget::pixmap()\n{\n    return m_context.selectedScreenshotArea();\n}\n\n// Finish whatever the current tool is doing, if there is a current active\n// tool.\nbool CaptureWidget::commitCurrentTool()\n{\n    if (m_activeTool) {\n        processPixmapWithTool(&amp;m_context.screenshot, m_activeTool);\n        if (m_activeTool-&gt;isValid() &amp;&amp; !m_activeTool-&gt;editMode() &amp;&amp;\n            m_toolWidget) {\n            pushToolToStack();\n        }\n        if (m_toolWidget) {\n            m_toolWidget-&gt;update();\n        }\n        releaseActiveTool();\n        return true;\n    }\n    return false;\n}\n\nvoid CaptureWidget::deleteToolWidgetOrClose()\n{\n    if (m_activeButton != nullptr) {\n        uncheckActiveTool();\n    } else if (m_panel-&gt;activeLayerIndex() &gt;= 0) {\n        // remove active tool selection\n        m_panel-&gt;setActiveLayer(-1);\n    } else if (m_panel-&gt;isVisible()) {\n        // hide panel if visible\n        m_panel-&gt;hide();\n    } else if (m_toolWidget) {\n        // delete toolWidget if exists\n        m_toolWidget-&gt;hide();\n        delete m_toolWidget;\n        m_toolWidget = nullptr;\n    } else if (m_colorPicker &amp;&amp; m_colorPicker-&gt;isVisible()) {\n        m_colorPicker-&gt;hide();\n    } else {\n        // close CaptureWidget\n        close();\n    }\n}\n\nvoid CaptureWidget::releaseActiveTool()\n{\n    if (m_activeTool) {\n        if (m_activeTool-&gt;editMode()) {\n            // Object shouldn't be deleted here because it is in the undo/redo\n            // stack, just set current pointer to null\n            m_activeTool-&gt;setEditMode(false);\n            if (m_activeTool-&gt;isChanged()) {\n                pushObjectsStateToUndoStack();\n            }\n        } else {\n            delete m_activeTool;\n        }\n        m_activeTool = nullptr;\n    }\n    if (m_toolWidget) {\n        m_toolWidget-&gt;hide();\n        delete m_toolWidget;\n        m_toolWidget = nullptr;\n    }\n}\n\nvoid CaptureWidget::uncheckActiveTool()\n{\n    // uncheck active tool\n    m_panel-&gt;setToolWidget(nullptr);\n    m_activeButton-&gt;setColor(m_uiColor);\n    updateTool(activeButtonTool());\n    m_activeButton = nullptr;\n    releaseActiveTool();\n    updateSelectionState();\n    updateCursor();\n}\n\nvoid CaptureWidget::paintEvent(QPaintEvent* paintEvent)\n{\n    Q_UNUSED(paintEvent)\n    QPainter painter(this);\n    GeneralConf::xywh_position position =\n      static_cast&lt;GeneralConf::xywh_position&gt;(m_config.showSelectionGeometry());\n    /* QPainter::save and restore is somewhat costly so we try to guess\n       if we need to do it here. What that means is that if you add\n       anything to the paintEvent and want to save/restore you should\n       add a test to the below if statement -- also if you change\n       any of the conditions that current trigger it you'll need to change here,\n       too\n    */\n    bool save = false;\n    if (m_xywhDisplay ||                           // clause 1: xywh display\n        m_displayGrid ||                           // clause 2: display grid\n        (m_activeTool &amp;&amp; m_mouseIsClicked) ||      // clause 3: tool/click\n        (m_previewEnabled &amp;&amp; activeButtonTool() &amp;&amp; // clause 4: mouse preview\n         m_activeButton-&gt;tool()-&gt;showMousePreview())) {\n        painter.save();\n        save = true;\n    }\n    painter.drawPixmap(0, 0, m_context.screenshot);\n    if (m_selection &amp;&amp; m_xywhDisplay) {\n        const QRect&amp; selection = m_selection-&gt;geometry().normalized();\n        const qreal scale = m_context.screenshot.devicePixelRatio();\n        QRect xybox;\n        QFontMetrics fm = painter.fontMetrics();\n\n        QString xy = QString(\"%1x%2+%3+%4\")\n                       .arg(static_cast&lt;int&gt;(selection.width() * scale))\n                       .arg(static_cast&lt;int&gt;(selection.height() * scale))\n                       .arg(static_cast&lt;int&gt;(selection.left() * scale))\n                       .arg(static_cast&lt;int&gt;(selection.top() * scale));\n\n        xybox = fm.boundingRect(xy);\n        // the small numbers here are just margins so the text doesn't\n        // smack right up to the box; they aren't critical and the box\n        // size itself is tied to the font metrics\n        xybox.adjust(0, 0, 10, 12);\n        // in anticipation of making the position adjustable\n        int x0, y0;\n        // Move these to header\n\n        switch (position) {\n            case GeneralConf::xywh_top_left:\n                x0 = selection.left();\n                y0 = selection.top();\n                break;\n            case GeneralConf::xywh_bottom_left:\n                x0 = selection.left();\n                y0 = selection.bottom() - xybox.height();\n                break;\n            case GeneralConf::xywh_top_right:\n                x0 = selection.right() - xybox.width();\n                y0 = selection.top();\n                break;\n            case GeneralConf::xywh_bottom_right:\n                x0 = selection.right() - xybox.width();\n                y0 = selection.bottom() - xybox.height();\n                break;\n            case GeneralConf::xywh_center:\n            default:\n                x0 = selection.left() + (selection.width() - xybox.width()) / 2;\n                y0 =\n                  selection.top() + (selection.height() - xybox.height()) / 2;\n        }\n\n        QColor uicolor = ConfigHandler().uiColor();\n        uicolor.setAlpha(200);\n        painter.fillRect(\n          x0, y0, xybox.width(), xybox.height(), QBrush(uicolor));\n        painter.setPen(ColorUtils::colorIsDark(uicolor) ? Qt::white\n                                                        : Qt::black);\n        painter.drawText(x0,\n                         y0,\n                         xybox.width(),\n                         xybox.height(),\n                         Qt::AlignVCenter | Qt::AlignHCenter,\n                         xy);\n    }\n\n    if (m_displayGrid) {\n        QColor uicolor = ConfigHandler().uiColor();\n        uicolor.setAlpha(100);\n        painter.setPen(uicolor);\n        painter.setBrush(QBrush(uicolor));\n\n        auto topLeft = mapToGlobal(m_context.selection.topLeft());\n        topLeft.rx() -= topLeft.x() % m_gridSize;\n        topLeft.ry() -= topLeft.y() % m_gridSize;\n        topLeft = mapFromGlobal(topLeft);\n\n        const auto scale{ m_context.screenshot.devicePixelRatio() };\n        const auto step{ m_gridSize * scale };\n        const auto radius{ 1 * scale };\n\n        for (int y = topLeft.y(); y &lt; m_context.selection.bottom(); y += step) {\n            for (int x = topLeft.x(); x &lt; m_context.selection.right();\n                 x += step) {\n                painter.drawEllipse(x, y, radius, radius);\n            }\n        }\n    }\n\n    if (m_activeTool &amp;&amp; m_mouseIsClicked) {\n        m_activeTool-&gt;process(painter, m_context.screenshot);\n    } else if (m_previewEnabled &amp;&amp; activeButtonTool() &amp;&amp;\n               m_activeButton-&gt;tool()-&gt;showMousePreview()) {\n        m_activeButton-&gt;tool()-&gt;paintMousePreview(painter, m_context);\n    }\n    if (save)\n        painter.restore();\n    // draw inactive region\n    drawInactiveRegion(&amp;painter);\n\n    if (!isActiveWindow()) {\n        drawErrorMessage(\n          tr(\"Flameshot has lost focus. Keyboard shortcuts won't \"\n             \"work until you click somewhere.\"),\n          &amp;painter);\n    } else if (m_configError) {\n        drawErrorMessage(ConfigHandler().errorMessage(), &amp;painter);\n    } else if (m_configErrorResolved) {\n        drawErrorMessage(tr(\"Configuration error resolved. Launch `flameshot \"\n                            \"gui` again to apply it.\"),\n                         &amp;painter);\n    }\n}\n\nvoid CaptureWidget::showColorPicker(const QPoint&amp; pos)\n{\n    // Try to select new object if current pos out of active object\n    auto toolItem = activeToolObject();\n    if (!toolItem || (toolItem &amp;&amp; !toolItem-&gt;boundingRect().contains(pos))) {\n        selectToolItemAtPos(pos);\n    }\n\n    // save current state for undo/redo stack\n    if (m_panel-&gt;activeLayerIndex() &gt;= 0) {\n        m_captureToolObjectsBackup = m_captureToolObjects;\n    }\n\n    // Call color picker\n    m_colorPicker-&gt;move(pos.x() - m_colorPicker-&gt;width() / 2,\n                        pos.y() - m_colorPicker-&gt;height() / 2);\n    m_colorPicker-&gt;raise();\n    m_colorPicker-&gt;show();\n}\n\nbool CaptureWidget::startDrawObjectTool(const QPoint&amp; pos)\n{\n    if (activeButtonToolType() != CaptureTool::NONE &amp;&amp;\n        activeButtonToolType() != CaptureTool::TYPE_MOVESELECTION) {\n        if (commitCurrentTool()) {\n            return false;\n        }\n        m_activeTool = m_activeButton-&gt;tool()-&gt;copy(this);\n\n        connect(this,\n                &amp;CaptureWidget::colorChanged,\n                m_activeTool,\n                &amp;CaptureTool::onColorChanged);\n        connect(this,\n                &amp;CaptureWidget::toolSizeChanged,\n                m_activeTool,\n                &amp;CaptureTool::onSizeChanged);\n        connect(m_activeTool,\n                &amp;CaptureTool::requestAction,\n                this,\n                &amp;CaptureWidget::handleToolSignal);\n\n        m_context.mousePos = m_displayGrid ? snapToGrid(pos) : pos;\n        m_activeTool-&gt;drawStart(m_context);\n        // TODO this is the wrong place to do this\n\n        if (m_activeTool-&gt;type() == CaptureTool::TYPE_CIRCLECOUNT) {\n            m_activeTool-&gt;setCount(m_context.circleCount++);\n        }\n\n        return true;\n    }\n    return false;\n}\n\nvoid CaptureWidget::pushObjectsStateToUndoStack()\n{\n    m_undoStack.push(new ModificationCommand(\n      this, m_captureToolObjects, m_captureToolObjectsBackup));\n    m_captureToolObjectsBackup.clear();\n}\n\nint CaptureWidget::selectToolItemAtPos(const QPoint&amp; pos)\n{\n    // Try to select existing tool, \"-1\" - no active tool\n    int activeLayerIndex = -1;\n    auto selectionMouseSide = m_selection-&gt;getMouseSide(pos);\n    if (m_activeButton.isNull() &amp;&amp;\n        m_captureToolObjects.captureToolObjects().size() &gt; 0 &amp;&amp;\n        (selectionMouseSide == SelectionWidget::NO_SIDE ||\n         selectionMouseSide == SelectionWidget::CENTER)) {\n        auto toolItem = activeToolObject();\n        if (!toolItem ||\n            (toolItem &amp;&amp; !toolItem-&gt;boundingRect().contains(pos))) {\n            activeLayerIndex = m_captureToolObjects.find(pos, size());\n            int oldToolSize = m_context.toolSize;\n            m_panel-&gt;setActiveLayer(activeLayerIndex);\n            drawObjectSelection();\n            if (oldToolSize != m_context.toolSize) {\n                emit toolSizeChanged(m_context.toolSize);\n            }\n        }\n    }\n    return activeLayerIndex;\n}\n\nvoid CaptureWidget::mousePressEvent(QMouseEvent* e)\n{\n    activateWindow();\n    m_startMove = false;\n    m_startMovePos = QPoint();\n    m_mousePressedPos = e-&gt;pos();\n    m_activeToolOffsetToMouseOnStart = QPoint();\n    if (m_colorPicker-&gt;isVisible()) {\n        updateCursor();\n        return;\n    }\n    // reset object selection if capture area selection is active\n    if (m_selection-&gt;getMouseSide(e-&gt;pos()) != SelectionWidget::CENTER) {\n        m_panel-&gt;setActiveLayer(-1);\n    }\n\n    if (e-&gt;button() == Qt::RightButton) {\n        if (m_activeTool &amp;&amp; m_activeTool-&gt;editMode()) {\n            return;\n        }\n        showColorPicker(m_mousePressedPos);\n        return;\n    } else if (e-&gt;button() == Qt::LeftButton) {\n        m_mouseIsClicked = true;\n\n        // Click using a tool excluding tool MOVE\n        if (startDrawObjectTool(m_mousePressedPos)) {\n            // return if success\n            return;\n        }\n    }\n\n    // Commit current tool if it has edit widget and mouse click is outside\n    // of it\n    if (m_toolWidget &amp;&amp; !m_toolWidget-&gt;geometry().contains(e-&gt;pos())) {\n        commitCurrentTool();\n        m_panel-&gt;setToolWidget(nullptr);\n        drawToolsData();\n        updateLayersPanel();\n    }\n\n    selectToolItemAtPos(m_mousePressedPos);\n    updateSelectionState();\n    updateCursor();\n}\n\nvoid CaptureWidget::mouseDoubleClickEvent(QMouseEvent* event)\n{\n    int activeLayerIndex = m_panel-&gt;activeLayerIndex();\n    if (activeLayerIndex != -1) {\n        // Start object editing\n        auto activeTool = m_captureToolObjects.at(activeLayerIndex);\n        if (activeTool &amp;&amp; activeTool-&gt;type() == CaptureTool::TYPE_TEXT) {\n            m_activeTool = activeTool;\n            m_mouseIsClicked = false;\n            m_context.mousePos = *m_activeTool-&gt;pos();\n            m_captureToolObjectsBackup = m_captureToolObjects;\n            m_activeTool-&gt;setEditMode(true);\n            drawToolsData();\n            updateLayersPanel();\n            handleToolSignal(CaptureTool::REQ_ADD_CHILD_WIDGET);\n            m_panel-&gt;setToolWidget(m_activeTool-&gt;configurationWidget());\n        }\n    } else if (m_selection-&gt;geometry().contains(event-&gt;pos())) {\n        if ((event-&gt;button() == Qt::LeftButton) &amp;&amp;\n            (m_config.copyOnDoubleClick())) {\n            CopyTool copyTool;\n            connect(&amp;copyTool,\n                    &amp;CopyTool::requestAction,\n                    this,\n                    &amp;CaptureWidget::handleToolSignal);\n            copyTool.pressed(m_context);\n            qApp-&gt;processEvents(QEventLoop::ExcludeUserInputEvents);\n        }\n    }\n}\n\nvoid CaptureWidget::mouseMoveEvent(QMouseEvent* e)\n{\n    if (m_magnifier) {\n        if (!m_activeButton) {\n            m_magnifier-&gt;show();\n            m_magnifier-&gt;update();\n        } else {\n            m_magnifier-&gt;hide();\n        }\n    }\n\n    m_context.mousePos = e-&gt;pos();\n    if (e-&gt;buttons() != Qt::LeftButton) {\n        updateTool(activeButtonTool());\n        updateCursor();\n        return;\n    }\n\n    // The rest assumes that left mouse button is clicked\n    if (!m_activeButton &amp;&amp; m_panel-&gt;activeLayerIndex() &gt;= 0) {\n        // Move existing object\n        if (!m_startMove) {\n            // Check for the minimal offset to start moving an object\n            if (m_startMovePos.isNull()) {\n                m_startMovePos = e-&gt;pos();\n            }\n            if ((e-&gt;pos() - m_startMovePos).manhattanLength() &gt;\n                MOUSE_DISTANCE_TO_START_MOVING) {\n                m_startMove = true;\n            }\n        }\n        if (m_startMove) {\n            QPointer&lt;CaptureTool&gt; activeTool =\n              m_captureToolObjects.at(m_panel-&gt;activeLayerIndex());\n            if (m_activeToolOffsetToMouseOnStart.isNull()) {\n                setCursor(Qt::ClosedHandCursor);\n                m_activeToolOffsetToMouseOnStart =\n                  e-&gt;pos() - *activeTool-&gt;pos();\n            }\n            if (!m_activeToolIsMoved) {\n                // save state before movement for undo stack\n                m_captureToolObjectsBackup = m_captureToolObjects;\n            }\n            m_activeToolIsMoved = true;\n            // update the old region of the selection, margins are added to\n            // ensure selection outline is updated too\n            update(paddedUpdateRect(activeTool-&gt;boundingRect()));\n            activeTool-&gt;move(e-&gt;pos() - m_activeToolOffsetToMouseOnStart);\n            drawToolsData();\n        }\n    } else if (m_activeTool) {\n        // drawing with a tool\n        if (m_adjustmentButtonPressed) {\n            m_activeTool-&gt;drawMoveWithAdjustment(e-&gt;pos());\n        } else {\n            m_activeTool-&gt;drawMove(m_displayGrid ? snapToGrid(e-&gt;pos())\n                                                 : e-&gt;pos());\n        }\n        // update drawing object\n        updateTool(m_activeTool);\n        // Hides the buttons under the mouse. If the mouse leaves, it shows\n        // them.\n        if (m_buttonHandler-&gt;buttonsAreInside()) {\n            const bool containsMouse =\n              m_buttonHandler-&gt;contains(m_context.mousePos);\n            if (containsMouse) {\n                m_buttonHandler-&gt;hide();\n            } else if (m_selection-&gt;isVisible()) {\n                m_buttonHandler-&gt;show();\n            }\n        }\n    }\n    updateCursor();\n}\n\nvoid CaptureWidget::mouseReleaseEvent(QMouseEvent* e)\n{\n    if (e-&gt;button() == Qt::LeftButton &amp;&amp; m_colorPicker-&gt;isVisible()) {\n        // Color picker\n        if (m_colorPicker-&gt;isVisible() &amp;&amp; m_panel-&gt;activeLayerIndex() &gt;= 0 &amp;&amp;\n            m_context.color.isValid()) {\n            pushObjectsStateToUndoStack();\n        }\n        m_colorPicker-&gt;hide();\n        if (!m_context.color.isValid()) {\n            m_context.color = ConfigHandler().drawColor();\n            m_panel-&gt;show();\n        }\n    } else if (m_mouseIsClicked) {\n        if (m_activeTool) {\n            // end draw/edit\n            m_activeTool-&gt;drawEnd(m_context.mousePos);\n            if (m_activeTool-&gt;isValid()) {\n                pushToolToStack();\n            } else if (!m_toolWidget) {\n                releaseActiveTool();\n            }\n        } else {\n            if (m_activeToolIsMoved) {\n                m_activeToolIsMoved = false;\n                pushObjectsStateToUndoStack();\n            }\n        }\n    }\n    m_mouseIsClicked = false;\n    m_activeToolIsMoved = false;\n\n    updateSelectionState();\n    updateCursor();\n}\n\nvoid CaptureWidget::setToolSize(int size)\n{\n    int oldSize = m_context.toolSize;\n    m_context.toolSize = qBound(1, size, maxToolSize);\n    updateTool(activeButtonTool());\n\n    QPoint topLeft =\n      QGuiAppCurrentScreen().currentScreen()-&gt;geometry().topLeft();\n    int offset = m_notifierBox-&gt;width() / 4;\n    m_notifierBox-&gt;move(mapFromGlobal(topLeft) + QPoint(offset, offset));\n    m_notifierBox-&gt;showMessage(QString::number(m_context.toolSize));\n\n    if (m_context.toolSize != oldSize) {\n        emit toolSizeChanged(m_context.toolSize);\n    }\n}\n\nvoid CaptureWidget::keyPressEvent(QKeyEvent* e)\n{\n    // If the key is a digit, change the tool size\n    bool ok;\n    int digit = e-&gt;text().toInt(&amp;ok);\n    if (ok &amp;&amp; ((e-&gt;modifiers() == Qt::NoModifier) ||\n               e-&gt;modifiers() == Qt::KeypadModifier)) { // digit received\n        m_toolSizeByKeyboard = 10 * m_toolSizeByKeyboard + digit;\n        setToolSize(m_toolSizeByKeyboard);\n        if (m_context.toolSize != m_toolSizeByKeyboard) {\n            // The tool size was out of range and was clipped by setToolSize\n            m_toolSizeByKeyboard = 0;\n        }\n    } else {\n        m_toolSizeByKeyboard = 0;\n    }\n\n    if (!m_selection-&gt;isVisible()) {\n        return;\n    } else if (e-&gt;key() == Qt::Key_Control) {\n        m_adjustmentButtonPressed = true;\n        updateCursor();\n    } else if (e-&gt;key() == Qt::Key_Enter) {\n        // Make no difference for Return and Enter keys\n        QCoreApplication::postEvent(\n          this,\n          new QKeyEvent(QEvent::KeyPress, Qt::Key_Return, Qt::NoModifier));\n    }\n}\n\nvoid CaptureWidget::keyReleaseEvent(QKeyEvent* e)\n{\n    if (e-&gt;key() == Qt::Key_Control) {\n        m_adjustmentButtonPressed = false;\n        updateCursor();\n    }\n}\n\nvoid CaptureWidget::wheelEvent(QWheelEvent* e)\n{\n    /* Mouse scroll usually gives value 120, not more or less, just how many\n     * times.\n     * Touchpad gives the value 2 or more (usually 2-8), it doesn't give\n     * too big values like mouse wheel on normal scrolling, so it is almost\n     * impossible to scroll. It's easier to calculate number of requests and do\n     * not accept events faster that one in 200ms.\n     * */\n    int toolSizeOffset = 0;\n    if (e-&gt;angleDelta().y() &gt;= 60) {\n        // mouse scroll (wheel) increment\n        toolSizeOffset = 1;\n    } else if (e-&gt;angleDelta().y() &lt;= -60) {\n        // mouse scroll (wheel) decrement\n        toolSizeOffset = -1;\n    } else {\n        // touchpad scroll\n        qint64 current = QDateTime::currentMSecsSinceEpoch();\n        if ((current - m_lastMouseWheel) &gt; 200) {\n            if (e-&gt;angleDelta().y() &gt; 0) {\n                toolSizeOffset = 1;\n            } else if (e-&gt;angleDelta().y() &lt; 0) {\n                toolSizeOffset = -1;\n            }\n            m_lastMouseWheel = current;\n        } else {\n            return;\n        }\n    }\n\n    setToolSize(m_context.toolSize + toolSizeOffset);\n}\n\nvoid CaptureWidget::resizeEvent(QResizeEvent* e)\n{\n    QWidget::resizeEvent(e);\n    m_context.widgetOffset = mapToGlobal(QPoint(0, 0));\n    if (!m_context.fullscreen) {\n        m_panel-&gt;setFixedHeight(height());\n        m_buttonHandler-&gt;updateScreenRegions(rect());\n    }\n}\n\nvoid CaptureWidget::moveEvent(QMoveEvent* e)\n{\n    QWidget::moveEvent(e);\n    m_context.widgetOffset = mapToGlobal(QPoint(0, 0));\n}\n\nvoid CaptureWidget::changeEvent(QEvent* e)\n{\n    if (e-&gt;type() == QEvent::ActivationChange) {\n        QPoint bottomRight = rect().bottomRight();\n        // Update the message in the bottom right corner. A rough estimate is\n        // used for the update rect\n        update(QRect(bottomRight - QPoint(1000, 200), bottomRight));\n    }\n}\n\nvoid CaptureWidget::initContext(bool fullscreen, const CaptureRequest&amp; req)\n{\n    m_context.color = m_config.drawColor();\n    m_context.widgetOffset = mapToGlobal(QPoint(0, 0));\n    m_context.mousePos = mapFromGlobal(QCursor::pos());\n    m_context.toolSize = m_config.drawThickness();\n    m_context.fullscreen = fullscreen;\n\n    // initialize m_context.request\n    m_context.request = req;\n}\n\nvoid CaptureWidget::initPanel()\n{\n    QRect panelRect = rect();\n    if (m_context.fullscreen) {\n#if (defined(Q_OS_MACOS) || defined(Q_OS_LINUX))\n        QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n        panelRect = currentScreen-&gt;geometry();\n        auto devicePixelRatio = currentScreen-&gt;devicePixelRatio();\n        panelRect.moveTo(static_cast&lt;int&gt;(panelRect.x() / devicePixelRatio),\n                         static_cast&lt;int&gt;(panelRect.y() / devicePixelRatio));\n#else\n        panelRect = QGuiApplication::primaryScreen()-&gt;geometry();\n        auto devicePixelRatio =\n          QGuiApplication::primaryScreen()-&gt;devicePixelRatio();\n        panelRect.moveTo(panelRect.x() / devicePixelRatio,\n                         panelRect.y() / devicePixelRatio);\n#endif\n    }\n\n    if (ConfigHandler().showSidePanelButton()) {\n        auto* panelToggleButton =\n          new OrientablePushButton(tr(\"Tool Settings\"), this);\n        makeChild(panelToggleButton);\n        panelToggleButton-&gt;setColor(m_uiColor);\n        panelToggleButton-&gt;setOrientation(\n          OrientablePushButton::VerticalBottomToTop);\n#if defined(Q_OS_MACOS)\n        panelToggleButton-&gt;move(\n          0,\n          static_cast&lt;int&gt;(panelRect.height() / 2) -\n            static_cast&lt;int&gt;(panelToggleButton-&gt;width() / 2));\n#else\n        panelToggleButton-&gt;move(panelRect.x(),\n                                panelRect.y() + panelRect.height() / 2 -\n                                  panelToggleButton-&gt;width() / 2);\n#endif\n        panelToggleButton-&gt;setCursor(Qt::ArrowCursor);\n        (new DraggableWidgetMaker(this))-&gt;makeDraggable(panelToggleButton);\n        connect(panelToggleButton,\n                &amp;QPushButton::clicked,\n                this,\n                &amp;CaptureWidget::togglePanel);\n    }\n\n    m_panel = new UtilityPanel(this);\n    m_panel-&gt;hide();\n    makeChild(m_panel);\n#if defined(Q_OS_MACOS)\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    panelRect.moveTo(mapFromGlobal(panelRect.topLeft()));\n    m_panel-&gt;setFixedWidth(static_cast&lt;int&gt;(m_colorPicker-&gt;width() * 1.5));\n    m_panel-&gt;setFixedHeight(currentScreen-&gt;geometry().height());\n#else\n    panelRect.moveTo(mapFromGlobal(panelRect.topLeft()));\n    panelRect.setWidth(m_colorPicker-&gt;width() * 1.5);\n    m_panel-&gt;setGeometry(panelRect);\n#endif\n    connect(m_panel,\n            &amp;UtilityPanel::layerChanged,\n            this,\n            &amp;CaptureWidget::updateActiveLayer);\n    connect(m_panel,\n            &amp;UtilityPanel::moveUpClicked,\n            this,\n            &amp;CaptureWidget::onMoveCaptureToolUp);\n    connect(m_panel,\n            &amp;UtilityPanel::moveDownClicked,\n            this,\n            &amp;CaptureWidget::onMoveCaptureToolDown);\n\n    m_sidePanel = new SidePanelWidget(&amp;m_context.screenshot, this);\n    connect(m_sidePanel,\n            &amp;SidePanelWidget::colorChanged,\n            this,\n            &amp;CaptureWidget::setDrawColor);\n    connect(m_sidePanel,\n            &amp;SidePanelWidget::toolSizeChanged,\n            this,\n            &amp;CaptureWidget::onToolSizeChanged);\n    connect(this,\n            &amp;CaptureWidget::colorChanged,\n            m_sidePanel,\n            &amp;SidePanelWidget::onColorChanged);\n    connect(this,\n            &amp;CaptureWidget::toolSizeChanged,\n            m_sidePanel,\n            &amp;SidePanelWidget::onToolSizeChanged);\n    connect(m_sidePanel,\n            &amp;SidePanelWidget::togglePanel,\n            m_panel,\n            &amp;UtilityPanel::toggle);\n    connect(m_sidePanel,\n            &amp;SidePanelWidget::displayGridChanged,\n            this,\n            &amp;CaptureWidget::onDisplayGridChanged);\n    connect(m_sidePanel,\n            &amp;SidePanelWidget::gridSizeChanged,\n            this,\n            &amp;CaptureWidget::onGridSizeChanged);\n    // TODO replace with a CaptureWidget signal\n    emit m_sidePanel-&gt;colorChanged(m_context.color);\n    emit toolSizeChanged(m_context.toolSize);\n    m_panel-&gt;pushWidget(m_sidePanel);\n\n    // Fill undo/redo/history list widget\n    m_panel-&gt;fillCaptureTools(m_captureToolObjects.captureToolObjects());\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nvoid CaptureWidget::showAppUpdateNotification(const QString&amp; appLatestVersion,\n                                              const QString&amp; appLatestUrl)\n{\n    if (!ConfigHandler().checkForUpdates()) {\n        // option check for updates disabled\n        return;\n    }\n    if (nullptr == m_updateNotificationWidget) {\n        m_updateNotificationWidget =\n          new UpdateNotificationWidget(this, appLatestVersion, appLatestUrl);\n    }\n#if defined(Q_OS_MACOS)\n    int ax = (width() - m_updateNotificationWidget-&gt;width()) / 2;\n#elif (defined(Q_OS_LINUX) &amp;&amp; QT_VERSION &lt; QT_VERSION_CHECK(5, 10, 0))\n    QRect helpRect = QGuiApplication::primaryScreen()-&gt;geometry();\n    int ax = helpRect.left() +\n             ((helpRect.width() - m_updateNotificationWidget-&gt;width()) / 2);\n#else\n    QRect helpRect;\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    if (currentScreen) {\n        helpRect = currentScreen-&gt;geometry();\n    } else {\n        helpRect = QGuiApplication::primaryScreen()-&gt;geometry();\n    }\n    int ax = helpRect.left() +\n             ((helpRect.width() - m_updateNotificationWidget-&gt;width()) / 2);\n#endif\n    m_updateNotificationWidget-&gt;move(ax, 0);\n    makeChild(m_updateNotificationWidget);\n    m_updateNotificationWidget-&gt;show();\n}\n#endif\n\nvoid CaptureWidget::initSelection()\n{\n    // Be mindful of the order of statements, so that slots are called properly\n    m_selection = new SelectionWidget(m_uiColor, this);\n    QRect initialSelection = m_context.request.initialSelection();\n    connect(m_selection, &amp;SelectionWidget::geometryChanged, this, [this]() {\n        QRect constrainedToCaptureArea =\n          m_selection-&gt;geometry().intersected(rect());\n        m_context.selection = extendedRect(constrainedToCaptureArea);\n\n        m_buttonHandler-&gt;hide();\n        updateCursor();\n        updateSizeIndicator();\n        OverlayMessage::pop();\n    });\n    connect(m_selection, &amp;SelectionWidget::geometrySettled, this, [this]() {\n        if (m_selection-&gt;isVisibleTo(this)) {\n            auto&amp; req = m_context.request;\n            if (req.tasks() &amp; CaptureRequest::ACCEPT_ON_SELECT) {\n                req.removeTask(CaptureRequest::ACCEPT_ON_SELECT);\n                m_captureDone = true;\n                close();\n            }\n            m_buttonHandler-&gt;updatePosition(m_selection-&gt;geometry());\n            m_buttonHandler-&gt;show();\n        } else {\n            m_buttonHandler-&gt;hide();\n        }\n    });\n    connect(m_selection, &amp;SelectionWidget::visibilityChanged, this, [this]() {\n        if (!m_selection-&gt;isVisible() &amp;&amp; !m_helpMessage.isEmpty()) {\n            OverlayMessage::push(m_helpMessage);\n        }\n    });\n    if (!initialSelection.isNull()) {\n        const qreal scale = m_context.screenshot.devicePixelRatio();\n        initialSelection.moveTopLeft(initialSelection.topLeft() -\n                                     mapToGlobal({}));\n        initialSelection.setTop(initialSelection.top() / scale);\n        initialSelection.setBottom(initialSelection.bottom() / scale);\n        initialSelection.setLeft(initialSelection.left() / scale);\n        initialSelection.setRight(initialSelection.right() / scale);\n    }\n    m_selection-&gt;setGeometry(initialSelection);\n    m_selection-&gt;setVisible(!initialSelection.isNull());\n    if (!initialSelection.isNull()) {\n        m_context.selection = extendedRect(m_selection-&gt;geometry());\n        emit m_selection-&gt;geometrySettled();\n    }\n}\n\nvoid CaptureWidget::setState(CaptureToolButton* b)\n{\n    if (!b) {\n        return;\n    }\n\n    commitCurrentTool();\n    if (m_toolWidget &amp;&amp; m_activeTool) {\n        if (m_activeTool-&gt;isValid()) {\n            pushToolToStack();\n        } else {\n            releaseActiveTool();\n        }\n    }\n    if (m_activeButton != b) {\n        auto backup = m_activeTool;\n        // The tool is active during the pressed().\n        // This must be done in order to handle tool requests correctly.\n        m_activeTool = b-&gt;tool();\n        m_activeTool-&gt;pressed(m_context);\n        m_activeTool = backup;\n    }\n\n    if (b-&gt;tool()-&gt;isSelectable()) {\n        if (m_activeButton != b) {\n            if (m_activeButton) {\n                m_activeButton-&gt;setColor(m_uiColor);\n            }\n            m_activeButton = b;\n            m_activeButton-&gt;setColor(m_contrastUiColor);\n            m_panel-&gt;setActiveLayer(-1);\n            m_panel-&gt;setToolWidget(b-&gt;tool()-&gt;configurationWidget());\n        } else if (m_activeButton) {\n            m_panel-&gt;clearToolWidget();\n            m_activeButton-&gt;setColor(m_uiColor);\n            m_activeButton = nullptr;\n        }\n        m_context.toolSize = ConfigHandler().toolSize(activeButtonToolType());\n        emit toolSizeChanged(m_context.toolSize);\n        updateCursor();\n        updateSelectionState();\n        updateTool(b-&gt;tool());\n    }\n}\n\nvoid CaptureWidget::handleToolSignal(CaptureTool::Request r)\n{\n    switch (r) {\n        case CaptureTool::REQ_CLOSE_GUI:\n            close();\n            break;\n        case CaptureTool::REQ_HIDE_GUI:\n            hide();\n            break;\n        case CaptureTool::REQ_UNDO_MODIFICATION:\n            undo();\n            break;\n        case CaptureTool::REQ_REDO_MODIFICATION:\n            redo();\n            break;\n        case CaptureTool::REQ_SHOW_COLOR_PICKER:\n            // TODO\n            break;\n        case CaptureTool::REQ_CAPTURE_DONE_OK:\n            m_captureDone = true;\n            break;\n        case CaptureTool::REQ_CLEAR_SELECTION:\n            if (m_panel-&gt;activeLayerIndex() &gt;= 0) {\n                m_panel-&gt;setActiveLayer(-1);\n                drawToolsData(false);\n            }\n            break;\n        case CaptureTool::REQ_ADD_CHILD_WIDGET:\n            if (!m_activeTool) {\n                break;\n            }\n            if (m_toolWidget) {\n                m_toolWidget-&gt;hide();\n                delete m_toolWidget;\n                m_toolWidget = nullptr;\n            }\n            m_toolWidget = m_activeTool-&gt;widget();\n            if (m_toolWidget) {\n                makeChild(m_toolWidget);\n                m_toolWidget-&gt;move(m_context.mousePos);\n                m_toolWidget-&gt;show();\n                m_toolWidget-&gt;setFocus();\n            }\n            break;\n        case CaptureTool::REQ_ADD_EXTERNAL_WIDGETS:\n            if (!m_activeTool) {\n                break;\n            } else {\n                QWidget* w = m_activeTool-&gt;widget();\n                w-&gt;setAttribute(Qt::WA_DeleteOnClose);\n                w-&gt;activateWindow();\n                w-&gt;show();\n                Flameshot::instance()-&gt;setExternalWidget(true);\n            }\n            break;\n        case CaptureTool::REQ_INCREASE_TOOL_SIZE:\n            setToolSize(m_context.toolSize + 1);\n            break;\n        case CaptureTool::REQ_DECREASE_TOOL_SIZE:\n            setToolSize(m_context.toolSize - 1);\n            break;\n        default:\n            break;\n    }\n}\n\nvoid CaptureWidget::onToolSizeChanged(int t)\n{\n\n    m_context.toolSize = t;\n    CaptureTool* tool = activeButtonTool();\n    if (tool &amp;&amp; tool-&gt;showMousePreview()) {\n        setCursor(Qt::BlankCursor);\n        tool-&gt;onSizeChanged(t);\n    }\n\n    // update tool size of object being drawn\n    if (m_activeTool != nullptr) {\n        updateTool(m_activeTool);\n    }\n\n    // update tool size of selected object\n    auto toolItem = activeToolObject();\n    if (toolItem) {\n        // Change thickness\n        toolItem-&gt;onSizeChanged(t);\n        if (!m_existingObjectIsChanged) {\n            m_captureToolObjectsBackup = m_captureToolObjects;\n            m_existingObjectIsChanged = true;\n        }\n        drawToolsData();\n        updateTool(toolItem);\n    }\n\n    // Force a repaint to prevent artifacting\n    this-&gt;repaint();\n}\n\nvoid CaptureWidget::onToolSizeSettled(int size)\n{\n    m_config.setToolSize(activeButtonToolType(), size);\n}\n\nvoid CaptureWidget::setDrawColor(const QColor&amp; c)\n{\n    m_context.color = c;\n    if (m_context.color.isValid()) {\n        ConfigHandler().setDrawColor(m_context.color);\n        emit colorChanged(c);\n        // Update mouse preview\n        updateTool(activeButtonTool());\n\n        // change color for the active tool\n        auto toolItem = activeToolObject();\n        if (toolItem) {\n            // Change color\n            toolItem-&gt;onColorChanged(c);\n            drawToolsData();\n        }\n    }\n}\n\nvoid CaptureWidget::updateActiveLayer(int layer)\n{\n    // TODO - refactor this part, make all objects to work with\n    // m_activeTool-&gt;isChanged() and remove m_existingObjectIsChanged\n    if (m_activeTool &amp;&amp; m_activeTool-&gt;type() == CaptureTool::TYPE_TEXT &amp;&amp;\n        m_activeTool-&gt;isChanged()) {\n        commitCurrentTool();\n    }\n\n    if (m_toolWidget) {\n        // Release active tool if it is in the editing mode but not changed and\n        // has editing widget (ex: text tool)\n        releaseActiveTool();\n    }\n\n    if (m_existingObjectIsChanged) {\n        m_existingObjectIsChanged = false;\n        pushObjectsStateToUndoStack();\n    }\n    drawToolsData();\n    drawObjectSelection();\n    updateSelectionState();\n}\n\nvoid CaptureWidget::onMoveCaptureToolUp(int captureToolIndex)\n{\n    m_captureToolObjectsBackup = m_captureToolObjects;\n    pushObjectsStateToUndoStack();\n    auto tool = m_captureToolObjects.at(captureToolIndex);\n    m_captureToolObjects.removeAt(captureToolIndex);\n    m_captureToolObjects.insert(captureToolIndex - 1, tool);\n    updateLayersPanel();\n}\n\nvoid CaptureWidget::onMoveCaptureToolDown(int captureToolIndex)\n{\n    m_captureToolObjectsBackup = m_captureToolObjects;\n    pushObjectsStateToUndoStack();\n    auto tool = m_captureToolObjects.at(captureToolIndex);\n    m_captureToolObjects.removeAt(captureToolIndex);\n    m_captureToolObjects.insert(captureToolIndex + 1, tool);\n    updateLayersPanel();\n}\n\nvoid CaptureWidget::selectAll()\n{\n    m_selection-&gt;show();\n    m_selection-&gt;setGeometry(rect());\n    emit m_selection-&gt;geometrySettled();\n    m_buttonHandler-&gt;show();\n    updateSelectionState();\n}\n\nvoid CaptureWidget::removeToolObject(int index)\n{\n    --index;\n    if (index &gt;= 0 &amp;&amp; index &lt; m_captureToolObjects.size()) {\n        // in case this tool is circle counter\n        const CaptureTool::Type currentToolType =\n          m_captureToolObjects.at(index)-&gt;type();\n        m_captureToolObjectsBackup = m_captureToolObjects;\n        update(\n          paddedUpdateRect(m_captureToolObjects.at(index)-&gt;boundingRect()));\n        if (currentToolType == CaptureTool::TYPE_CIRCLECOUNT) {\n            int removedCircleCount = m_captureToolObjects.at(index)-&gt;count();\n            --m_context.circleCount;\n            // Decrement circle counter numbers starting from deleted circle\n            for (int cnt = 0; cnt &lt; m_captureToolObjects.size(); cnt++) {\n                auto toolItem = m_captureToolObjects.at(cnt);\n                if (toolItem-&gt;type() != CaptureTool::TYPE_CIRCLECOUNT) {\n                    continue;\n                }\n                auto circleTool = m_captureToolObjects.at(cnt);\n                if (circleTool-&gt;count() &gt;= removedCircleCount) {\n                    circleTool-&gt;setCount(circleTool-&gt;count() - 1);\n                }\n            }\n        }\n        m_captureToolObjects.removeAt(index);\n        pushObjectsStateToUndoStack();\n        drawToolsData();\n        updateLayersPanel();\n    }\n}\n\nvoid CaptureWidget::initShortcuts()\n{\n    newShortcut(\n      QKeySequence(ConfigHandler().shortcut(\"TYPE_UNDO\")), this, SLOT(undo()));\n\n    newShortcut(\n      QKeySequence(ConfigHandler().shortcut(\"TYPE_REDO\")), this, SLOT(redo()));\n\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_TOGGLE_PANEL\")),\n                this,\n                SLOT(togglePanel()));\n\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_LEFT\")),\n                m_selection,\n                SLOT(resizeLeft()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_RIGHT\")),\n                m_selection,\n                SLOT(resizeRight()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_UP\")),\n                m_selection,\n                SLOT(resizeUp()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_RESIZE_DOWN\")),\n                m_selection,\n                SLOT(resizeDown()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_LEFT\")),\n                m_selection,\n                SLOT(symResizeLeft()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_RIGHT\")),\n                m_selection,\n                SLOT(symResizeRight()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_UP\")),\n                m_selection,\n                SLOT(symResizeUp()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SYM_RESIZE_DOWN\")),\n                m_selection,\n                SLOT(symResizeDown()));\n\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_LEFT\")),\n                m_selection,\n                SLOT(moveLeft()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_RIGHT\")),\n                m_selection,\n                SLOT(moveRight()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_UP\")),\n                m_selection,\n                SLOT(moveUp()));\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_MOVE_DOWN\")),\n                m_selection,\n                SLOT(moveDown()));\n\n    newShortcut(\n      QKeySequence(ConfigHandler().shortcut(\"TYPE_DELETE_CURRENT_TOOL\")),\n      this,\n      SLOT(deleteCurrentTool()));\n\n    newShortcut(\n      QKeySequence(ConfigHandler().shortcut(\"TYPE_COMMIT_CURRENT_TOOL\")),\n      this,\n      SLOT(commitCurrentTool()));\n\n    newShortcut(QKeySequence(ConfigHandler().shortcut(\"TYPE_SELECT_ALL\")),\n                this,\n                SLOT(selectAll()));\n\n    newShortcut(Qt::Key_Escape, this, SLOT(deleteToolWidgetOrClose()));\n}\n\nvoid CaptureWidget::deleteCurrentTool()\n{\n    int oldToolSize = m_context.toolSize;\n    m_panel-&gt;slotButtonDelete(true);\n    drawObjectSelection();\n    if (oldToolSize != m_context.toolSize) {\n        emit toolSizeChanged(m_context.toolSize);\n    }\n}\n\nvoid CaptureWidget::updateSizeIndicator()\n{\n    if (m_config.showSelectionGeometry()) {\n        showxywh();\n    }\n    if (m_sizeIndButton) {\n        const QRect&amp; selection = extendedSelection();\n        m_sizeIndButton-&gt;setText(QStringLiteral(\"%1\\n%2\")\n                                   .arg(selection.width())\n                                   .arg(selection.height()));\n    }\n}\n\nvoid CaptureWidget::updateCursor()\n{\n    if (m_colorPicker &amp;&amp; m_colorPicker-&gt;isVisible()) {\n        setCursor(Qt::ArrowCursor);\n    } else if (m_activeButton != nullptr &amp;&amp;\n               activeButtonToolType() != CaptureTool::TYPE_MOVESELECTION) {\n        setCursor(Qt::CrossCursor);\n    } else if (m_selection-&gt;getMouseSide(mapFromGlobal(QCursor::pos())) !=\n               SelectionWidget::NO_SIDE) {\n        setCursor(m_selection-&gt;cursor());\n    } else if (activeButtonToolType() == CaptureTool::TYPE_MOVESELECTION) {\n        setCursor(Qt::OpenHandCursor);\n    } else {\n        setCursor(Qt::CrossCursor);\n    }\n}\n\nvoid CaptureWidget::updateSelectionState()\n{\n    auto toolType = activeButtonToolType();\n    if (toolType == CaptureTool::TYPE_MOVESELECTION) {\n        m_selection-&gt;setIdleCentralCursor(Qt::OpenHandCursor);\n        m_selection-&gt;setIgnoreMouse(false);\n    } else {\n        m_selection-&gt;setIdleCentralCursor(Qt::ArrowCursor);\n        if (toolType == CaptureTool::NONE) {\n            m_selection-&gt;setIgnoreMouse(m_panel-&gt;activeLayerIndex() != -1);\n        } else {\n            m_selection-&gt;setIgnoreMouse(true);\n        }\n    }\n}\n\nvoid CaptureWidget::updateTool(CaptureTool* tool)\n{\n    if (!tool || !tool-&gt;showMousePreview()) {\n        return;\n    }\n\n    static QRect oldPreviewRect, oldToolObjectRect;\n\n    QRect previewRect(tool-&gt;mousePreviewRect(m_context));\n    previewRect += QMargins(previewRect.width(),\n                            previewRect.height(),\n                            previewRect.width(),\n                            previewRect.height());\n\n    QRect toolObjectRect = paddedUpdateRect(tool-&gt;boundingRect());\n\n    // old rects are united with current rects to handle sudden mouse movement\n    update(previewRect);\n    update(toolObjectRect);\n    update(oldPreviewRect);\n    update(oldToolObjectRect);\n\n    oldPreviewRect = previewRect;\n    oldToolObjectRect = toolObjectRect;\n}\n\nvoid CaptureWidget::updateLayersPanel()\n{\n    m_panel-&gt;fillCaptureTools(m_captureToolObjects.captureToolObjects());\n}\n\nvoid CaptureWidget::pushToolToStack()\n{\n    // append current tool to the new state\n    if (m_activeTool &amp;&amp; m_activeButton) {\n        disconnect(this,\n                   &amp;CaptureWidget::colorChanged,\n                   m_activeTool,\n                   &amp;CaptureTool::onColorChanged);\n        disconnect(this,\n                   &amp;CaptureWidget::toolSizeChanged,\n                   m_activeTool,\n                   &amp;CaptureTool::onSizeChanged);\n        if (m_panel-&gt;toolWidget()) {\n            disconnect(m_panel-&gt;toolWidget(), nullptr, m_activeTool, nullptr);\n        }\n\n        // disable signal connect for updating layer because it may call this\n        // function again on text objects\n        m_panel-&gt;blockSignals(true);\n\n        m_captureToolObjectsBackup = m_captureToolObjects;\n        m_captureToolObjects.append(m_activeTool);\n        pushObjectsStateToUndoStack();\n        releaseActiveTool();\n        drawToolsData();\n        updateLayersPanel();\n\n        // restore signal connection for updating layer\n        m_panel-&gt;blockSignals(false);\n    }\n}\n\nvoid CaptureWidget::drawToolsData(bool drawSelection)\n{\n    // TODO refactor this for performance. The objects should not all be updated\n    // at once every time\n    QPixmap pixmapItem = m_context.origScreenshot;\n    for (auto toolItem : m_captureToolObjects.captureToolObjects()) {\n        processPixmapWithTool(&amp;pixmapItem, toolItem);\n        update(paddedUpdateRect(toolItem-&gt;boundingRect()));\n    }\n\n    m_context.screenshot = pixmapItem;\n    if (drawSelection) {\n        drawObjectSelection();\n    }\n}\n\nvoid CaptureWidget::drawObjectSelection()\n{\n    auto toolItem = activeToolObject();\n    if (toolItem &amp;&amp; !toolItem-&gt;editMode()) {\n        QPainter painter(&amp;m_context.screenshot);\n        toolItem-&gt;drawObjectSelection(painter);\n        // TODO move this elsewhere\n        if (m_context.toolSize != toolItem-&gt;size()) {\n            m_context.toolSize = toolItem-&gt;size();\n        }\n        if (activeToolObject() &amp;&amp; m_activeButton) {\n            uncheckActiveTool();\n        }\n    }\n}\n\nvoid CaptureWidget::processPixmapWithTool(QPixmap* pixmap, CaptureTool* tool)\n{\n    QPainter painter(pixmap);\n    painter.setRenderHint(QPainter::Antialiasing);\n    tool-&gt;process(painter, *pixmap);\n}\n\nCaptureTool* CaptureWidget::activeButtonTool() const\n{\n    if (m_activeButton == nullptr) {\n        return nullptr;\n    }\n    return m_activeButton-&gt;tool();\n}\n\nCaptureTool::Type CaptureWidget::activeButtonToolType() const\n{\n    auto* activeTool = activeButtonTool();\n    if (activeTool == nullptr) {\n        return CaptureTool::NONE;\n    }\n    return activeTool-&gt;type();\n}\n\nQPoint CaptureWidget::snapToGrid(const QPoint&amp; point) const\n{\n    QPoint snapPoint = mapToGlobal(point);\n\n    const auto scale{ m_context.screenshot.devicePixelRatio() };\n\n    snapPoint.setX((qRound(snapPoint.x() / double(m_gridSize)) * m_gridSize) *\n                   scale);\n    snapPoint.setY((qRound(snapPoint.y() / double(m_gridSize)) * m_gridSize) *\n                   scale);\n\n    return mapFromGlobal(snapPoint);\n}\n\nQPointer&lt;CaptureTool&gt; CaptureWidget::activeToolObject()\n{\n    return m_captureToolObjects.at(m_panel-&gt;activeLayerIndex());\n}\n\nvoid CaptureWidget::makeChild(QWidget* w)\n{\n    w-&gt;setParent(this);\n    w-&gt;installEventFilter(m_eventFilter);\n}\n\nvoid CaptureWidget::restoreCircleCountState()\n{\n    int largest = 0;\n    for (int cnt = 0; cnt &lt; m_captureToolObjects.size(); cnt++) {\n        auto toolItem = m_captureToolObjects.at(cnt);\n        if (toolItem-&gt;type() != CaptureTool::TYPE_CIRCLECOUNT) {\n            continue;\n        }\n        if (toolItem-&gt;count() &gt; largest) {\n            largest = toolItem-&gt;count();\n        }\n    }\n    m_context.circleCount = largest + 1;\n}\n\nQList&lt;QShortcut*&gt; CaptureWidget::newShortcut(const QKeySequence&amp; key,\n                                             QWidget* parent,\n                                             const char* slot)\n{\n    QList&lt;QShortcut*&gt; shortcuts;\n    QString strKey = key.toString();\n    if (strKey.contains(\"Enter\") || strKey.contains(\"Return\")) {\n        strKey.replace(\"Enter\", \"Return\");\n        shortcuts &lt;&lt; new QShortcut(strKey, parent, slot);\n        strKey.replace(\"Return\", \"Enter\");\n        shortcuts &lt;&lt; new QShortcut(strKey, parent, slot);\n    } else {\n        shortcuts &lt;&lt; new QShortcut(key, parent, slot);\n    }\n    return shortcuts;\n}\n\nvoid CaptureWidget::togglePanel()\n{\n    m_panel-&gt;toggle();\n}\n\nvoid CaptureWidget::childEnter()\n{\n    m_previewEnabled = false;\n    updateTool(activeButtonTool());\n}\n\nvoid CaptureWidget::childLeave()\n{\n    m_previewEnabled = true;\n    updateTool(activeButtonTool());\n}\n\nvoid CaptureWidget::setCaptureToolObjects(\n  const CaptureToolObjects&amp; captureToolObjects)\n{\n    // Used for undo/redo\n    m_captureToolObjects = captureToolObjects;\n    drawToolsData();\n    updateLayersPanel();\n    drawObjectSelection();\n}\n\nvoid CaptureWidget::undo()\n{\n    if (m_activeTool &amp;&amp;\n        (m_activeTool-&gt;isChanged() || m_activeTool-&gt;editMode())) {\n        // Remove selection on undo, at the same time commit current tool will\n        // be called\n        m_panel-&gt;setActiveLayer(-1);\n    }\n\n    // drawToolsData is called twice to update both previous and new regions\n    // FIXME this is a temporary workaround\n    drawToolsData();\n    m_undoStack.undo();\n    drawToolsData();\n    updateLayersPanel();\n\n    restoreCircleCountState();\n}\n\nvoid CaptureWidget::redo()\n{\n    // drawToolsData is called twice to update both previous and new regions\n    // FIXME this is a temporary workaround\n    drawToolsData();\n    m_undoStack.redo();\n    drawToolsData();\n    update();\n    updateLayersPanel();\n\n    restoreCircleCountState();\n}\n\nQRect CaptureWidget::extendedSelection() const\n{\n    if (m_selection == nullptr) {\n        return {};\n    }\n    QRect r = m_selection-&gt;geometry();\n    return extendedRect(r);\n}\n\nQRect CaptureWidget::extendedRect(const QRect&amp; r) const\n{\n    auto devicePixelRatio = m_context.screenshot.devicePixelRatio();\n    return { static_cast&lt;int&gt;(r.left() * devicePixelRatio),\n             static_cast&lt;int&gt;(r.top() * devicePixelRatio),\n             static_cast&lt;int&gt;(r.width() * devicePixelRatio),\n             static_cast&lt;int&gt;(r.height() * devicePixelRatio) };\n}\n\nQRect CaptureWidget::paddedUpdateRect(const QRect&amp; r) const\n{\n    if (r.isNull()) {\n        return r;\n    } else {\n        return r + QMargins(20, 20, 20, 20);\n    }\n}\n\nvoid CaptureWidget::drawErrorMessage(const QString&amp; msg, QPainter* painter)\n{\n    auto textRect = painter-&gt;fontMetrics().boundingRect(msg);\n    int w = textRect.width(), h = textRect.height();\n    textRect = {\n        size().width() - w - 10, size().height() - h - 5, w + 100, h + 100\n    };\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n\n    if (!textRect.contains(QCursor::pos(currentScreen))) {\n        QColor textColor(Qt::white);\n        painter-&gt;setPen(textColor);\n        painter-&gt;drawText(textRect, msg);\n    }\n}\n\nvoid CaptureWidget::drawInactiveRegion(QPainter* painter)\n{\n    QColor overlayColor(0, 0, 0, m_opacity);\n    painter-&gt;setBrush(overlayColor);\n    QRect r;\n    if (m_selection-&gt;isVisible()) {\n        r = m_selection-&gt;geometry().normalized();\n    }\n    QRegion grey(rect());\n    grey = grey.subtracted(r);\n\n    painter-&gt;setClipRegion(grey);\n    painter-&gt;drawRect(-1, -1, rect().width() + 1, rect().height() + 1);\n}\n\n</code></pre>"},{"location":"flameshot/capturewidget_8h/","title":"File capturewidget.h","text":"<p>FileList &gt; capture &gt; capturewidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"buttonhandler.h\"</code></li> <li><code>#include \"capturetoolbutton.h\"</code></li> <li><code>#include \"capturetoolobjects.h\"</code></li> <li><code>#include \"src/config/generalconf.h\"</code></li> <li><code>#include \"src/tools/capturecontext.h\"</code></li> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/widgets/capture/magnifierwidget.h\"</code></li> <li><code>#include \"src/widgets/capture/selectionwidget.h\"</code></li> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QUndoStack&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/capturewidget_8h/#classes","title":"Classes","text":"Type Name class CaptureWidget"},{"location":"flameshot/capturewidget_8h_source/","title":"File capturewidget.h","text":"<p>File List &gt; capture &gt; capturewidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// Based on Lightscreen areadialog.h, Copyright 2017  Christian Kaiser\n// &lt;info@ckaiser.com.ar&gt; released under the GNU GPL2\n// &lt;https://www.gnu.org/licenses/gpl-2.0.txt&gt;\n\n// Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007\n// Luca Gugelmann &lt;lucag@student.ethz.ch&gt; released under the GNU LGPL\n// &lt;http://www.gnu.org/licenses/old-licenses/library.txt&gt;\n\n#pragma once\n\n#include \"buttonhandler.h\"\n#include \"capturetoolbutton.h\"\n#include \"capturetoolobjects.h\"\n#include \"src/config/generalconf.h\"\n#include \"src/tools/capturecontext.h\"\n#include \"src/tools/capturetool.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/widgets/capture/magnifierwidget.h\"\n#include \"src/widgets/capture/selectionwidget.h\"\n#include &lt;QPointer&gt;\n#include &lt;QTimer&gt;\n#include &lt;QUndoStack&gt;\n#include &lt;QWidget&gt;\n\nclass QLabel;\nclass QPaintEvent;\nclass QResizeEvent;\nclass QMouseEvent;\nclass QShortcut;\nclass QNetworkAccessManager;\nclass QNetworkReply;\nclass ColorPicker;\nclass NotifierBox;\nclass HoverEventFilter;\n#if !defined(DISABLE_UPDATE_CHECKER)\nclass UpdateNotificationWidget;\n#endif\nclass UtilityPanel;\nclass SidePanelWidget;\n\nclass CaptureWidget : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    explicit CaptureWidget(const CaptureRequest&amp; req,\n                           bool fullScreen = true,\n                           QWidget* parent = nullptr);\n    ~CaptureWidget();\n\n    QPixmap pixmap();\n    void setCaptureToolObjects(const CaptureToolObjects&amp; captureToolObjects);\n#if !defined(DISABLE_UPDATE_CHECKER)\n    void showAppUpdateNotification(const QString&amp; appLatestVersion,\n                                   const QString&amp; appLatestUrl);\n#endif\n\npublic slots:\n    bool commitCurrentTool();\n    void deleteToolWidgetOrClose();\n\nsignals:\n    void colorChanged(const QColor&amp; c);\n    void toolSizeChanged(int size);\n\nprivate slots:\n    void undo();\n    void redo();\n    void togglePanel();\n    void childEnter();\n    void childLeave();\n\n    void deleteCurrentTool();\n\n    void setState(CaptureToolButton* b);\n    void handleToolSignal(CaptureTool::Request r);\n    void handleButtonLeftClick(CaptureToolButton* b);\n    void handleButtonRightClick(CaptureToolButton* b);\n    void setDrawColor(const QColor&amp; c);\n    void onToolSizeChanged(int size);\n    void onToolSizeSettled(int size);\n    void updateActiveLayer(int layer);\n    void onMoveCaptureToolUp(int captureToolIndex);\n    void onMoveCaptureToolDown(int captureToolIndex);\n    void selectAll();\n    void xywhTick();\n    void onDisplayGridChanged(bool display);\n    void onGridSizeChanged(int size);\n\npublic:\n    void removeToolObject(int index = -1);\n    void showxywh();\n\nprotected:\n    void paintEvent(QPaintEvent* paintEvent) override;\n    void mousePressEvent(QMouseEvent* mouseEvent) override;\n    void mouseMoveEvent(QMouseEvent* mouseEvent) override;\n    void mouseReleaseEvent(QMouseEvent* mouseEvent) override;\n    void mouseDoubleClickEvent(QMouseEvent* event) override;\n    void keyPressEvent(QKeyEvent* keyEvent) override;\n    void keyReleaseEvent(QKeyEvent* keyEvent) override;\n    void wheelEvent(QWheelEvent* wheelEvent) override;\n    void resizeEvent(QResizeEvent* resizeEvent) override;\n    void moveEvent(QMoveEvent* moveEvent) override;\n    void changeEvent(QEvent* changeEvent) override;\n\nprivate:\n    void pushObjectsStateToUndoStack();\n    void releaseActiveTool();\n    void uncheckActiveTool();\n    int selectToolItemAtPos(const QPoint&amp; pos);\n    void showColorPicker(const QPoint&amp; pos);\n    bool startDrawObjectTool(const QPoint&amp; pos);\n    QPointer&lt;CaptureTool&gt; activeToolObject();\n    void initContext(bool fullscreen, const CaptureRequest&amp; req);\n    void initPanel();\n    void initSelection();\n    void initShortcuts();\n    void initButtons();\n    void initHelpMessage();\n    void updateSizeIndicator();\n    void updateCursor();\n    void updateSelectionState();\n    void updateTool(CaptureTool* tool);\n    void updateLayersPanel();\n    void pushToolToStack();\n    void makeChild(QWidget* w);\n    void restoreCircleCountState();\n\n    QList&lt;QShortcut*&gt; newShortcut(const QKeySequence&amp; key,\n                                  QWidget* parent,\n                                  const char* slot);\n\n    void setToolSize(int size);\n\n    QRect extendedSelection() const;\n    QRect extendedRect(const QRect&amp; r) const;\n    QRect paddedUpdateRect(const QRect&amp; r) const;\n    void drawErrorMessage(const QString&amp; msg, QPainter* painter);\n    void drawInactiveRegion(QPainter* painter);\n    void drawToolsData(bool drawSelection = true);\n    void drawObjectSelection();\n\n    void processPixmapWithTool(QPixmap* pixmap, CaptureTool* tool);\n\n    CaptureTool* activeButtonTool() const;\n    CaptureTool::Type activeButtonToolType() const;\n\n    QPoint snapToGrid(const QPoint&amp; point) const;\n\n    // Class members\n\n    // Context information\n    CaptureContext m_context;\n\n    // Main ui color\n    QColor m_uiColor;\n    // Secondary ui color\n    QColor m_contrastUiColor;\n\n    // Outside selection opacity\n    int m_opacity;\n    int m_toolSizeByKeyboard;\n\n    // utility flags\n    bool m_mouseIsClicked;\n    bool m_newSelection;\n    bool m_movingSelection;\n    bool m_captureDone;\n    bool m_previewEnabled;\n    bool m_adjustmentButtonPressed;\n    bool m_configError;\n    bool m_configErrorResolved;\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n    UpdateNotificationWidget* m_updateNotificationWidget;\n#endif\n    quint64 m_lastMouseWheel;\n    QPointer&lt;CaptureToolButton&gt; m_sizeIndButton;\n    // Last pressed button\n    QPointer&lt;CaptureToolButton&gt; m_activeButton;\n    QPointer&lt;CaptureTool&gt; m_activeTool;\n    bool m_activeToolIsMoved;\n    QPointer&lt;QWidget&gt; m_toolWidget;\n\n    ButtonHandler* m_buttonHandler;\n    UtilityPanel* m_panel;\n    SidePanelWidget* m_sidePanel;\n    ColorPicker* m_colorPicker;\n    ConfigHandler m_config;\n    NotifierBox* m_notifierBox;\n    HoverEventFilter* m_eventFilter;\n    SelectionWidget* m_selection;\n    MagnifierWidget* m_magnifier;\n    QString m_helpMessage;\n\n    SelectionWidget::SideType m_mouseOverHandle;\n\n    QMap&lt;CaptureTool::Type, CaptureTool*&gt; m_tools;\n    CaptureToolObjects m_captureToolObjects;\n    CaptureToolObjects m_captureToolObjectsBackup;\n\n    QPoint m_mousePressedPos;\n    QPoint m_activeToolOffsetToMouseOnStart;\n\n    // XYWH display position and timer\n    bool m_xywhDisplay;\n    QTimer m_xywhTimer;\n\n    QUndoStack m_undoStack;\n\n    bool m_existingObjectIsChanged;\n\n    // For start moving after more than X offset\n    QPoint m_startMovePos;\n    bool m_startMove;\n\n    // Grid\n    bool m_displayGrid{ false };\n    int m_gridSize{ 10 };\n};\n\n</code></pre>"},{"location":"flameshot/colorpicker_8cpp/","title":"File colorpicker.cpp","text":"<p>FileList &gt; capture &gt; colorpicker.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"colorpicker.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/colorpicker_8cpp_source/","title":"File colorpicker.cpp","text":"<p>File List &gt; capture &gt; colorpicker.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"colorpicker.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QMouseEvent&gt;\n#include &lt;QPainter&gt;\n\nColorPicker::ColorPicker(QWidget* parent)\n  : ColorPickerWidget(parent)\n{\n    setMouseTracking(true);\n\n    ConfigHandler config;\n    QColor drawColor = config.drawColor();\n    for (int i = 0; i &lt; m_colorList.size(); ++i) {\n        if (m_colorList.at(i) == drawColor) {\n            m_selectedIndex = i;\n            m_lastIndex = i;\n            break;\n        }\n    }\n}\n\nvoid ColorPicker::mouseMoveEvent(QMouseEvent* e)\n{\n    for (int i = 0; i &lt; m_colorList.size(); ++i) {\n        if (m_colorAreaList.at(i).contains(e-&gt;pos())) {\n            m_selectedIndex = i;\n            update(m_colorAreaList.at(i) + QMargins(10, 10, 10, 10));\n            update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10));\n            m_lastIndex = i;\n            break;\n        }\n    }\n}\n\nvoid ColorPicker::showEvent(QShowEvent* event)\n{\n    grabMouse();\n}\n\nvoid ColorPicker::hideEvent(QHideEvent* event)\n{\n    releaseMouse();\n    emit colorSelected(m_colorList.at(m_selectedIndex));\n}\n\n</code></pre>"},{"location":"flameshot/colorpicker_8h/","title":"File colorpicker.h","text":"<p>FileList &gt; capture &gt; colorpicker.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/widgets/colorpickerwidget.h\"</code></li> </ul>"},{"location":"flameshot/colorpicker_8h/#classes","title":"Classes","text":"Type Name class ColorPicker"},{"location":"flameshot/colorpicker_8h_source/","title":"File colorpicker.h","text":"<p>File List &gt; capture &gt; colorpicker.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/widgets/colorpickerwidget.h\"\n\nclass ColorPicker : public ColorPickerWidget\n{\n    Q_OBJECT\npublic:\n    explicit ColorPicker(QWidget* parent = nullptr);\n\nsignals:\n    void colorSelected(QColor c);\n\nprotected:\n    void showEvent(QShowEvent* event) override;\n    void hideEvent(QHideEvent* event) override;\n    void mouseMoveEvent(QMouseEvent* e) override;\n};\n\n</code></pre>"},{"location":"flameshot/hovereventfilter_8cpp/","title":"File hovereventfilter.cpp","text":"<p>FileList &gt; capture &gt; hovereventfilter.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"hovereventfilter.h\"</code></li> <li><code>#include &lt;QEvent&gt;</code></li> </ul>"},{"location":"flameshot/hovereventfilter_8cpp_source/","title":"File hovereventfilter.cpp","text":"<p>File List &gt; capture &gt; hovereventfilter.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// Based on Lightscreen areadialog.h, Copyright 2017  Christian Kaiser\n// &lt;info@ckaiser.com.ar&gt; released under the GNU GPL2\n// &lt;https://www.gnu.org/licenses/gpl-2.0.txt&gt;\n\n// Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007\n// Luca Gugelmann &lt;lucag@student.ethz.ch&gt; released under the GNU LGPL\n// &lt;http://www.gnu.org/licenses/old-licenses/library.txt&gt;\n\n#include \"hovereventfilter.h\"\n#include &lt;QEvent&gt;\n\nHoverEventFilter::HoverEventFilter(QObject* parent)\n  : QObject(parent)\n{}\n\nbool HoverEventFilter::eventFilter(QObject* watched, QEvent* event)\n{\n    QEvent::Type t = event-&gt;type();\n    switch (t) {\n        case QEvent::Enter:\n            emit hoverIn(watched);\n            break;\n        case QEvent::Leave:\n            emit hoverOut(watched);\n            break;\n        default:\n            break;\n    }\n    return false;\n}\n\n</code></pre>"},{"location":"flameshot/hovereventfilter_8h/","title":"File hovereventfilter.h","text":"<p>FileList &gt; capture &gt; hovereventfilter.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QObject&gt;</code></li> </ul>"},{"location":"flameshot/hovereventfilter_8h/#classes","title":"Classes","text":"Type Name class HoverEventFilter"},{"location":"flameshot/hovereventfilter_8h_source/","title":"File hovereventfilter.h","text":"<p>File List &gt; capture &gt; hovereventfilter.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// Based on Lightscreen areadialog.h, Copyright 2017  Christian Kaiser\n// &lt;info@ckaiser.com.ar&gt; released under the GNU GPL2\n// &lt;https://www.gnu.org/licenses/gpl-2.0.txt&gt;\n\n// Based on KDE's KSnapshot regiongrabber.cpp, revision 796531, Copyright 2007\n// Luca Gugelmann &lt;lucag@student.ethz.ch&gt; released under the GNU LGPL\n// &lt;http://www.gnu.org/licenses/old-licenses/library.txt&gt;\n\n#pragma once\n\n#include &lt;QObject&gt;\n\nclass HoverEventFilter : public QObject\n{\n    Q_OBJECT\npublic:\n    explicit HoverEventFilter(QObject* parent = nullptr);\n\nsignals:\n    void hoverIn(QObject*);\n    void hoverOut(QObject*);\n\nprotected:\n    bool eventFilter(QObject* watched, QEvent* event);\n};\n\n</code></pre>"},{"location":"flameshot/magnifierwidget_8cpp/","title":"File magnifierwidget.cpp","text":"<p>FileList &gt; capture &gt; magnifierwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"magnifierwidget.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QEvent&gt;</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPainterPath&gt;</code></li> <li><code>#include &lt;QPen&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> </ul>"},{"location":"flameshot/magnifierwidget_8cpp_source/","title":"File magnifierwidget.cpp","text":"<p>File List &gt; capture &gt; magnifierwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"magnifierwidget.h\"\n#include &lt;QApplication&gt;\n#include &lt;QEvent&gt;\n#include &lt;QMouseEvent&gt;\n#include &lt;QPainter&gt;\n#include &lt;QPainterPath&gt;\n#include &lt;QPen&gt;\n#include &lt;QPixmap&gt;\n\nMagnifierWidget::MagnifierWidget(const QPixmap&amp; p,\n                                 const QColor&amp; c,\n                                 bool isSquare,\n                                 QWidget* parent)\n  : QWidget(parent)\n  , m_color(c)\n  , m_borderColor(c)\n  , m_screenshot(p)\n  , m_square(isSquare)\n{\n    setFixedSize(parent-&gt;width(), parent-&gt;height());\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    m_color.setAlpha(130);\n    // add padding for circular magnifier\n    QImage padded(p.width() + 2 * m_magPixels,\n                  p.height() + 2 * m_magPixels,\n                  QImage::Format_ARGB32);\n    padded.fill(Qt::black);\n    QPainter painter(&amp;padded);\n    painter.drawPixmap(m_magPixels, m_magPixels, p);\n    m_paddedScreenshot.convertFromImage(padded);\n}\nvoid MagnifierWidget::paintEvent(QPaintEvent*)\n{\n    QPainter p(this);\n    if (m_square) {\n        drawMagnifier(p);\n    } else {\n        drawMagnifierCircle(p);\n    }\n}\n\nvoid MagnifierWidget::drawMagnifierCircle(QPainter&amp; painter)\n{\n    auto relativeCursor = QCursor::pos();\n    auto translated = QWidget::mapFromGlobal(relativeCursor);\n    auto x = translated.x() + m_magPixels;\n    auto y = translated.y() + m_magPixels;\n\n    int magX = static_cast&lt;int&gt;(x * m_devicePixelRatio - m_magPixels);\n    int magY = static_cast&lt;int&gt;(y * m_devicePixelRatio - m_magPixels);\n    QRectF magniRect(magX, magY, m_pixels, m_pixels);\n\n    qreal drawPosX = x + m_magOffset + m_pixels * magZoom / 2;\n    if (drawPosX &gt; width() - m_pixels * magZoom / 2) {\n        drawPosX = x - m_magOffset - m_pixels * magZoom / 2;\n    }\n    qreal drawPosY = y + m_magOffset + m_pixels * magZoom / 2;\n    if (drawPosY &gt; height() - m_pixels * magZoom / 2) {\n        drawPosY = y - m_magOffset - m_pixels * magZoom / 2;\n    }\n    QPointF drawPos(drawPosX, drawPosY);\n    QRectF crossHairTop(drawPos.x() + magZoom * (-0.5),\n                        drawPos.y() - magZoom * (m_magPixels + 0.5),\n                        magZoom,\n                        magZoom * (m_magPixels));\n    QRectF crossHairRight(drawPos.x() + magZoom * (0.5),\n                          drawPos.y() + magZoom * (-0.5),\n                          magZoom * (m_magPixels),\n                          magZoom);\n    QRectF crossHairBottom(drawPos.x() + magZoom * (-0.5),\n                           drawPos.y() + magZoom * (0.5),\n                           magZoom,\n                           magZoom * (m_magPixels));\n    QRectF crossHairLeft(drawPos.x() - magZoom * (m_magPixels + 0.5),\n                         drawPos.y() + magZoom * (-0.5),\n                         magZoom * (m_magPixels),\n                         magZoom);\n    QRectF crossHairBorder(drawPos.x() - magZoom * (m_magPixels + 0.5) - 1,\n                           drawPos.y() - magZoom * (m_magPixels + 0.5) - 1,\n                           m_pixels * magZoom + 2,\n                           m_pixels * magZoom + 2);\n    const auto frag =\n      QPainter::PixmapFragment::create(drawPos, magniRect, magZoom, magZoom);\n\n    painter.setRenderHint(QPainter::Antialiasing, true);\n    QPainterPath path = QPainterPath();\n    path.addEllipse(drawPos, m_pixels * magZoom / 2, m_pixels * magZoom / 2);\n    painter.setClipPath(path);\n\n    painter.drawPixmapFragments(\n      &amp;frag, 1, m_paddedScreenshot, QPainter::OpaqueHint);\n    painter.setCompositionMode(QPainter::CompositionMode_SourceOver);\n    for (const auto&amp; rect :\n         { crossHairTop, crossHairRight, crossHairBottom, crossHairLeft }) {\n        painter.fillRect(rect, m_color);\n    }\n    QPen pen(m_borderColor);\n    pen.setWidth(4);\n    painter.setPen(pen);\n    painter.drawEllipse(\n      drawPos, m_pixels * magZoom / 2, m_pixels * magZoom / 2);\n}\n// https://invent.kde.org/graphics/spectacle/-/blob/master/src/QuickEditor/QuickEditor.cpp#L841\nvoid MagnifierWidget::drawMagnifier(QPainter&amp; painter)\n{\n    auto relativeCursor = QCursor::pos();\n    auto translated = QWidget::mapFromGlobal(relativeCursor);\n    auto x = translated.x();\n    auto y = translated.y();\n\n    int magX = static_cast&lt;int&gt;(x * m_devicePixelRatio - m_magPixels);\n    int offsetX = 0;\n    if (magX &lt; 0) {\n        offsetX = magX;\n        magX = 0;\n    } else {\n        const int maxX = m_screenshot.width() - m_pixels;\n        if (magX &gt; maxX) {\n            offsetX = magX - maxX;\n            magX = maxX;\n        }\n    }\n    int magY = static_cast&lt;int&gt;(y * m_devicePixelRatio - m_magPixels);\n    int offsetY = 0;\n    if (magY &lt; 0) {\n        offsetY = magY;\n        magY = 0;\n    } else {\n        const int maxY = m_screenshot.height() - m_pixels;\n        if (magY &gt; maxY) {\n            offsetY = magY - maxY;\n            magY = maxY;\n        }\n    }\n    QRectF magniRect(magX, magY, m_pixels, m_pixels);\n\n    qreal drawPosX = x + m_magOffset + m_pixels * magZoom / 2;\n    if (drawPosX &gt; width() - m_pixels * magZoom / 2) {\n        drawPosX = x - m_magOffset - m_pixels * magZoom / 2;\n    }\n    qreal drawPosY = y + m_magOffset + m_pixels * magZoom / 2;\n    if (drawPosY &gt; height() - m_pixels * magZoom / 2) {\n        drawPosY = y - m_magOffset - m_pixels * magZoom / 2;\n    }\n    QPointF drawPos(drawPosX, drawPosY);\n    QRectF crossHairTop(drawPos.x() + magZoom * (offsetX - 0.5),\n                        drawPos.y() - magZoom * (m_magPixels + 0.5),\n                        magZoom,\n                        magZoom * (m_magPixels + offsetY));\n    QRectF crossHairRight(drawPos.x() + magZoom * (0.5 + offsetX),\n                          drawPos.y() + magZoom * (offsetY - 0.5),\n                          magZoom * (m_magPixels - offsetX),\n                          magZoom);\n    QRectF crossHairBottom(drawPos.x() + magZoom * (offsetX - 0.5),\n                           drawPos.y() + magZoom * (0.5 + offsetY),\n                           magZoom,\n                           magZoom * (m_magPixels - offsetY));\n    QRectF crossHairLeft(drawPos.x() - magZoom * (m_magPixels + 0.5),\n                         drawPos.y() + magZoom * (offsetY - 0.5),\n                         magZoom * (m_magPixels + offsetX),\n                         magZoom);\n    QRectF crossHairBorder(drawPos.x() - magZoom * (m_magPixels + 0.5) - 1,\n                           drawPos.y() - magZoom * (m_magPixels + 0.5) - 1,\n                           m_pixels * magZoom + 2,\n                           m_pixels * magZoom + 2);\n    const auto frag =\n      QPainter::PixmapFragment::create(drawPos, magniRect, magZoom, magZoom);\n\n    painter.fillRect(crossHairBorder, m_borderColor);\n    painter.drawPixmapFragments(&amp;frag, 1, m_screenshot, QPainter::OpaqueHint);\n    painter.setCompositionMode(QPainter::CompositionMode_SourceOver);\n    for (const auto&amp; rect :\n         { crossHairTop, crossHairRight, crossHairBottom, crossHairLeft }) {\n        painter.fillRect(rect, m_color);\n    }\n}\n\n</code></pre>"},{"location":"flameshot/magnifierwidget_8h/","title":"File magnifierwidget.h","text":"<p>FileList &gt; capture &gt; magnifierwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/magnifierwidget_8h/#classes","title":"Classes","text":"Type Name class MagnifierWidget"},{"location":"flameshot/magnifierwidget_8h_source/","title":"File magnifierwidget.h","text":"<p>File List &gt; capture &gt; magnifierwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass QPropertyAnimation;\n\nclass MagnifierWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit MagnifierWidget(const QPixmap&amp; p,\n                             const QColor&amp; c,\n                             bool isSquare,\n                             QWidget* parent = nullptr);\n\nprotected:\n    void paintEvent(QPaintEvent*) override;\n\nprivate:\n    const int m_magPixels = 8;\n    const int m_magOffset = 16;\n    const int magZoom = 10;\n    const int m_pixels = 2 * m_magPixels + 1;\n    const int m_devicePixelRatio = 1;\n    bool m_square;\n    QColor m_color;\n    QColor m_borderColor;\n    QPixmap m_screenshot;\n    QPixmap m_paddedScreenshot;\n    void drawMagnifier(QPainter&amp; painter);\n    void drawMagnifierCircle(QPainter&amp; painter);\n};\n\n</code></pre>"},{"location":"flameshot/modificationcommand_8cpp/","title":"File modificationcommand.cpp","text":"<p>FileList &gt; capture &gt; modificationcommand.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"modificationcommand.h\"</code></li> <li><code>#include \"capturewidget.h\"</code></li> </ul>"},{"location":"flameshot/modificationcommand_8cpp_source/","title":"File modificationcommand.cpp","text":"<p>File List &gt; capture &gt; modificationcommand.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"modificationcommand.h\"\n#include \"capturewidget.h\"\n\nModificationCommand::ModificationCommand(\n  CaptureWidget* captureWidget,\n  const CaptureToolObjects&amp; captureToolObjects,\n  const CaptureToolObjects&amp; captureToolObjectsBackup)\n  : m_captureWidget(captureWidget)\n{\n    m_captureToolObjects = captureToolObjects;\n    m_captureToolObjectsBackup = captureToolObjectsBackup;\n}\n\nvoid ModificationCommand::undo()\n{\n    m_captureWidget-&gt;setCaptureToolObjects(m_captureToolObjectsBackup);\n}\n\nvoid ModificationCommand::redo()\n{\n    m_captureWidget-&gt;setCaptureToolObjects(m_captureToolObjects);\n}\n\n</code></pre>"},{"location":"flameshot/modificationcommand_8h/","title":"File modificationcommand.h","text":"<p>FileList &gt; capture &gt; modificationcommand.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturetoolobjects.h\"</code></li> <li><code>#include &lt;QUndoCommand&gt;</code></li> </ul>"},{"location":"flameshot/modificationcommand_8h/#classes","title":"Classes","text":"Type Name class ModificationCommand"},{"location":"flameshot/modificationcommand_8h_source/","title":"File modificationcommand.h","text":"<p>File List &gt; capture &gt; modificationcommand.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"capturetoolobjects.h\"\n#include &lt;QUndoCommand&gt;\n\n#ifndef FLAMESHOT_MODIFICATIONCOMMAND_H\n#define FLAMESHOT_MODIFICATIONCOMMAND_H\n\nclass CaptureWidget;\n\nclass ModificationCommand : public QUndoCommand\n{\npublic:\n    ModificationCommand(CaptureWidget* captureWidget,\n                        const CaptureToolObjects&amp; captureToolObjects,\n                        const CaptureToolObjects&amp; captureToolObjectsBackup);\n\n    virtual void undo() override;\n    virtual void redo() override;\n\nprivate:\n    CaptureToolObjects m_captureToolObjects;\n    CaptureToolObjects m_captureToolObjectsBackup;\n    CaptureWidget* m_captureWidget;\n};\n\n#endif // FLAMESHOT_MODIFICATIONCOMMAND_H\n\n</code></pre>"},{"location":"flameshot/notifierbox_8cpp/","title":"File notifierbox.cpp","text":"<p>FileList &gt; capture &gt; notifierbox.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"notifierbox.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> </ul>"},{"location":"flameshot/notifierbox_8cpp_source/","title":"File notifierbox.cpp","text":"<p>File List &gt; capture &gt; notifierbox.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"notifierbox.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QApplication&gt;\n#include &lt;QPainter&gt;\n#include &lt;QTimer&gt;\n\nNotifierBox::NotifierBox(QWidget* parent)\n  : QWidget(parent)\n{\n    m_timer = new QTimer(this);\n    m_timer-&gt;setSingleShot(true);\n    m_timer-&gt;setInterval(600);\n    connect(m_timer, &amp;QTimer::timeout, this, &amp;NotifierBox::hide);\n    m_bgColor = ConfigHandler().uiColor();\n    m_foregroundColor =\n      (ColorUtils::colorIsDark(m_bgColor) ? Qt::white : Qt::black);\n    m_bgColor.setAlpha(180);\n    const int size =\n      (GlobalValues::buttonBaseSize() + GlobalValues::buttonBaseSize() / 2) *\n      qApp-&gt;devicePixelRatio();\n    setFixedSize(QSize(size, size));\n}\n\nvoid NotifierBox::enterEvent(QEvent*)\n{\n    hide();\n}\n\nvoid NotifierBox::paintEvent(QPaintEvent*)\n{\n    QPainter painter(this);\n    // draw Ellipse\n    painter.setRenderHint(QPainter::Antialiasing);\n    painter.setBrush(QBrush(m_bgColor, Qt::SolidPattern));\n    painter.setPen(QPen(Qt::transparent));\n    painter.drawEllipse(rect());\n    // Draw the text:\n    painter.setPen(QPen(m_foregroundColor));\n    painter.drawText(rect(), Qt::AlignCenter, m_message);\n}\n\nvoid NotifierBox::showMessage(const QString&amp; msg)\n{\n    m_message = msg;\n    update();\n    show();\n    m_timer-&gt;start();\n}\n\nvoid NotifierBox::showColor(const QColor&amp; color)\n{\n    Q_UNUSED(color)\n    m_message = QLatin1String(\"\");\n}\n\nvoid NotifierBox::hideEvent(QHideEvent* event)\n{\n    emit hidden();\n}\n\n</code></pre>"},{"location":"flameshot/notifierbox_8h/","title":"File notifierbox.h","text":"<p>FileList &gt; capture &gt; notifierbox.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/notifierbox_8h/#classes","title":"Classes","text":"Type Name class NotifierBox"},{"location":"flameshot/notifierbox_8h_source/","title":"File notifierbox.h","text":"<p>File List &gt; capture &gt; notifierbox.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass QTimer;\n\nclass NotifierBox : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit NotifierBox(QWidget* parent = nullptr);\n\nprotected:\n    virtual void enterEvent(QEvent*) override;\n    virtual void paintEvent(QPaintEvent*) override;\n\nsignals:\n    void hidden();\n\npublic slots:\n    void showMessage(const QString&amp; msg);\n    void showColor(const QColor&amp; color);\n\nprivate:\n    QTimer* m_timer;\n    QString m_message;\n    QColor m_bgColor;\n    QColor m_foregroundColor;\n\n    void hideEvent(QHideEvent* event) override;\n};\n\n</code></pre>"},{"location":"flameshot/overlaymessage_8cpp/","title":"File overlaymessage.cpp","text":"<p>FileList &gt; capture &gt; overlaymessage.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"overlaymessage.h\"</code></li> <li><code>#include \"colorutils.h\"</code></li> <li><code>#include \"confighandler.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPen&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/overlaymessage_8cpp_source/","title":"File overlaymessage.cpp","text":"<p>File List &gt; capture &gt; overlaymessage.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"overlaymessage.h\"\n#include \"colorutils.h\"\n#include \"confighandler.h\"\n\n#include &lt;QApplication&gt;\n#include &lt;QDebug&gt;\n#include &lt;QLabel&gt;\n#include &lt;QPainter&gt;\n#include &lt;QPen&gt;\n#include &lt;QScreen&gt;\n\nOverlayMessage::OverlayMessage(QWidget* parent, const QRect&amp; targetArea)\n  : QLabel(parent)\n  , m_targetArea(targetArea)\n{\n    // NOTE: do not call the static functions from the constructor\n    m_instance = this;\n    m_messageStack.push(QString()); // Default message is empty\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    setAttribute(Qt::WA_AlwaysStackOnTop);\n    setAlignment(Qt::AlignCenter);\n    setTextFormat(Qt::RichText);\n\n    m_fillColor = ConfigHandler().uiColor();\n    int opacity = ConfigHandler().contrastOpacity();\n    m_textColor =\n      (ColorUtils::colorIsDark(m_fillColor) ? Qt::white : Qt::black);\n    // map a background opacity range 0-255 to a fill opacity range 190-160\n    // we do this because an opaque background makes the box look opaque too\n    m_fillColor.setAlpha(160 + (180 - 220) / (255.0 - 0) * (opacity - 255));\n    setStyleSheet(\n      QStringLiteral(\"QLabel { color: %1; }\").arg(m_textColor.name()));\n\n    setMargin(QApplication::fontMetrics().height() / 2);\n    QWidget::hide();\n}\n\nvoid OverlayMessage::init(QWidget* parent, const QRect&amp; targetArea)\n{\n    new OverlayMessage(parent, targetArea);\n}\n\nvoid OverlayMessage::push(const QString&amp; msg)\n{\n    m_instance-&gt;m_messageStack.push(msg);\n    m_instance-&gt;setText(m_instance-&gt;m_messageStack.top());\n    setVisibility(true);\n}\n\nvoid OverlayMessage::pop()\n{\n    if (m_instance-&gt;m_messageStack.size() &gt; 1) {\n        m_instance-&gt;m_messageStack.pop();\n    }\n\n    m_instance-&gt;setText(m_instance-&gt;m_messageStack.top());\n    setVisibility(m_instance-&gt;m_messageStack.size() &gt; 1);\n}\n\nvoid OverlayMessage::setVisibility(bool visible)\n{\n    m_instance-&gt;updateGeometry();\n    m_instance-&gt;setVisible(visible);\n}\n\nOverlayMessage* OverlayMessage::instance()\n{\n    return m_instance;\n}\n\nvoid OverlayMessage::pushKeyMap(const QList&lt;QPair&lt;QString, QString&gt;&gt;&amp; map)\n{\n    push(compileFromKeyMap(map));\n}\n\nQString OverlayMessage::compileFromKeyMap(\n  const QList&lt;QPair&lt;QString, QString&gt;&gt;&amp; map)\n{\n    QString str = QStringLiteral(\"&lt;table&gt;\");\n    for (const auto&amp; pair : map) {\n        str += QStringLiteral(\"&lt;tr&gt;\"\n                              \"&lt;td align=\\\"right\\\"&gt;&lt;b&gt;%1 &lt;/b&gt;&lt;/td&gt;\"\n                              \"&lt;td align=\\\"left\\\"&gt;&amp;nbsp;&amp;nbsp;%2&lt;/td&gt;\"\n                              \"&lt;/tr&gt;\")\n                 .arg(pair.first)\n                 .arg(pair.second);\n    }\n    str += QStringLiteral(\"&lt;/table&gt;\");\n    return str;\n}\n\nvoid OverlayMessage::paintEvent(QPaintEvent* e)\n{\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    painter.setBrush(QBrush(m_fillColor, Qt::SolidPattern));\n    painter.setPen(QPen(m_textColor, 1.5));\n    float margin = painter.pen().widthF();\n    painter.drawRoundedRect(\n      rect() - QMarginsF(margin, margin, margin, margin), 5, 5);\n\n    return QLabel::paintEvent(e);\n}\n\nQRect OverlayMessage::boundingRect() const\n{\n    QRect geom = QRect(QPoint(), sizeHint());\n    geom.moveCenter(m_targetArea.center());\n    return geom;\n}\n\nvoid OverlayMessage::updateGeometry()\n{\n    setGeometry(boundingRect());\n    QLabel::updateGeometry();\n}\n\nOverlayMessage* OverlayMessage::m_instance = nullptr;\n\n</code></pre>"},{"location":"flameshot/overlaymessage_8h/","title":"File overlaymessage.h","text":"<p>FileList &gt; capture &gt; overlaymessage.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QStack&gt;</code></li> </ul>"},{"location":"flameshot/overlaymessage_8h/#classes","title":"Classes","text":"Type Name class OverlayMessage Overlay a message in capture mode."},{"location":"flameshot/overlaymessage_8h_source/","title":"File overlaymessage.h","text":"<p>File List &gt; capture &gt; overlaymessage.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#pragma once\n\n#include &lt;QLabel&gt;\n#include &lt;QStack&gt;\n\nclass OverlayMessage : public QLabel\n{\npublic:\n    OverlayMessage() = delete;\n\n    static void init(QWidget* parent, const QRect&amp; targetArea);\n    static void push(const QString&amp; msg);\n    static void pop();\n    static void setVisibility(bool visible);\n    static OverlayMessage* instance();\n\n    static void pushKeyMap(const QList&lt;QPair&lt;QString, QString&gt;&gt;&amp; map);\n    static QString compileFromKeyMap(const QList&lt;QPair&lt;QString, QString&gt;&gt;&amp; map);\n\nprivate:\n    QStack&lt;QString&gt; m_messageStack;\n    QRect m_targetArea;\n    QColor m_fillColor, m_textColor;\n    static OverlayMessage* m_instance;\n\n    OverlayMessage(QWidget* parent, const QRect&amp; center);\n\n    void paintEvent(QPaintEvent*) override;\n\n    QRect boundingRect() const;\n    void updateGeometry();\n};\n\n</code></pre>"},{"location":"flameshot/selectionwidget_8cpp/","title":"File selectionwidget.cpp","text":"<p>FileList &gt; capture &gt; selectionwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"selectionwidget.h\"</code></li> <li><code>#include \"capturetool.h\"</code></li> <li><code>#include \"capturetoolbutton.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QEvent&gt;</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QPropertyAnimation&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"flameshot/selectionwidget_8cpp/#public-functions","title":"Public Functions","text":"Type Name SelectionWidget::SideType getProperSide (SelectionWidget::SideType side, const QRect &amp; r)"},{"location":"flameshot/selectionwidget_8cpp/#macros","title":"Macros","text":"Type Name define MARGIN  (m_THandle.width())"},{"location":"flameshot/selectionwidget_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/selectionwidget_8cpp/#function-getproperside","title":"function getProperSide","text":"<pre><code>SelectionWidget::SideType getProperSide (\n    SelectionWidget::SideType side,\n    const QRect &amp; r\n) \n</code></pre>"},{"location":"flameshot/selectionwidget_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/selectionwidget_8cpp/#define-margin","title":"define MARGIN","text":"<pre><code>#define MARGIN (m_THandle.width())\n</code></pre>"},{"location":"flameshot/selectionwidget_8cpp_source/","title":"File selectionwidget.cpp","text":"<p>File List &gt; capture &gt; selectionwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"selectionwidget.h\"\n#include \"capturetool.h\"\n#include \"capturetoolbutton.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QApplication&gt;\n#include &lt;QEvent&gt;\n#include &lt;QMouseEvent&gt;\n#include &lt;QPainter&gt;\n#include &lt;QPropertyAnimation&gt;\n#include &lt;QTimer&gt;\n#include &lt;utility&gt;\n\n#define MARGIN (m_THandle.width())\n\nSelectionWidget::SelectionWidget(QColor c, QWidget* parent)\n  : QWidget(parent)\n  , m_color(std::move(c))\n  , m_activeSide(NO_SIDE)\n  , m_ignoreMouse(false)\n{\n    // prevents this widget from consuming CaptureToolButton mouse events\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    parent-&gt;installEventFilter(this);\n\n    m_animation = new QPropertyAnimation(this, \"geometry\", this);\n    m_animation-&gt;setEasingCurve(QEasingCurve::InOutQuad);\n    m_animation-&gt;setDuration(200);\n    connect(m_animation, &amp;QPropertyAnimation::finished, this, [this]() {\n        emit geometrySettled();\n    });\n\n    int sideVal = GlobalValues::buttonBaseSize() * 0.6;\n    int handleSide = sideVal / 2;\n    const QRect areaRect(0, 0, sideVal, sideVal);\n\n    const QRect handleRect(0, 0, handleSide, handleSide);\n    m_TLHandle = m_TRHandle = m_BLHandle = m_BRHandle = m_LHandle = m_THandle =\n      m_RHandle = m_BHandle = handleRect;\n    m_TLArea = m_TRArea = m_BLArea = m_BRArea = areaRect;\n\n    m_areaOffset = QPoint(-sideVal / 2, -sideVal / 2);\n    m_handleOffset = QPoint(-handleSide / 2, -handleSide / 2);\n}\n\nSelectionWidget::SideType SelectionWidget::getMouseSide(\n  const QPoint&amp; mousePos) const\n{\n    if (!isVisible()) {\n        return NO_SIDE;\n    }\n    QPoint localPos = mapFromParent(mousePos);\n    if (m_TLArea.contains(localPos)) {\n        return TOPLEFT_SIDE;\n    } else if (m_TRArea.contains(localPos)) {\n        return TOPRIGHT_SIDE;\n    } else if (m_BLArea.contains(localPos)) {\n        return BOTTOMLEFT_SIDE;\n    } else if (m_BRArea.contains(localPos)) {\n        return BOTTOMRIGHT_SIDE;\n    } else if (m_LArea.contains(localPos)) {\n        return LEFT_SIDE;\n    } else if (m_TArea.contains(localPos)) {\n        return TOP_SIDE;\n    } else if (m_RArea.contains(localPos)) {\n        return RIGHT_SIDE;\n    } else if (m_BArea.contains(localPos)) {\n        return BOTTOM_SIDE;\n    } else if (rect().contains(localPos)) {\n        return CENTER;\n    } else {\n        return NO_SIDE;\n    }\n}\n\nQVector&lt;QRect&gt; SelectionWidget::handlerAreas()\n{\n    QVector&lt;QRect&gt; areas;\n    areas &lt;&lt; m_TLHandle &lt;&lt; m_TRHandle &lt;&lt; m_BLHandle &lt;&lt; m_BRHandle &lt;&lt; m_LHandle\n          &lt;&lt; m_THandle &lt;&lt; m_RHandle &lt;&lt; m_BHandle;\n    return areas;\n}\n\n// helper function\nSelectionWidget::SideType getProperSide(SelectionWidget::SideType side,\n                                        const QRect&amp; r)\n{\n    using SideType = SelectionWidget::SideType;\n    int intSide = side;\n    if (r.right() &lt; r.left()) {\n        intSide ^= SideType::LEFT_SIDE;\n        intSide ^= SideType::RIGHT_SIDE;\n    }\n    if (r.bottom() &lt; r.top()) {\n        intSide ^= SideType::TOP_SIDE;\n        intSide ^= SideType::BOTTOM_SIDE;\n    }\n\n    return (SideType)intSide;\n}\n\nvoid SelectionWidget::setIgnoreMouse(bool ignore)\n{\n    m_ignoreMouse = ignore;\n    updateCursor();\n}\n\nvoid SelectionWidget::setIdleCentralCursor(const QCursor&amp; cursor)\n{\n    m_idleCentralCursor = cursor;\n}\n\nvoid SelectionWidget::setGeometryAnimated(const QRect&amp; r)\n{\n    if (isVisible()) {\n        m_animation-&gt;setStartValue(geometry());\n        m_animation-&gt;setEndValue(r);\n        m_animation-&gt;start();\n    }\n}\n\nvoid SelectionWidget::setGeometry(const QRect&amp; r)\n{\n    QWidget::setGeometry(r + QMargins(MARGIN, MARGIN, MARGIN, MARGIN));\n    updateCursor();\n    if (isVisible()) {\n        emit geometryChanged();\n    }\n}\n\nQRect SelectionWidget::geometry() const\n{\n    return QWidget::geometry() - QMargins(MARGIN, MARGIN, MARGIN, MARGIN);\n}\n\nQRect SelectionWidget::fullGeometry() const\n{\n    return QWidget::geometry();\n}\n\nQRect SelectionWidget::rect() const\n{\n    return QWidget::rect() - QMargins(MARGIN, MARGIN, MARGIN, MARGIN);\n}\n\nbool SelectionWidget::eventFilter(QObject* obj, QEvent* event)\n{\n    if (m_ignoreMouse &amp;&amp; dynamic_cast&lt;QMouseEvent*&gt;(event)) {\n        m_activeSide = NO_SIDE;\n        unsetCursor();\n    } else if (event-&gt;type() == QEvent::MouseButtonRelease) {\n        parentMouseReleaseEvent(static_cast&lt;QMouseEvent*&gt;(event));\n    } else if (event-&gt;type() == QEvent::MouseButtonPress) {\n        parentMousePressEvent(static_cast&lt;QMouseEvent*&gt;(event));\n    } else if (event-&gt;type() == QEvent::MouseMove) {\n        parentMouseMoveEvent(static_cast&lt;QMouseEvent*&gt;(event));\n    }\n    return false;\n}\n\nvoid SelectionWidget::parentMousePressEvent(QMouseEvent* e)\n{\n    if (e-&gt;button() != Qt::LeftButton) {\n        return;\n    }\n\n    m_dragStartPos = e-&gt;pos();\n    m_activeSide = getMouseSide(e-&gt;pos());\n}\n\nvoid SelectionWidget::parentMouseReleaseEvent(QMouseEvent* e)\n{\n    // released outside of the selection area\n    if (!getMouseSide(e-&gt;pos())) {\n        hide();\n    }\n\n    m_activeSide = NO_SIDE;\n    updateCursor();\n    emit geometrySettled();\n}\n\nvoid SelectionWidget::parentMouseMoveEvent(QMouseEvent* e)\n{\n    updateCursor();\n\n    if (e-&gt;buttons() != Qt::LeftButton) {\n        return;\n    }\n\n    SideType mouseSide = m_activeSide;\n    if (!m_activeSide) {\n        mouseSide = getMouseSide(e-&gt;pos());\n    }\n\n    QPoint pos;\n\n    if (!isVisible() || !mouseSide) {\n        show();\n        m_activeSide = TOPLEFT_SIDE;\n        pos = m_dragStartPos;\n        setGeometry({ pos, pos });\n    } else {\n        pos = e-&gt;pos();\n    }\n\n    auto geom = geometry();\n    float aspectRatio = (float)geom.width() / (float)geom.height();\n    bool symmetryMod = qApp-&gt;keyboardModifiers() &amp; Qt::ShiftModifier;\n    bool preserveAspect = qApp-&gt;keyboardModifiers() &amp; Qt::ControlModifier;\n\n    QPoint newTopLeft = geom.topLeft(), newBottomRight = geom.bottomRight();\n    int oldLeft = newTopLeft.rx(), oldRight = newBottomRight.rx(),\n        oldTop = newTopLeft.ry(), oldBottom = newBottomRight.ry();\n    int &amp;newLeft = newTopLeft.rx(), &amp;newRight = newBottomRight.rx(),\n        &amp;newTop = newTopLeft.ry(), &amp;newBottom = newBottomRight.ry();\n    switch (mouseSide) {\n        case TOPLEFT_SIDE:\n            if (m_activeSide) {\n                if (preserveAspect) {\n                    if ((float)(oldRight - pos.x()) /\n                          (float)(oldBottom - pos.y()) &gt;\n                        aspectRatio) {\n                        /* width longer than expected width, hence increase\n                         * height to compensate for the aspect ratio */\n                        newLeft = pos.x();\n                        newTop =\n                          oldBottom -\n                          (int)(((float)(oldRight - pos.x())) / aspectRatio);\n                    } else {\n                        /* height longer than expected height, hence increase\n                         * width to compensate for the aspect ratio */\n                        newTop = pos.y();\n                        newLeft =\n                          oldRight -\n                          (int)(((float)(oldBottom - pos.y())) * aspectRatio);\n                    }\n                } else {\n                    newTopLeft = pos;\n                }\n            }\n            break;\n        case BOTTOMRIGHT_SIDE:\n            if (m_activeSide) {\n                if (preserveAspect) {\n                    if ((float)(pos.x() - oldLeft) / (float)(pos.y() - oldTop) &gt;\n                        aspectRatio) {\n                        newRight = pos.x();\n                        newBottom =\n                          oldTop +\n                          (int)(((float)(pos.x() - oldLeft)) / aspectRatio);\n                    } else {\n                        newBottom = pos.y();\n                        newRight = oldLeft + (int)(((float)(pos.y() - oldTop)) *\n                                                   aspectRatio);\n                    }\n                } else {\n                    newBottomRight = pos;\n                }\n            }\n            break;\n        case TOPRIGHT_SIDE:\n            if (m_activeSide) {\n                if (preserveAspect) {\n                    if ((float)(pos.x() - oldLeft) /\n                          (float)(oldBottom - pos.y()) &gt;\n                        aspectRatio) {\n                        newRight = pos.x();\n                        newTop =\n                          oldBottom -\n                          (int)(((float)(pos.x() - oldLeft)) / aspectRatio);\n                    } else {\n                        newTop = pos.y();\n                        newRight =\n                          oldLeft +\n                          (int)(((float)(oldBottom - pos.y())) * aspectRatio);\n                    }\n                } else {\n                    newTop = pos.y();\n                    newRight = pos.x();\n                }\n            }\n            break;\n        case BOTTOMLEFT_SIDE:\n            if (m_activeSide) {\n                if (preserveAspect) {\n                    if ((float)(oldRight - pos.x()) /\n                          (float)(pos.y() - oldTop) &gt;\n                        aspectRatio) {\n                        newLeft = pos.x();\n                        newBottom =\n                          oldTop +\n                          (int)(((float)(oldRight - pos.x())) / aspectRatio);\n                    } else {\n                        newBottom = pos.y();\n                        newLeft = oldRight - (int)(((float)(pos.y() - oldTop)) *\n                                                   aspectRatio);\n                    }\n                } else {\n                    newBottom = pos.y();\n                    newLeft = pos.x();\n                }\n            }\n            break;\n        case LEFT_SIDE:\n            if (m_activeSide) {\n                newLeft = pos.x();\n                if (preserveAspect) {\n                    /* By default bottom edge moves when dragging sides, this\n                     * behavior feels natural */\n                    newBottom = oldTop + (int)(((float)(oldRight - pos.x())) /\n                                               aspectRatio);\n                }\n            }\n            break;\n        case RIGHT_SIDE:\n            if (m_activeSide) {\n                newRight = pos.x();\n                if (preserveAspect) {\n                    newBottom = oldTop + (int)(((float)(pos.x() - oldLeft)) /\n                                               aspectRatio);\n                }\n            }\n            break;\n        case TOP_SIDE:\n            if (m_activeSide) {\n                newTop = pos.y();\n                if (preserveAspect) {\n                    /* By default right edge moves when dragging sides, this\n                     * behavior feels natural */\n                    newRight =\n                      oldLeft +\n                      (int)(((float)(oldBottom - pos.y()) * aspectRatio));\n                }\n            }\n            break;\n        case BOTTOM_SIDE:\n            if (m_activeSide) {\n                newBottom = pos.y();\n                if (preserveAspect) {\n                    newRight = oldLeft +\n                               (int)(((float)(pos.y() - oldTop) * aspectRatio));\n                }\n            }\n            break;\n        default:\n            if (m_activeSide) {\n                move(this-&gt;pos() + pos - m_dragStartPos);\n                m_dragStartPos = pos;\n                /* do nothing special in case of preserveAspect */\n            }\n            return;\n    }\n    // finalize geometry change\n    if (m_activeSide) {\n        if (symmetryMod) {\n            QPoint deltaTopLeft = newTopLeft - geom.topLeft();\n            QPoint deltaBottomRight = newBottomRight - geom.bottomRight();\n            newTopLeft = geom.topLeft() + deltaTopLeft - deltaBottomRight;\n            newBottomRight =\n              geom.bottomRight() + deltaBottomRight - deltaTopLeft;\n        }\n        geom = { newTopLeft, newBottomRight };\n        setGeometry(geom.normalized());\n        m_activeSide = getProperSide(m_activeSide, geom);\n    }\n    m_dragStartPos = e-&gt;pos();\n}\n\nvoid SelectionWidget::paintEvent(QPaintEvent*)\n{\n    QPainter p(this);\n    p.setPen(m_color);\n    p.drawRect(rect() + QMargins(0, 0, -1, -1));\n    p.setRenderHint(QPainter::Antialiasing);\n    p.setBrush(m_color);\n    for (auto rectangle : handlerAreas()) {\n        p.drawEllipse(rectangle);\n    }\n}\n\nvoid SelectionWidget::resizeEvent(QResizeEvent*)\n{\n    updateAreas();\n    if (isVisible()) {\n        emit geometryChanged();\n    }\n}\n\nvoid SelectionWidget::moveEvent(QMoveEvent*)\n{\n    updateAreas();\n    if (isVisible()) {\n        emit geometryChanged();\n    }\n}\n\nvoid SelectionWidget::showEvent(QShowEvent*)\n{\n    emit visibilityChanged();\n}\n\nvoid SelectionWidget::hideEvent(QHideEvent*)\n{\n    emit visibilityChanged();\n}\n\nvoid SelectionWidget::updateColor(const QColor&amp; c)\n{\n    m_color = c;\n}\n\nvoid SelectionWidget::moveLeft()\n{\n    setGeometryByKeyboard(geometry().adjusted(-1, 0, -1, 0));\n}\n\nvoid SelectionWidget::moveRight()\n{\n    setGeometryByKeyboard(geometry().adjusted(1, 0, 1, 0));\n}\n\nvoid SelectionWidget::moveUp()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, -1, 0, -1));\n}\n\nvoid SelectionWidget::moveDown()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, 1, 0, 1));\n}\n\nvoid SelectionWidget::resizeLeft()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, 0, -1, 0));\n}\n\nvoid SelectionWidget::resizeRight()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, 0, 1, 0));\n}\n\nvoid SelectionWidget::resizeUp()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, 0, 0, -1));\n}\n\nvoid SelectionWidget::resizeDown()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, 0, 0, 1));\n}\n\nvoid SelectionWidget::symResizeLeft()\n{\n    setGeometryByKeyboard(geometry().adjusted(1, 0, -1, 0));\n}\n\nvoid SelectionWidget::symResizeRight()\n{\n    setGeometryByKeyboard(geometry().adjusted(-1, 0, 1, 0));\n}\n\nvoid SelectionWidget::symResizeUp()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, -1, 0, 1));\n}\n\nvoid SelectionWidget::symResizeDown()\n{\n    setGeometryByKeyboard(geometry().adjusted(0, 1, 0, -1));\n}\n\nvoid SelectionWidget::updateAreas()\n{\n    QRect r = rect();\n    m_TLArea.moveTo(r.topLeft() + m_areaOffset);\n    m_TRArea.moveTo(r.topRight() + m_areaOffset);\n    m_BLArea.moveTo(r.bottomLeft() + m_areaOffset);\n    m_BRArea.moveTo(r.bottomRight() + m_areaOffset);\n\n    m_LArea = QRect(m_TLArea.bottomLeft(), m_BLArea.topRight());\n    m_TArea = QRect(m_TLArea.topRight(), m_TRArea.bottomLeft());\n    m_RArea = QRect(m_TRArea.bottomLeft(), m_BRArea.topRight());\n    m_BArea = QRect(m_BLArea.topRight(), m_BRArea.bottomLeft());\n\n    m_TLHandle.moveTo(m_TLArea.center() + m_handleOffset);\n    m_BLHandle.moveTo(m_BLArea.center() + m_handleOffset);\n    m_TRHandle.moveTo(m_TRArea.center() + m_handleOffset);\n    m_BRHandle.moveTo(m_BRArea.center() + m_handleOffset);\n    m_LHandle.moveTo(m_LArea.center() + m_handleOffset);\n    m_THandle.moveTo(m_TArea.center() + m_handleOffset);\n    m_RHandle.moveTo(m_RArea.center() + m_handleOffset);\n    m_BHandle.moveTo(m_BArea.center() + m_handleOffset);\n}\n\nvoid SelectionWidget::updateCursor()\n{\n    SideType mouseSide = m_activeSide;\n    if (!m_activeSide) {\n        mouseSide = getMouseSide(parentWidget()-&gt;mapFromGlobal(QCursor::pos()));\n    }\n\n    switch (mouseSide) {\n        case TOPLEFT_SIDE:\n            setCursor(Qt::SizeFDiagCursor);\n            break;\n        case BOTTOMRIGHT_SIDE:\n            setCursor(Qt::SizeFDiagCursor);\n            break;\n        case TOPRIGHT_SIDE:\n            setCursor(Qt::SizeBDiagCursor);\n            break;\n        case BOTTOMLEFT_SIDE:\n            setCursor(Qt::SizeBDiagCursor);\n            break;\n        case LEFT_SIDE:\n            setCursor(Qt::SizeHorCursor);\n            break;\n        case RIGHT_SIDE:\n            setCursor(Qt::SizeHorCursor);\n            break;\n        case TOP_SIDE:\n            setCursor(Qt::SizeVerCursor);\n            break;\n        case BOTTOM_SIDE:\n            setCursor(Qt::SizeVerCursor);\n            break;\n        default:\n            if (m_activeSide) {\n                setCursor(Qt::ClosedHandCursor);\n            } else {\n                setCursor(m_idleCentralCursor);\n                return;\n            }\n            break;\n    }\n}\n\nvoid SelectionWidget::setGeometryByKeyboard(const QRect&amp; r)\n{\n    static QTimer timer;\n    QRect rectangle = r.intersected(parentWidget()-&gt;rect());\n    if (rectangle.width() &lt;= 0) {\n        rectangle.setWidth(1);\n    }\n    if (rectangle.height() &lt;= 0) {\n        rectangle.setHeight(1);\n    }\n    setGeometry(rectangle);\n    connect(&amp;timer,\n            &amp;QTimer::timeout,\n            this,\n            &amp;SelectionWidget::geometrySettled,\n            Qt::UniqueConnection);\n    timer.start(400);\n}\n\n</code></pre>"},{"location":"flameshot/selectionwidget_8h/","title":"File selectionwidget.h","text":"<p>FileList &gt; capture &gt; selectionwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/selectionwidget_8h/#classes","title":"Classes","text":"Type Name class SelectionWidget"},{"location":"flameshot/selectionwidget_8h_source/","title":"File selectionwidget.h","text":"<p>File List &gt; capture &gt; selectionwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass QPropertyAnimation;\n\nclass SelectionWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    enum SideType\n    {\n        NO_SIDE = 0,\n        TOP_SIDE = 0b0001,\n        BOTTOM_SIDE = 0b0010,\n        RIGHT_SIDE = 0b0100,\n        LEFT_SIDE = 0b1000,\n        TOPLEFT_SIDE = TOP_SIDE | LEFT_SIDE,\n        BOTTOMLEFT_SIDE = BOTTOM_SIDE | LEFT_SIDE,\n        TOPRIGHT_SIDE = TOP_SIDE | RIGHT_SIDE,\n        BOTTOMRIGHT_SIDE = BOTTOM_SIDE | RIGHT_SIDE,\n        CENTER = 0b10000,\n    };\n\n    explicit SelectionWidget(QColor c, QWidget* parent = nullptr);\n\n    SideType getMouseSide(const QPoint&amp; mousePos) const;\n    QVector&lt;QRect&gt; handlerAreas();\n\n    void setIgnoreMouse(bool ignore);\n    void setIdleCentralCursor(const QCursor&amp; cursor);\n\n    void setGeometryAnimated(const QRect&amp; r);\n    void setGeometry(const QRect&amp; r);\n    QRect geometry() const;\n    QRect fullGeometry() const;\n\n    QRect rect() const;\n\nprotected:\n    bool eventFilter(QObject*, QEvent*) override;\n    void parentMousePressEvent(QMouseEvent* e);\n    void parentMouseReleaseEvent(QMouseEvent* e);\n    void parentMouseMoveEvent(QMouseEvent* e);\n\n    void paintEvent(QPaintEvent*) override;\n    void resizeEvent(QResizeEvent*) override;\n    void moveEvent(QMoveEvent*) override;\n\n    void showEvent(QShowEvent*) override;\n    void hideEvent(QHideEvent*) override;\n\nsignals:\n    void animationEnded();\n    void geometryChanged();\n    void geometrySettled();\n    void visibilityChanged();\n\npublic slots:\n    void updateColor(const QColor&amp; c);\n\n    void moveLeft();\n    void moveRight();\n    void moveUp();\n    void moveDown();\n\n    void resizeLeft();\n    void resizeRight();\n    void resizeUp();\n    void resizeDown();\n\n    void symResizeLeft();\n    void symResizeRight();\n    void symResizeUp();\n    void symResizeDown();\n\nprivate:\n    void updateAreas();\n    void updateCursor();\n    void setGeometryByKeyboard(const QRect&amp; r);\n\n    QPropertyAnimation* m_animation;\n\n    QColor m_color;\n    QPoint m_areaOffset;\n    QPoint m_handleOffset;\n\n    QPoint m_dragStartPos;\n    SideType m_activeSide;\n    QCursor m_idleCentralCursor;\n    bool m_ignoreMouse;\n    bool m_mouseStartMove;\n\n    // naming convention for handles\n    // T top, B bottom, R Right, L left\n    // 2 letters: a corner\n    // 1 letter: the handle on the middle of the corresponding side\n    QRect m_TLHandle, m_TRHandle, m_BLHandle, m_BRHandle;\n    QRect m_LHandle, m_THandle, m_RHandle, m_BHandle;\n\n    QRect m_TLArea, m_TRArea, m_BLArea, m_BRArea;\n    QRect m_LArea, m_TArea, m_RArea, m_BArea;\n};\n\n</code></pre>"},{"location":"flameshot/capturelauncher_8cpp/","title":"File capturelauncher.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; capturelauncher.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capturelauncher.h\"</code></li> <li><code>#include \"./ui_capturelauncher.h\"</code></li> <li><code>#include \"src/config/cacheutils.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"src/utils/screengrabber.h\"</code></li> <li><code>#include \"src/utils/screenshotsaver.h\"</code></li> <li><code>#include \"src/widgets/imagelabel.h\"</code></li> <li><code>#include &lt;QMimeData&gt;</code></li> </ul>"},{"location":"flameshot/capturelauncher_8cpp_source/","title":"File capturelauncher.cpp","text":"<p>File List &gt; src &gt; widgets &gt; capturelauncher.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2018 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"capturelauncher.h\"\n#include \"./ui_capturelauncher.h\"\n#include \"src/config/cacheutils.h\"\n#include \"src/core/flameshot.h\"\n#include \"src/utils/globalvalues.h\"\n#include \"src/utils/screengrabber.h\"\n#include \"src/utils/screenshotsaver.h\"\n#include \"src/widgets/imagelabel.h\"\n#include &lt;QMimeData&gt;\n\n// https://github.com/KDE/spectacle/blob/941c1a517be82bed25d1254ebd735c29b0d2951c/src/Gui/KSWidget.cpp\n// https://github.com/KDE/spectacle/blob/941c1a517be82bed25d1254ebd735c29b0d2951c/src/Gui/KSMainWindow.cpp\n\nCaptureLauncher::CaptureLauncher(QDialog* parent)\n  : QDialog(parent)\n  , ui(new Ui::CaptureLauncher)\n{\n    qApp-&gt;installEventFilter(this); // see eventFilter()\n    ui-&gt;setupUi(this);\n    setAttribute(Qt::WA_DeleteOnClose);\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    bool ok;\n\n    ui-&gt;imagePreview-&gt;setScreenshot(ScreenGrabber().grabEntireDesktop(ok));\n    ui-&gt;imagePreview-&gt;setSizePolicy(QSizePolicy::Expanding,\n                                    QSizePolicy::Expanding);\n\n    ui-&gt;captureType-&gt;insertItem(\n      1, tr(\"Rectangular Region\"), CaptureRequest::GRAPHICAL_MODE);\n\n#if defined(Q_OS_MACOS)\n    // Following to MacOS philosophy (one application cannot be displayed on\n    // more than one display)\n    ui-&gt;captureType-&gt;insertItem(\n      2, tr(\"Full Screen (Current Display)\"), CaptureRequest::FULLSCREEN_MODE);\n#else\n    ui-&gt;captureType-&gt;insertItem(\n      2, tr(\"Full Screen (All Monitors)\"), CaptureRequest::FULLSCREEN_MODE);\n#endif\n\n    ui-&gt;delayTime-&gt;setSpecialValueText(tr(\"No Delay\"));\n    ui-&gt;launchButton-&gt;setFocus();\n\n    // Function to add or remove plural to seconds\n    connect(ui-&gt;delayTime,\n            static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            [this](int val) {\n                QString suffix = val == 1 ? tr(\" second\") : tr(\" seconds\");\n                this-&gt;ui-&gt;delayTime-&gt;setSuffix(suffix);\n            });\n\n    connect(ui-&gt;launchButton,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;CaptureLauncher::startCapture);\n\n    connect(ui-&gt;captureType,\n            QOverload&lt;int&gt;::of(&amp;QComboBox::currentIndexChanged),\n            this,\n            [this]() {\n                auto mode = static_cast&lt;CaptureRequest::CaptureMode&gt;(\n                  ui-&gt;captureType-&gt;currentData().toInt());\n                if (mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE) {\n                    ui-&gt;sizeLabel-&gt;show();\n                    ui-&gt;screenshotX-&gt;show();\n                    ui-&gt;screenshotY-&gt;show();\n                    ui-&gt;screenshotWidth-&gt;show();\n                    ui-&gt;screenshotHeight-&gt;show();\n                } else {\n                    ui-&gt;sizeLabel-&gt;hide();\n                    ui-&gt;screenshotX-&gt;hide();\n                    ui-&gt;screenshotY-&gt;hide();\n                    ui-&gt;screenshotWidth-&gt;hide();\n                    ui-&gt;screenshotHeight-&gt;hide();\n                }\n            });\n\n    auto lastRegion = getLastRegion();\n    ui-&gt;screenshotX-&gt;setText(QString::number(lastRegion.x()));\n    ui-&gt;screenshotY-&gt;setText(QString::number(lastRegion.y()));\n    ui-&gt;screenshotWidth-&gt;setText(QString::number(lastRegion.width()));\n    ui-&gt;screenshotHeight-&gt;setText(QString::number(lastRegion.height()));\n    show();\n}\n\n// HACK:\n// https://github.com/KDE/spectacle/blob/fa1e780b8bf3df3ac36c410b9ece4ace041f401b/src/Gui/KSMainWindow.cpp#L70\nvoid CaptureLauncher::startCapture()\n{\n    ui-&gt;launchButton-&gt;setEnabled(false);\n    hide();\n\n    auto const additionalDelayToHideUI = 600;\n    auto const secondsToMilliseconds = 1000;\n    auto mode = static_cast&lt;CaptureRequest::CaptureMode&gt;(\n      ui-&gt;captureType-&gt;currentData().toInt());\n    CaptureRequest req(mode,\n                       additionalDelayToHideUI +\n                         ui-&gt;delayTime-&gt;value() * secondsToMilliseconds);\n\n    if (mode == CaptureRequest::CaptureMode::GRAPHICAL_MODE) {\n        req.setInitialSelection(QRect(ui-&gt;screenshotX-&gt;text().toInt(),\n                                      ui-&gt;screenshotY-&gt;text().toInt(),\n                                      ui-&gt;screenshotWidth-&gt;text().toInt(),\n                                      ui-&gt;screenshotHeight-&gt;text().toInt()));\n    }\n\n    connectCaptureSlots();\n    Flameshot::instance()-&gt;requestCapture(req);\n}\n\nvoid CaptureLauncher::connectCaptureSlots() const\n{\n    connect(Flameshot::instance(),\n            &amp;Flameshot::captureTaken,\n            this,\n            &amp;CaptureLauncher::onCaptureTaken);\n    connect(Flameshot::instance(),\n            &amp;Flameshot::captureFailed,\n            this,\n            &amp;CaptureLauncher::onCaptureFailed);\n}\n\nvoid CaptureLauncher::disconnectCaptureSlots() const\n{\n    // Hack for MacOS\n    // for some strange reasons MacOS sends multiple \"captureTaken\" signals\n    // (random number, usually from 1 up to 20).\n    // So now it enables signal on \"Capture new screenshot\" button and disables\n    // on first success of fail.\n    disconnect(Flameshot::instance(),\n               &amp;Flameshot::captureTaken,\n               this,\n               &amp;CaptureLauncher::onCaptureTaken);\n    disconnect(Flameshot::instance(),\n               &amp;Flameshot::captureFailed,\n               this,\n               &amp;CaptureLauncher::onCaptureFailed);\n}\n\nvoid CaptureLauncher::onCaptureTaken(QPixmap const&amp; screenshot)\n{\n    // MacOS specific, more details in the function disconnectCaptureSlots()\n    disconnectCaptureSlots();\n\n    ui-&gt;imagePreview-&gt;setScreenshot(screenshot);\n    show();\n\n    auto mode = static_cast&lt;CaptureRequest::CaptureMode&gt;(\n      ui-&gt;captureType-&gt;currentData().toInt());\n\n    if (mode == CaptureRequest::FULLSCREEN_MODE) {\n        saveToFilesystemGUI(screenshot);\n    }\n    ui-&gt;launchButton-&gt;setEnabled(true);\n}\n\nvoid CaptureLauncher::onCaptureFailed()\n{\n    // MacOS specific, more details in the function disconnectCaptureSlots()\n    disconnectCaptureSlots();\n    show();\n    ui-&gt;launchButton-&gt;setEnabled(true);\n}\n\nCaptureLauncher::~CaptureLauncher()\n{\n    delete ui;\n}\n\n</code></pre>"},{"location":"flameshot/capturelauncher_8h/","title":"File capturelauncher.h","text":"<p>FileList &gt; src &gt; widgets &gt; capturelauncher.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QDialog&gt;</code></li> </ul>"},{"location":"flameshot/capturelauncher_8h/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"flameshot/capturelauncher_8h/#classes","title":"Classes","text":"Type Name class CaptureLauncher"},{"location":"flameshot/capturelauncher_8h_source/","title":"File capturelauncher.h","text":"<p>File List &gt; src &gt; widgets &gt; capturelauncher.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2018 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QDialog&gt;\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass CaptureLauncher;\n}\nQT_END_NAMESPACE\n\nclass CaptureLauncher : public QDialog\n{\n    Q_OBJECT\n\npublic:\n    explicit CaptureLauncher(QDialog* parent = nullptr);\n    ~CaptureLauncher();\n\nprivate:\n    Ui::CaptureLauncher* ui;\n    void connectCaptureSlots() const;\n    void disconnectCaptureSlots() const;\n\nprivate slots:\n    void startCapture();\n    void onCaptureTaken(QPixmap const&amp; p);\n    void onCaptureFailed();\n};\n\n</code></pre>"},{"location":"flameshot/colorpickerwidget_8cpp/","title":"File colorpickerwidget.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; colorpickerwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"colorpickerwidget.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> </ul>"},{"location":"flameshot/colorpickerwidget_8cpp_source/","title":"File colorpickerwidget.cpp","text":"<p>File List &gt; src &gt; widgets &gt; colorpickerwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2022 Dearsh Oberoi\n\n#include \"colorpickerwidget.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QMouseEvent&gt;\n#include &lt;QPainter&gt;\n\nColorPickerWidget::ColorPickerWidget(QWidget* parent)\n  : QWidget(parent)\n  , m_selectedIndex(1)\n  , m_lastIndex(1)\n{\n    initColorPicker();\n}\n\nconst QVector&lt;QColor&gt;&amp; ColorPickerWidget::getDefaultSmallColorPalette()\n{\n    return defaultSmallColorPalette;\n}\n\nconst QVector&lt;QColor&gt;&amp; ColorPickerWidget::getDefaultLargeColorPalette()\n{\n    return defaultLargeColorPalette;\n}\n\nvoid ColorPickerWidget::paintEvent(QPaintEvent* e)\n{\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n    painter.setPen(QColor(Qt::black));\n\n    for (int i = 0; i &lt; m_colorAreaList.size(); ++i) {\n        if (e-&gt;region().contains(m_colorAreaList.at(i))) {\n            painter.setClipRegion(e-&gt;region());\n            repaint(i, painter);\n        }\n    }\n}\n\nvoid ColorPickerWidget::repaint(int i, QPainter&amp; painter)\n{\n    // draw the highlight when we have to draw the selected color\n    if (i == m_selectedIndex) {\n        auto c = QColor(m_uiColor);\n        c.setAlpha(155);\n        painter.setBrush(c);\n        c.setAlpha(100);\n        painter.setPen(c);\n        QRect highlight = m_colorAreaList.at(i);\n        const int highlightThickness = 6;\n\n        // makes the highlight and color circles concentric\n        highlight.moveTo(highlight.x() - (highlightThickness / 2),\n                         highlight.y() - (highlightThickness / 2));\n\n        highlight.setHeight(highlight.height() + highlightThickness);\n        highlight.setWidth(highlight.width() + highlightThickness);\n        painter.drawRoundedRect(highlight, 100, 100);\n        painter.setPen(QColor(Qt::black));\n    }\n\n    // draw available colors\n    if (m_colorList.at(i).isValid()) {\n        // draw preset color\n        painter.setBrush(QColor(m_colorList.at(i)));\n        painter.drawRoundedRect(m_colorAreaList.at(i), 100, 100);\n    } else {\n        // draw rainbow (part) for custom color\n        QRect lastRect = m_colorAreaList.at(i);\n        int nStep = 1;\n        int nSteps = lastRect.height() / nStep;\n        // 0.02 - start rainbow color, 0.33 - end rainbow color from range:\n        // 0.0 - 1.0\n        float h = 0.02;\n        for (int radius = nSteps; radius &gt; 0; radius -= nStep * 2) {\n            // calculate color\n            float fHStep = (0.33 - h) / (nSteps / nStep / 2);\n            QColor color = QColor::fromHslF(h, 0.95, 0.5);\n\n            // set color and draw circle\n            painter.setPen(color);\n            painter.setBrush(color);\n            painter.drawRoundedRect(lastRect, 100, 100);\n\n            // set next color, circle geometry\n            h += fHStep;\n            lastRect.setX(lastRect.x() + nStep);\n            lastRect.setY(lastRect.y() + nStep);\n            lastRect.setHeight(lastRect.height() - nStep);\n            lastRect.setWidth(lastRect.width() - nStep);\n\n            painter.setPen(QColor(Qt::black));\n        }\n    }\n}\n\nvoid ColorPickerWidget::updateSelection(int index)\n{\n    m_selectedIndex = index;\n    update(m_colorAreaList.at(index) + QMargins(10, 10, 10, 10));\n    update(m_colorAreaList.at(m_lastIndex) + QMargins(10, 10, 10, 10));\n    m_lastIndex = index;\n}\n\nvoid ColorPickerWidget::updateWidget()\n{\n    m_colorAreaList.clear();\n    initColorPicker();\n    update();\n}\n\nvoid ColorPickerWidget::initColorPicker()\n{\n    ConfigHandler config;\n    m_colorList = config.userColors();\n    m_colorAreaSize = GlobalValues::buttonBaseSize() * 0.6;\n    // save the color values in member variables for faster access\n    m_uiColor = config.uiColor();\n\n    // extraSize represents the extra space needed for the highlight of the\n    // selected color.\n    const int extraSize = 6;\n    const double slope = 3;\n    double radius = slope * m_colorList.size() + GlobalValues::buttonBaseSize();\n    setMinimumSize(radius * 2 + m_colorAreaSize + extraSize,\n                   radius * 2 + m_colorAreaSize + extraSize);\n    resize(radius * 2 + m_colorAreaSize + extraSize,\n           radius * 2 + m_colorAreaSize + extraSize);\n    double degree = (double)360 / m_colorList.size();\n    double degreeAcum = 90;\n    // this line is the radius of the circle which will be rotated to add\n    // the color components.\n    QLineF baseLine =\n      QLineF(QPoint(radius + extraSize / 2, radius + extraSize / 2),\n             QPoint(radius + extraSize / 2, extraSize / 2));\n\n    for (int i = 0; i &lt; m_colorList.size(); ++i) {\n        m_colorAreaList.append(QRect(\n          baseLine.x2(), baseLine.y2(), m_colorAreaSize, m_colorAreaSize));\n        degreeAcum += degree;\n        baseLine.setAngle(degreeAcum);\n    }\n}\n\nQVector&lt;QColor&gt; ColorPickerWidget::defaultSmallColorPalette = {\n    QColor(),      Qt::darkRed, Qt::red,  Qt::yellow,  Qt::green,\n    Qt::darkGreen, Qt::cyan,    Qt::blue, Qt::magenta, Qt::darkMagenta\n};\n\nQVector&lt;QColor&gt; ColorPickerWidget::defaultLargeColorPalette = {\n    QColor(),        Qt::white,     Qt::red,       Qt::green,     Qt::blue,\n    Qt::black,       Qt::darkRed,   Qt::darkGreen, Qt::darkBlue,  Qt::darkGray,\n    Qt::cyan,        Qt::magenta,   Qt::yellow,    Qt::lightGray, Qt::darkCyan,\n    Qt::darkMagenta, Qt::darkYellow\n};\n\n</code></pre>"},{"location":"flameshot/colorpickerwidget_8h/","title":"File colorpickerwidget.h","text":"<p>FileList &gt; src &gt; widgets &gt; colorpickerwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/colorpickerwidget_8h/#classes","title":"Classes","text":"Type Name class ColorPickerWidget"},{"location":"flameshot/colorpickerwidget_8h_source/","title":"File colorpickerwidget.h","text":"<p>File List &gt; src &gt; widgets &gt; colorpickerwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2022 Dearsh Oberoi\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass ColorPickerWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit ColorPickerWidget(QWidget* parent = nullptr);\n\n    static const QVector&lt;QColor&gt;&amp; getDefaultSmallColorPalette();\n    static const QVector&lt;QColor&gt;&amp; getDefaultLargeColorPalette();\n    void updateWidget();\n    void updateSelection(int index);\n\nprotected:\n    void paintEvent(QPaintEvent* event) override;\n    void repaint(int i, QPainter&amp; painter);\n\n    int m_colorAreaSize;\n    int m_selectedIndex, m_lastIndex;\n    QVector&lt;QRect&gt; m_colorAreaList;\n    QVector&lt;QColor&gt; m_colorList;\n\n    QColor m_uiColor;\n\nprivate:\n    void initColorPicker();\n    static QVector&lt;QColor&gt; defaultSmallColorPalette, defaultLargeColorPalette;\n};\n\n</code></pre>"},{"location":"flameshot/draggablewidgetmaker_8cpp/","title":"File draggablewidgetmaker.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; draggablewidgetmaker.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"draggablewidgetmaker.h\"</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> </ul>"},{"location":"flameshot/draggablewidgetmaker_8cpp_source/","title":"File draggablewidgetmaker.cpp","text":"<p>File List &gt; src &gt; widgets &gt; draggablewidgetmaker.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"draggablewidgetmaker.h\"\n#include &lt;QMouseEvent&gt;\n\nDraggableWidgetMaker::DraggableWidgetMaker(QObject* parent)\n  : QObject(parent)\n{}\n\nvoid DraggableWidgetMaker::makeDraggable(QWidget* widget)\n{\n    widget-&gt;installEventFilter(this);\n}\n\nbool DraggableWidgetMaker::eventFilter(QObject* obj, QEvent* event)\n{\n    auto* widget = static_cast&lt;QWidget*&gt;(obj);\n\n    // based on https://stackoverflow.com/a/12221360/964478\n    switch (event-&gt;type()) {\n        case QEvent::MouseButtonPress: {\n            auto* mouseEvent = static_cast&lt;QMouseEvent*&gt;(event);\n\n            m_isPressing = false;\n            m_isDragging = false;\n            if (mouseEvent-&gt;button() == Qt::LeftButton) {\n                m_isPressing = true;\n                m_mousePressPos = mouseEvent-&gt;globalPos();\n                m_mouseMovePos = m_mousePressPos;\n            }\n        } break;\n        case QEvent::MouseMove: {\n            auto* mouseEvent = static_cast&lt;QMouseEvent*&gt;(event);\n\n            if (m_isPressing) {\n                QPoint widgetPos = widget-&gt;mapToGlobal(widget-&gt;pos());\n                QPoint eventPos = mouseEvent-&gt;globalPos();\n                QPoint diff = eventPos - m_mouseMovePos;\n                QPoint newPos = widgetPos + diff;\n\n                widget-&gt;move(widget-&gt;mapFromGlobal(newPos));\n\n                if (!m_isDragging) {\n                    QPoint totalMovedDiff = eventPos - m_mousePressPos;\n                    if (totalMovedDiff.manhattanLength() &gt; 3) {\n                        m_isDragging = true;\n                    }\n                }\n\n                m_mouseMovePos = eventPos;\n            }\n        } break;\n        case QEvent::MouseButtonRelease: {\n            m_isPressing = false;\n            if (m_isDragging) {\n                m_isDragging = false;\n                event-&gt;ignore();\n                return true;\n            }\n        } break;\n        default:\n            break;\n    }\n\n    return QObject::eventFilter(obj, event);\n}\n\n</code></pre>"},{"location":"flameshot/draggablewidgetmaker_8h/","title":"File draggablewidgetmaker.h","text":"<p>FileList &gt; src &gt; widgets &gt; draggablewidgetmaker.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QEvent&gt;</code></li> <li><code>#include &lt;QObject&gt;</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/draggablewidgetmaker_8h/#classes","title":"Classes","text":"Type Name class DraggableWidgetMaker"},{"location":"flameshot/draggablewidgetmaker_8h_source/","title":"File draggablewidgetmaker.h","text":"<p>File List &gt; src &gt; widgets &gt; draggablewidgetmaker.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QEvent&gt;\n#include &lt;QObject&gt;\n#include &lt;QPoint&gt;\n#include &lt;QWidget&gt;\n\nclass DraggableWidgetMaker : public QObject\n{\n    Q_OBJECT\npublic:\n    DraggableWidgetMaker(QObject* parent = nullptr);\n\n    void makeDraggable(QWidget* widget);\n\nprotected:\n    bool eventFilter(QObject* obj, QEvent* event) override;\n\nprivate:\n    bool m_isPressing = false;\n    bool m_isDragging = false;\n    QPoint m_mouseMovePos;\n    QPoint m_mousePressPos;\n};\n\n</code></pre>"},{"location":"flameshot/imagelabel_8cpp/","title":"File imagelabel.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; imagelabel.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"imagelabel.h\"</code></li> </ul>"},{"location":"flameshot/imagelabel_8cpp_source/","title":"File imagelabel.cpp","text":"<p>File List &gt; src &gt; widgets &gt; imagelabel.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// This code is a modified version of the KDE software Spectacle\n// /src/Gui/KSImageWidget.cpp commit cbbd6d45f6426ccbf1a82b15fdf98613ccccbbe9\n\n#include \"imagelabel.h\"\n\nImageLabel::ImageLabel(QWidget* parent)\n  : QLabel(parent)\n  , m_pixmap(QPixmap())\n{\n    m_DSEffect = new QGraphicsDropShadowEffect(this);\n\n    m_DSEffect-&gt;setBlurRadius(5);\n    m_DSEffect-&gt;setOffset(0);\n    m_DSEffect-&gt;setColor(QColor(Qt::black));\n\n    setGraphicsEffect(m_DSEffect);\n    setCursor(Qt::OpenHandCursor);\n    setAlignment(Qt::AlignCenter);\n    setMinimumSize(size());\n}\n\nvoid ImageLabel::setScreenshot(const QPixmap&amp; pixmap)\n{\n    m_pixmap = pixmap;\n    const QString tooltip =\n      QStringLiteral(\"%1x%2 px\").arg(m_pixmap.width()).arg(m_pixmap.height());\n    setToolTip(tooltip);\n    setScaledPixmap();\n}\n\nvoid ImageLabel::setScaledPixmap()\n{\n    const qreal scale = qApp-&gt;devicePixelRatio();\n    QPixmap scaledPixmap = m_pixmap.scaled(\n      size() * scale, Qt::KeepAspectRatio, Qt::SmoothTransformation);\n    scaledPixmap.setDevicePixelRatio(scale);\n    setPixmap(scaledPixmap);\n}\n\n// drag handlers\n\nvoid ImageLabel::mousePressEvent(QMouseEvent* event)\n{\n    if (event-&gt;button() == Qt::LeftButton) {\n        m_dragStartPosition = event-&gt;pos();\n        setCursor(Qt::ClosedHandCursor);\n    }\n}\n\nvoid ImageLabel::mouseReleaseEvent(QMouseEvent* event)\n{\n    if (event-&gt;button() == Qt::LeftButton) {\n        setCursor(Qt::OpenHandCursor);\n    }\n}\n\nvoid ImageLabel::mouseMoveEvent(QMouseEvent* event)\n{\n    if (!(event-&gt;buttons() &amp; Qt::LeftButton)) {\n        return;\n    }\n    if ((event-&gt;pos() - m_dragStartPosition).manhattanLength() &lt;\n        QGuiApplication::styleHints()-&gt;startDragDistance()) {\n        return;\n    }\n    setCursor(Qt::OpenHandCursor);\n    emit dragInitiated();\n}\n\n// resize handler\nvoid ImageLabel::resizeEvent(QResizeEvent* event)\n{\n    Q_UNUSED(event)\n    setScaledPixmap();\n}\n\n</code></pre>"},{"location":"flameshot/imagelabel_8h/","title":"File imagelabel.h","text":"<p>FileList &gt; src &gt; widgets &gt; imagelabel.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QColor&gt;</code></li> <li><code>#include &lt;QGraphicsDropShadowEffect&gt;</code></li> <li><code>#include &lt;QGuiApplication&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QMouseEvent&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> <li><code>#include &lt;QPoint&gt;</code></li> <li><code>#include &lt;QStyleHints&gt;</code></li> </ul>"},{"location":"flameshot/imagelabel_8h/#classes","title":"Classes","text":"Type Name class ImageLabel"},{"location":"flameshot/imagelabel_8h_source/","title":"File imagelabel.h","text":"<p>File List &gt; src &gt; widgets &gt; imagelabel.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// This code is a modified version of the KDE software Spectacle\n// /src/Gui/KSImageWidget.h commit cbbd6d45f6426ccbf1a82b15fdf98613ccccbbe9\n\n#pragma once\n\n#include &lt;QColor&gt;\n#include &lt;QGraphicsDropShadowEffect&gt;\n#include &lt;QGuiApplication&gt;\n#include &lt;QLabel&gt;\n#include &lt;QMouseEvent&gt;\n#include &lt;QPixmap&gt;\n#include &lt;QPoint&gt;\n#include &lt;QStyleHints&gt;\n\nclass ImageLabel : public QLabel\n{\n    Q_OBJECT\n\npublic:\n    explicit ImageLabel(QWidget* parent = nullptr);\n    void setScreenshot(const QPixmap&amp; pixmap);\n\nsignals:\n    void dragInitiated();\n\nprotected:\n    void mousePressEvent(QMouseEvent* event) Q_DECL_OVERRIDE;\n    void mouseReleaseEvent(QMouseEvent* event) Q_DECL_OVERRIDE;\n    void mouseMoveEvent(QMouseEvent* event) Q_DECL_OVERRIDE;\n    void resizeEvent(QResizeEvent* event) Q_DECL_OVERRIDE;\n\nprivate:\n    void setScaledPixmap();\n\n    QGraphicsDropShadowEffect* m_DSEffect;\n    QPixmap m_pixmap;\n    QPoint m_dragStartPosition;\n};\n\n</code></pre>"},{"location":"flameshot/imguploaddialog_8cpp/","title":"File imguploaddialog.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; imguploaddialog.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"imguploaddialog.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QCheckBox&gt;</code></li> <li><code>#include &lt;QDialogButtonBox&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/imguploaddialog_8cpp_source/","title":"File imguploaddialog.cpp","text":"<p>File List &gt; src &gt; widgets &gt; imguploaddialog.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"imguploaddialog.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QCheckBox&gt;\n#include &lt;QDialogButtonBox&gt;\n#include &lt;QLabel&gt;\n#include &lt;QVBoxLayout&gt;\n\nImgUploadDialog::ImgUploadDialog(QDialog* parent)\n  : QDialog(parent)\n{\n    setAttribute(Qt::WA_DeleteOnClose);\n    setMinimumSize(400, 120);\n    setWindowIcon(QIcon(GlobalValues::iconPath()));\n    setWindowTitle(tr(\"Upload Confirmation\"));\n\n    layout = new QVBoxLayout(this);\n\n    m_uploadLabel = new QLabel(tr(\"Do you want to upload this capture?\"), this);\n\n    layout-&gt;addWidget(m_uploadLabel);\n\n    buttonBox =\n      new QDialogButtonBox(QDialogButtonBox::Yes | QDialogButtonBox::No);\n\n    connect(buttonBox, &amp;QDialogButtonBox::accepted, this, &amp;QDialog::accept);\n    connect(buttonBox, &amp;QDialogButtonBox::rejected, this, &amp;QDialog::reject);\n\n    layout-&gt;addWidget(buttonBox);\n\n    m_uploadWithoutConfirmation =\n      new QCheckBox(tr(\"Upload without confirmation\"), this);\n    m_uploadWithoutConfirmation-&gt;setToolTip(tr(\"Upload without confirmation\"));\n    connect(m_uploadWithoutConfirmation, &amp;QCheckBox::clicked, [](bool checked) {\n        ConfigHandler().setUploadWithoutConfirmation(checked);\n    });\n\n    layout-&gt;addWidget(m_uploadWithoutConfirmation);\n}\n\n</code></pre>"},{"location":"flameshot/imguploaddialog_8h/","title":"File imguploaddialog.h","text":"<p>FileList &gt; src &gt; widgets &gt; imguploaddialog.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QDialog&gt;</code></li> </ul>"},{"location":"flameshot/imguploaddialog_8h/#classes","title":"Classes","text":"Type Name class ImgUploadDialog"},{"location":"flameshot/imguploaddialog_8h_source/","title":"File imguploaddialog.h","text":"<p>File List &gt; src &gt; widgets &gt; imguploaddialog.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QDialog&gt;\n\nclass QCheckBox;\nclass QLabel;\nclass QDialogButtonBox;\nclass QVBoxLayout;\n\nclass ImgUploadDialog : public QDialog\n{\n    Q_OBJECT\npublic:\n    explicit ImgUploadDialog(QDialog* parent = nullptr);\n\nprivate:\n    QCheckBox* m_uploadWithoutConfirmation;\n    QLabel* m_uploadLabel;\n    QDialogButtonBox* buttonBox;\n    QVBoxLayout* layout;\n};\n\n</code></pre>"},{"location":"flameshot/infowindow_8cpp/","title":"File infowindow.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; infowindow.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"infowindow.h\"</code></li> <li><code>#include \"./ui_infowindow.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> </ul>"},{"location":"flameshot/infowindow_8cpp/#public-functions","title":"Public Functions","text":"Type Name QString generateKernelString ()"},{"location":"flameshot/infowindow_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/infowindow_8cpp/#function-generatekernelstring","title":"function generateKernelString","text":"<pre><code>QString generateKernelString () \n</code></pre>"},{"location":"flameshot/infowindow_8cpp_source/","title":"File infowindow.cpp","text":"<p>File List &gt; src &gt; widgets &gt; infowindow.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021-2022 Jeremy Borgman &amp; Contributors\n\n#include \"infowindow.h\"\n#include \"./ui_infowindow.h\"\n#include \"src/core/flameshotdaemon.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/utils/globalvalues.h\"\n#include &lt;QKeyEvent&gt;\n#include &lt;QScreen&gt;\n\nInfoWindow::InfoWindow(QWidget* parent)\n  : QWidget(parent)\n  , ui(new Ui::InfoWindow)\n{\n    ui-&gt;setupUi(this);\n    setAttribute(Qt::WA_DeleteOnClose);\n\n    ui-&gt;IconSVG-&gt;setPixmap(QPixmap(GlobalValues::iconPath()));\n    ui-&gt;VersionDetails-&gt;setText(GlobalValues::versionInfo());\n    ui-&gt;OperatingSystemDetails-&gt;setText(generateKernelString());\n\n#if (QT_VERSION &gt;= QT_VERSION_CHECK(5, 10, 0))\n    QRect position = frameGeometry();\n    QScreen* screen = QGuiAppCurrentScreen().currentScreen();\n    position.moveCenter(screen-&gt;availableGeometry().center());\n    move(position.topLeft());\n#endif\n\n    show();\n}\n\nInfoWindow::~InfoWindow()\n{\n    delete ui;\n}\n\nvoid InfoWindow::keyPressEvent(QKeyEvent* event)\n{\n    if (event-&gt;key() == Qt::Key_Escape) {\n        close();\n    }\n}\n\nQString generateKernelString()\n{\n    QString kernelVersion =\n      QSysInfo::kernelType() + \": \" + QSysInfo::kernelVersion() + \"\\n\" +\n      QSysInfo::productType() + \": \" + QSysInfo::productVersion();\n    return kernelVersion;\n}\n\nvoid InfoWindow::on_CopyInfoButton_clicked()\n{\n    FlameshotDaemon::copyToClipboard(GlobalValues::versionInfo() + \"\\n\" +\n                                     generateKernelString());\n}\n\n</code></pre>"},{"location":"flameshot/infowindow_8h/","title":"File infowindow.h","text":"<p>FileList &gt; src &gt; widgets &gt; infowindow.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/infowindow_8h/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"flameshot/infowindow_8h/#classes","title":"Classes","text":"Type Name class InfoWindow"},{"location":"flameshot/infowindow_8h/#public-functions","title":"Public Functions","text":"Type Name QString generateKernelString ()"},{"location":"flameshot/infowindow_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/infowindow_8h/#function-generatekernelstring","title":"function generateKernelString","text":"<pre><code>QString generateKernelString () \n</code></pre>"},{"location":"flameshot/infowindow_8h_source/","title":"File infowindow.h","text":"<p>File List &gt; src &gt; widgets &gt; infowindow.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2021-2022 Jeremy Borgman &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass InfoWindow;\n}\nQT_END_NAMESPACE\n\nclass InfoWindow : public QWidget\n{\n    Q_OBJECT\n\npublic:\n    explicit InfoWindow(QWidget* parent = nullptr);\n    ~InfoWindow();\n\nprivate:\n    Ui::InfoWindow* ui;\n\nprotected:\n    void keyPressEvent(QKeyEvent* event);\n\nprivate slots:\n    void on_CopyInfoButton_clicked();\n};\n\nQString generateKernelString();\n\n</code></pre>"},{"location":"flameshot/loadspinner_8cpp/","title":"File loadspinner.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; loadspinner.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"loadspinner.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QPaintEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> </ul>"},{"location":"flameshot/loadspinner_8cpp/#macros","title":"Macros","text":"Type Name define OFFSET  5"},{"location":"flameshot/loadspinner_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/loadspinner_8cpp/#define-offset","title":"define OFFSET","text":"<pre><code>#define OFFSET 5\n</code></pre>"},{"location":"flameshot/loadspinner_8cpp_source/","title":"File loadspinner.cpp","text":"<p>File List &gt; src &gt; widgets &gt; loadspinner.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"loadspinner.h\"\n#include &lt;QApplication&gt;\n#include &lt;QPaintEvent&gt;\n#include &lt;QPainter&gt;\n#include &lt;QTimer&gt;\n\n#define OFFSET 5\n\nLoadSpinner::LoadSpinner(QWidget* parent)\n  : QWidget(parent)\n  , m_span(0)\n  , m_growing(true)\n{\n    setAttribute(Qt::WA_TranslucentBackground);\n    const int size = QApplication::fontMetrics().height() * 8;\n    setFixedSize(size, size);\n    updateFrame();\n    // init timer\n    m_timer = new QTimer(this);\n    connect(m_timer, &amp;QTimer::timeout, this, &amp;LoadSpinner::rotate);\n    m_timer-&gt;setInterval(30);\n}\n\nvoid LoadSpinner::setColor(const QColor&amp; c)\n{\n    m_color = c;\n}\n\nvoid LoadSpinner::setWidth(int w)\n{\n    setFixedSize(w, w);\n    updateFrame();\n}\n\nvoid LoadSpinner::setHeight(int h)\n{\n    setFixedSize(h, h);\n    updateFrame();\n}\n\nvoid LoadSpinner::start()\n{\n    m_timer-&gt;start();\n}\n\nvoid LoadSpinner::stop()\n{\n    m_timer-&gt;stop();\n}\n\nvoid LoadSpinner::paintEvent(QPaintEvent*)\n{\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing, true);\n    auto pen = QPen(m_color);\n\n    pen.setWidth(height() / 10);\n    painter.setPen(pen);\n    painter.setOpacity(0.2);\n    painter.drawArc(m_frame, 0, 5760);\n    painter.setOpacity(1.0);\n    painter.drawArc(m_frame, (m_startAngle * 16), (m_span * 16));\n}\n\nvoid LoadSpinner::rotate()\n{\n    const int advance = 3;\n    const int grow = 8;\n    if (m_growing) {\n        m_startAngle = (m_startAngle + advance) % 360;\n        m_span += grow;\n        if (m_span &gt; 260) {\n            m_growing = false;\n        }\n    } else {\n        m_startAngle = (m_startAngle + grow) % 360;\n        m_span = m_span + advance - grow;\n        if (m_span &lt; 10) {\n            m_growing = true;\n        }\n    }\n    update();\n}\n\nvoid LoadSpinner::updateFrame()\n{\n    m_frame =\n      QRect(OFFSET, OFFSET, width() - OFFSET * 2, height() - OFFSET * 2);\n}\n\n</code></pre>"},{"location":"flameshot/loadspinner_8h/","title":"File loadspinner.h","text":"<p>FileList &gt; src &gt; widgets &gt; loadspinner.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/loadspinner_8h/#classes","title":"Classes","text":"Type Name class LoadSpinner"},{"location":"flameshot/loadspinner_8h_source/","title":"File loadspinner.h","text":"<p>File List &gt; src &gt; widgets &gt; loadspinner.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass LoadSpinner : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit LoadSpinner(QWidget* parent = nullptr);\n\n    void setColor(const QColor&amp; c);\n    void setWidth(int w);\n    void setHeight(int h);\n    void start();\n    void stop();\n\nprotected:\n    void paintEvent(QPaintEvent*);\n\nprivate slots:\n    void rotate();\n\nprivate:\n    QColor m_color;\n    QTimer* m_timer;\n\n    int m_startAngle = 0;\n    int m_span = 180;\n    bool m_growing;\n\n    QRect m_frame;\n    void updateFrame();\n};\n\n</code></pre>"},{"location":"flameshot/notificationwidget_8cpp/","title":"File notificationwidget.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; notificationwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"notificationwidget.h\"</code></li> <li><code>#include &lt;QFrame&gt;</code></li> <li><code>#include &lt;QIcon&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QPropertyAnimation&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/notificationwidget_8cpp_source/","title":"File notificationwidget.cpp","text":"<p>File List &gt; src &gt; widgets &gt; notificationwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"notificationwidget.h\"\n#include &lt;QFrame&gt;\n#include &lt;QIcon&gt;\n#include &lt;QLabel&gt;\n#include &lt;QPropertyAnimation&gt;\n#include &lt;QTimer&gt;\n#include &lt;QVBoxLayout&gt;\n\nNotificationWidget::NotificationWidget(QWidget* parent)\n  : QWidget(parent)\n{\n    m_timer = new QTimer(this);\n    m_timer-&gt;setSingleShot(true);\n    m_timer-&gt;setInterval(7000);\n    connect(m_timer, &amp;QTimer::timeout, this, &amp;NotificationWidget::animatedHide);\n\n    m_content = new QFrame();\n    m_layout = new QVBoxLayout();\n    m_label = new QLabel(m_content);\n    m_label-&gt;hide();\n\n    m_showAnimation = new QPropertyAnimation(m_content, \"geometry\", this);\n    m_showAnimation-&gt;setDuration(300);\n\n    m_hideAnimation = new QPropertyAnimation(m_content, \"geometry\", this);\n    m_hideAnimation-&gt;setDuration(300);\n    connect(\n      m_hideAnimation, &amp;QPropertyAnimation::finished, m_label, &amp;QLabel::hide);\n\n    auto* mainLayout = new QVBoxLayout();\n    setLayout(mainLayout);\n\n    mainLayout-&gt;addWidget(m_content);\n    m_layout-&gt;addWidget(m_label, 0, Qt::AlignHCenter);\n    m_content-&gt;setLayout(m_layout);\n\n    setFixedHeight(40);\n}\n\nvoid NotificationWidget::showMessage(const QString&amp; msg)\n{\n    m_label-&gt;setText(msg);\n    m_label-&gt;show();\n    animatedShow();\n}\n\nvoid NotificationWidget::animatedShow()\n{\n    m_showAnimation-&gt;setStartValue(QRect(0, 0, width(), 0));\n    m_showAnimation-&gt;setEndValue(QRect(0, 0, width(), height()));\n    m_showAnimation-&gt;start();\n    m_timer-&gt;start();\n}\n\nvoid NotificationWidget::animatedHide()\n{\n    m_hideAnimation-&gt;setStartValue(QRect(0, 0, width(), height()));\n    m_hideAnimation-&gt;setEndValue(QRect(0, 0, width(), 0));\n    m_hideAnimation-&gt;start();\n}\n\n</code></pre>"},{"location":"flameshot/notificationwidget_8h/","title":"File notificationwidget.h","text":"<p>FileList &gt; src &gt; widgets &gt; notificationwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/notificationwidget_8h/#classes","title":"Classes","text":"Type Name class NotificationWidget"},{"location":"flameshot/notificationwidget_8h_source/","title":"File notificationwidget.h","text":"<p>File List &gt; src &gt; widgets &gt; notificationwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include &lt;QWidget&gt;\n\nclass QLabel;\nclass QTimer;\nclass QPropertyAnimation;\nclass QVBoxLayout;\nclass QFrame;\n\nclass NotificationWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit NotificationWidget(QWidget* parent = nullptr);\n\n    void showMessage(const QString&amp; msg);\n\nprivate:\n    QLabel* m_label;\n    QPropertyAnimation* m_showAnimation;\n    QPropertyAnimation* m_hideAnimation;\n    QVBoxLayout* m_layout;\n    QFrame* m_content;\n    QTimer* m_timer;\n\n    void animatedShow();\n    void animatedHide();\n};\n\n</code></pre>"},{"location":"flameshot/orientablepushbutton_8cpp/","title":"File orientablepushbutton.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; orientablepushbutton.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"orientablepushbutton.h\"</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QStyleOptionButton&gt;</code></li> <li><code>#include &lt;QStylePainter&gt;</code></li> </ul>"},{"location":"flameshot/orientablepushbutton_8cpp_source/","title":"File orientablepushbutton.cpp","text":"<p>File List &gt; src &gt; widgets &gt; orientablepushbutton.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// Based on https://stackoverflow.com/a/53135675/964478\n\n#include \"orientablepushbutton.h\"\n#include &lt;QPainter&gt;\n#include &lt;QStyleOptionButton&gt;\n#include &lt;QStylePainter&gt;\n\nOrientablePushButton::OrientablePushButton(QWidget* parent)\n  : CaptureButton(parent)\n{}\n\nOrientablePushButton::OrientablePushButton(const QString&amp; text, QWidget* parent)\n  : CaptureButton(text, parent)\n{}\n\nOrientablePushButton::OrientablePushButton(const QIcon&amp; icon,\n                                           const QString&amp; text,\n                                           QWidget* parent)\n  : CaptureButton(icon, text, parent)\n{}\n\nQSize OrientablePushButton::sizeHint() const\n{\n    QSize sh = QPushButton::sizeHint();\n\n    if (m_orientation != OrientablePushButton::Horizontal) {\n        sh.transpose();\n    }\n\n    return sh;\n}\n\nvoid OrientablePushButton::paintEvent(QPaintEvent* event)\n{\n    Q_UNUSED(event)\n\n    QStylePainter painter(this);\n    QStyleOptionButton option;\n    initStyleOption(&amp;option);\n\n    if (m_orientation == OrientablePushButton::VerticalTopToBottom) {\n        painter.rotate(90);\n        painter.translate(0, -1 * width());\n        option.rect = option.rect.transposed();\n    }\n\n    else if (m_orientation == OrientablePushButton::VerticalBottomToTop) {\n        painter.rotate(-90);\n        painter.translate(-1 * height(), 0);\n        option.rect = option.rect.transposed();\n    }\n\n    painter.drawControl(QStyle::CE_PushButton, option);\n}\n\nOrientablePushButton::Orientation OrientablePushButton::orientation() const\n{\n    return m_orientation;\n}\n\nvoid OrientablePushButton::setOrientation(\n  OrientablePushButton::Orientation orientation)\n{\n    m_orientation = orientation;\n}\n\n</code></pre>"},{"location":"flameshot/orientablepushbutton_8h/","title":"File orientablepushbutton.h","text":"<p>FileList &gt; src &gt; widgets &gt; orientablepushbutton.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"capture/capturebutton.h\"</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> </ul>"},{"location":"flameshot/orientablepushbutton_8h/#classes","title":"Classes","text":"Type Name class OrientablePushButton"},{"location":"flameshot/orientablepushbutton_8h_source/","title":"File orientablepushbutton.h","text":"<p>File List &gt; src &gt; widgets &gt; orientablepushbutton.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n// Based on https://stackoverflow.com/a/53135675/964478\n\n#pragma once\n\n#include \"capture/capturebutton.h\"\n#include &lt;QPushButton&gt;\n\nclass OrientablePushButton : public CaptureButton\n{\n    Q_OBJECT\npublic:\n    enum Orientation\n    {\n        Horizontal,\n        VerticalTopToBottom,\n        VerticalBottomToTop\n    };\n\n    OrientablePushButton(QWidget* parent = nullptr);\n    OrientablePushButton(const QString&amp; text, QWidget* parent = nullptr);\n    OrientablePushButton(const QIcon&amp; icon,\n                         const QString&amp; text,\n                         QWidget* parent = nullptr);\n\n    QSize sizeHint() const;\n\n    OrientablePushButton::Orientation orientation() const;\n    void setOrientation(OrientablePushButton::Orientation orientation);\n\nprotected:\n    void paintEvent(QPaintEvent* event);\n\nprivate:\n    Orientation m_orientation = Horizontal;\n};\n\n</code></pre>"},{"location":"flameshot/dir_e79db7da44a022b7c1e2f0b610359347/","title":"Dir panel","text":"<p>FileList &gt; panel</p>"},{"location":"flameshot/dir_e79db7da44a022b7c1e2f0b610359347/#files","title":"Files","text":"Type Name file colorgrabwidget.cpp file colorgrabwidget.h file sidepanelwidget.cpp file sidepanelwidget.h file utilitypanel.cpp file utilitypanel.h"},{"location":"flameshot/colorgrabwidget_8cpp/","title":"File colorgrabwidget.cpp","text":"<p>FileList &gt; panel &gt; colorgrabwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"colorgrabwidget.h\"</code></li> <li><code>#include \"sidepanelwidget.h\"</code></li> <li><code>#include \"colorutils.h\"</code></li> <li><code>#include \"confighandler.h\"</code></li> <li><code>#include \"overlaymessage.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QDebug&gt;</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QPainter&gt;</code></li> <li><code>#include &lt;QScreen&gt;</code></li> <li><code>#include &lt;QShortcut&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> </ul>"},{"location":"flameshot/colorgrabwidget_8cpp/#macros","title":"Macros","text":"Type Name define WIDTH1  77 define WIDTH2  165 define ZOOM1  11 define ZOOM2  15"},{"location":"flameshot/colorgrabwidget_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"flameshot/colorgrabwidget_8cpp/#define-width1","title":"define WIDTH1","text":"<pre><code>#define WIDTH1 77\n</code></pre>"},{"location":"flameshot/colorgrabwidget_8cpp/#define-width2","title":"define WIDTH2","text":"<pre><code>#define WIDTH2 165\n</code></pre>"},{"location":"flameshot/colorgrabwidget_8cpp/#define-zoom1","title":"define ZOOM1","text":"<pre><code>#define ZOOM1 11\n</code></pre>"},{"location":"flameshot/colorgrabwidget_8cpp/#define-zoom2","title":"define ZOOM2","text":"<pre><code>#define ZOOM2 15\n</code></pre>"},{"location":"flameshot/colorgrabwidget_8cpp_source/","title":"File colorgrabwidget.cpp","text":"<p>File List &gt; panel &gt; colorgrabwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"colorgrabwidget.h\"\n#include \"sidepanelwidget.h\"\n\n#include \"colorutils.h\"\n#include \"confighandler.h\"\n#include \"overlaymessage.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include &lt;QApplication&gt;\n#include &lt;QDebug&gt;\n#include &lt;QKeyEvent&gt;\n#include &lt;QPainter&gt;\n#include &lt;QScreen&gt;\n#include &lt;QShortcut&gt;\n#include &lt;QTimer&gt;\n#include &lt;stdexcept&gt;\n\n// Width (= height) and zoom level of the widget before the user clicks\n#define WIDTH1 77\n#define ZOOM1 11\n// Width (= height) and zoom level of the widget after the user clicks\n#define WIDTH2 165\n#define ZOOM2 15\n\n// NOTE: WIDTH1(2) should be divisible by ZOOM1(2) for best precision.\n//       WIDTH1 should be odd so the cursor can be centered on a pixel.\n\nColorGrabWidget::ColorGrabWidget(QPixmap* p, QWidget* parent)\n  : QWidget(parent)\n  , m_pixmap(p)\n  , m_mousePressReceived(false)\n  , m_extraZoomActive(false)\n  , m_magnifierActive(false)\n{\n    if (p == nullptr) {\n        throw std::logic_error(\"Pixmap must not be null\");\n    }\n    setAttribute(Qt::WA_DeleteOnClose);\n    // We don't need this widget to receive mouse events because we use\n    // eventFilter on other objects that do\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    setAttribute(Qt::WA_QuitOnClose, false);\n    // On Windows: don't activate the widget so CaptureWidget remains active\n    setAttribute(Qt::WA_ShowWithoutActivating);\n    setWindowFlags(Qt::BypassWindowManagerHint | Qt::WindowStaysOnTopHint |\n                   Qt::FramelessWindowHint | Qt::WindowDoesNotAcceptFocus);\n    setMouseTracking(true);\n}\n\nvoid ColorGrabWidget::startGrabbing()\n{\n    // NOTE: grabMouse() would prevent move events being received\n    // With this method we just need to make sure that mouse press and release\n    // events get consumed before they reach their target widget.\n    // This is undone in the destructor.\n    qApp-&gt;setOverrideCursor(Qt::CrossCursor);\n    qApp-&gt;installEventFilter(this);\n    OverlayMessage::pushKeyMap(\n      { { tr(\"Enter or Left Click\"), tr(\"Accept color\") },\n        { tr(\"Hold Left Click\"), tr(\"Precisely select color\") },\n        { tr(\"Space or Right Click\"), tr(\"Toggle magnifier\") },\n        { tr(\"Esc\"), tr(\"Cancel\") } });\n}\n\nQColor ColorGrabWidget::color()\n{\n    return m_color;\n}\n\nbool ColorGrabWidget::eventFilter(QObject*, QEvent* event)\n{\n    // Consume shortcut events and handle key presses from whole app\n    if (event-&gt;type() == QEvent::KeyPress ||\n        event-&gt;type() == QEvent::Shortcut) {\n        QKeySequence key = event-&gt;type() == QEvent::KeyPress\n                             ? static_cast&lt;QKeyEvent*&gt;(event)-&gt;key()\n                             : static_cast&lt;QShortcutEvent*&gt;(event)-&gt;key();\n        if (key == Qt::Key_Escape) {\n            emit grabAborted();\n            finalize();\n        } else if (key == Qt::Key_Return || key == Qt::Key_Enter) {\n            emit colorGrabbed(m_color);\n            finalize();\n        } else if (key == Qt::Key_Space &amp;&amp; !m_extraZoomActive) {\n            setMagnifierActive(!m_magnifierActive);\n        }\n        return true;\n    } else if (event-&gt;type() == QEvent::MouseMove) {\n        // NOTE: This relies on the fact that CaptureWidget tracks mouse moves\n\n        if (m_extraZoomActive &amp;&amp; !geometry().contains(cursorPos())) {\n            setExtraZoomActive(false);\n            return true;\n        }\n        if (!m_extraZoomActive &amp;&amp; !m_magnifierActive) {\n            // This fixes an issue when the mouse leaves the zoom area before\n            // the widget even appears.\n            hide();\n        }\n        if (!m_extraZoomActive) {\n            // Update only before the user clicks the mouse, after the mouse\n            // press the widget remains static.\n            updateWidget();\n        }\n\n        // Hide overlay message when cursor is over it\n        OverlayMessage* overlayMsg = OverlayMessage::instance();\n        overlayMsg-&gt;setVisibility(\n          !overlayMsg-&gt;geometry().contains(cursorPos()));\n\n        m_color = getColorAtPoint(cursorPos());\n        emit colorUpdated(m_color);\n        return true;\n    } else if (event-&gt;type() == QEvent::MouseButtonPress) {\n        m_mousePressReceived = true;\n        auto* e = static_cast&lt;QMouseEvent*&gt;(event);\n        if (e-&gt;buttons() == Qt::RightButton) {\n            setMagnifierActive(!m_magnifierActive);\n        } else if (e-&gt;buttons() == Qt::LeftButton) {\n            setExtraZoomActive(true);\n        }\n        return true;\n    } else if (event-&gt;type() == QEvent::MouseButtonRelease) {\n        if (!m_mousePressReceived) {\n            // Do not consume event if it corresponds to the mouse press that\n            // triggered the color grabbing in the first place. This prevents\n            // focus issues in the capture widget when the color grabber is\n            // closed.\n            return false;\n        }\n        auto* e = static_cast&lt;QMouseEvent*&gt;(event);\n        if (e-&gt;button() == Qt::LeftButton &amp;&amp; m_extraZoomActive) {\n            emit colorGrabbed(getColorAtPoint(cursorPos()));\n            finalize();\n        }\n        return true;\n    } else if (event-&gt;type() == QEvent::MouseButtonDblClick) {\n        return true;\n    }\n    return false;\n}\n\nvoid ColorGrabWidget::paintEvent(QPaintEvent*)\n{\n    QPainter painter(this);\n    painter.drawImage(QRectF(0, 0, width(), height()), m_previewImage);\n}\n\nvoid ColorGrabWidget::showEvent(QShowEvent*)\n{\n    updateWidget();\n}\n\nQPoint ColorGrabWidget::cursorPos() const\n{\n    return QCursor::pos(QGuiAppCurrentScreen().currentScreen());\n}\n\nQColor ColorGrabWidget::getColorAtPoint(const QPoint&amp; p) const\n{\n    if (m_extraZoomActive &amp;&amp; geometry().contains(p)) {\n        QPoint point = mapFromGlobal(p);\n        // we divide coordinate-wise to avoid rounding to nearest\n        return m_previewImage.pixel(\n          QPoint(point.x() / ZOOM2, point.y() / ZOOM2));\n    }\n    QPoint point = p;\n#if defined(Q_OS_MACOS)\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    if (currentScreen) {\n        point = QPoint((p.x() - currentScreen-&gt;geometry().x()) *\n                         currentScreen-&gt;devicePixelRatio(),\n                       (p.y() - currentScreen-&gt;geometry().y()) *\n                         currentScreen-&gt;devicePixelRatio());\n    }\n#endif\n    QPixmap pixel = m_pixmap-&gt;copy(QRect(point, point));\n    return pixel.toImage().pixel(0, 0);\n}\n\nvoid ColorGrabWidget::setExtraZoomActive(bool active)\n{\n    m_extraZoomActive = active;\n    if (!active &amp;&amp; !m_magnifierActive) {\n        hide();\n    } else {\n        if (!isVisible()) {\n            QTimer::singleShot(250, this, [this]() { show(); });\n        } else {\n            QTimer::singleShot(250, this, [this]() { updateWidget(); });\n        }\n    }\n}\n\nvoid ColorGrabWidget::setMagnifierActive(bool active)\n{\n    m_magnifierActive = active;\n    setVisible(active);\n}\n\nvoid ColorGrabWidget::updateWidget()\n{\n    int width = m_extraZoomActive ? WIDTH2 : WIDTH1;\n    float zoom = m_extraZoomActive ? ZOOM2 : ZOOM1;\n    // Set window size and move its center to the mouse cursor\n    QRect rect(0, 0, width, width);\n\n    auto realCursorPos = cursorPos();\n    auto adjustedCursorPos = realCursorPos;\n\n#if defined(Q_OS_MACOS)\n    QScreen* currentScreen = QGuiAppCurrentScreen().currentScreen();\n    if (currentScreen) {\n        adjustedCursorPos =\n          QPoint((realCursorPos.x() - currentScreen-&gt;geometry().x()) *\n                   currentScreen-&gt;devicePixelRatio(),\n                 (realCursorPos.y() - currentScreen-&gt;geometry().y()) *\n                   currentScreen-&gt;devicePixelRatio());\n    }\n#endif\n\n    rect.moveCenter(cursorPos());\n    setGeometry(rect);\n    // Store a pixmap containing the zoomed-in section around the cursor\n    QRect sourceRect(0, 0, width / zoom, width / zoom);\n    sourceRect.moveCenter(adjustedCursorPos);\n    m_previewImage = m_pixmap-&gt;copy(sourceRect).toImage();\n    // Repaint\n    update();\n}\n\nvoid ColorGrabWidget::finalize()\n{\n    qApp-&gt;removeEventFilter(this);\n    qApp-&gt;restoreOverrideCursor();\n    OverlayMessage::pop();\n    close();\n}\n\n</code></pre>"},{"location":"flameshot/colorgrabwidget_8h/","title":"File colorgrabwidget.h","text":"<p>FileList &gt; panel &gt; colorgrabwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/colorgrabwidget_8h/#classes","title":"Classes","text":"Type Name class ColorGrabWidget"},{"location":"flameshot/colorgrabwidget_8h_source/","title":"File colorgrabwidget.h","text":"<p>File List &gt; panel &gt; colorgrabwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#ifndef COLORGRABWIDGET_H\n#define COLORGRABWIDGET_H\n\n#include &lt;QWidget&gt;\n\nclass SidePanelWidget;\nclass OverlayMessage;\n\nclass ColorGrabWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    ColorGrabWidget(QPixmap* p, QWidget* parent = nullptr);\n\n    void startGrabbing();\n\n    QColor color();\n\nsignals:\n    void colorUpdated(const QColor&amp; color);\n    void colorGrabbed(const QColor&amp; color);\n    void grabAborted();\n\nprivate:\n    bool eventFilter(QObject* obj, QEvent* event) override;\n    void paintEvent(QPaintEvent* e) override;\n    void showEvent(QShowEvent* event) override;\n\n    QPoint cursorPos() const;\n    QColor getColorAtPoint(const QPoint&amp; point) const;\n    void setExtraZoomActive(bool active);\n    void setMagnifierActive(bool active);\n    void updateWidget();\n    void finalize();\n\n    QPixmap* m_pixmap;\n    QImage m_previewImage;\n    QColor m_color;\n\n    bool m_mousePressReceived;\n    bool m_extraZoomActive;\n    bool m_magnifierActive;\n};\n\n#endif // COLORGRABWIDGET_H\n\n</code></pre>"},{"location":"flameshot/sidepanelwidget_8cpp/","title":"File sidepanelwidget.cpp","text":"<p>FileList &gt; panel &gt; sidepanelwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"sidepanelwidget.h\"</code></li> <li><code>#include \"colorgrabwidget.h\"</code></li> <li><code>#include \"src/core/qguiappcurrentscreen.h\"</code></li> <li><code>#include \"src/utils/colorutils.h\"</code></li> <li><code>#include \"src/utils/pathinfo.h\"</code></li> <li><code>#include \"utilitypanel.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QCheckBox&gt;</code></li> <li><code>#include &lt;QKeyEvent&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QLineEdit&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QShortcut&gt;</code></li> <li><code>#include &lt;QSlider&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> </ul>"},{"location":"flameshot/sidepanelwidget_8cpp_source/","title":"File sidepanelwidget.cpp","text":"<p>File List &gt; panel &gt; sidepanelwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"sidepanelwidget.h\"\n#include \"colorgrabwidget.h\"\n#include \"src/core/qguiappcurrentscreen.h\"\n#include \"src/utils/colorutils.h\"\n#include \"src/utils/pathinfo.h\"\n#include \"utilitypanel.h\"\n#include &lt;QApplication&gt;\n#include &lt;QCheckBox&gt;\n#include &lt;QKeyEvent&gt;\n#include &lt;QLabel&gt;\n#include &lt;QLineEdit&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QShortcut&gt;\n#include &lt;QSlider&gt;\n#include &lt;QVBoxLayout&gt;\n#if defined(Q_OS_MACOS)\n#include &lt;QScreen&gt;\n#endif\n\nSidePanelWidget::SidePanelWidget(QPixmap* p, QWidget* parent)\n  : QWidget(parent)\n  , m_layout(new QVBoxLayout(this))\n  , m_pixmap(p)\n{\n\n    if (parent != nullptr) {\n        parent-&gt;installEventFilter(this);\n    }\n\n    auto* colorLayout = new QGridLayout();\n\n    // Create Active Tool Size\n    auto* toolSizeHBox = new QHBoxLayout();\n    auto* activeToolSizeText = new QLabel(tr(\"Active tool size: \"));\n\n    m_toolSizeSpin = new QSpinBox(this);\n    m_toolSizeSpin-&gt;setRange(1, maxToolSize);\n    m_toolSizeSpin-&gt;setSingleStep(1);\n    m_toolSizeSpin-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);\n\n    toolSizeHBox-&gt;addWidget(activeToolSizeText);\n    toolSizeHBox-&gt;addWidget(m_toolSizeSpin);\n\n    m_toolSizeSlider = new QSlider(Qt::Horizontal);\n    m_toolSizeSlider-&gt;setRange(1, maxToolSize);\n    m_toolSizeSlider-&gt;setValue(m_toolSize);\n    m_toolSizeSlider-&gt;setMinimumWidth(minSliderWidth);\n\n    colorLayout-&gt;addLayout(toolSizeHBox, 0, 0);\n    colorLayout-&gt;addWidget(m_toolSizeSlider, 1, 0);\n\n    // Create Active Color\n    auto* colorHBox = new QHBoxLayout();\n    auto* colorText = new QLabel(tr(\"Active Color: \"));\n\n    m_colorLabel = new QLabel();\n    m_colorLabel-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);\n\n    colorHBox-&gt;addWidget(colorText);\n    colorHBox-&gt;addWidget(m_colorLabel);\n    colorLayout-&gt;addLayout(colorHBox, 2, 0);\n\n    m_layout-&gt;addLayout(colorLayout);\n\n    m_colorWheel = new color_widgets::ColorWheel(this);\n    m_colorWheel-&gt;setColor(m_color);\n    m_colorHex = new QLineEdit(this);\n    m_colorHex-&gt;setAlignment(Qt::AlignCenter);\n\n    QColor background = this-&gt;palette().window().color();\n    bool isDark = ColorUtils::colorIsDark(background);\n    QString modifier =\n      isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();\n    QIcon grabIcon(modifier + \"colorize.svg\");\n    m_colorGrabButton = new QPushButton(grabIcon, tr(\"Grab Color\"));\n\n    m_layout-&gt;addWidget(m_colorGrabButton);\n    m_layout-&gt;addWidget(m_colorWheel);\n    m_layout-&gt;addWidget(m_colorHex);\n\n    QHBoxLayout* gridHBoxLayout = new QHBoxLayout(this);\n    m_gridCheck = new QCheckBox(tr(\"Display grid\"), this);\n    m_gridSizeSpin = new QSpinBox(this);\n    m_gridSizeSpin-&gt;setRange(5, 50);\n    m_gridSizeSpin-&gt;setSingleStep(5);\n    m_gridSizeSpin-&gt;setValue(10);\n    m_gridSizeSpin-&gt;setDisabled(true);\n    m_gridSizeSpin-&gt;setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);\n    gridHBoxLayout-&gt;addWidget(m_gridCheck);\n    gridHBoxLayout-&gt;addWidget(m_gridSizeSpin);\n    m_layout-&gt;addLayout(gridHBoxLayout);\n\n    // tool size sigslots\n    connect(m_toolSizeSpin,\n            static_cast&lt;void (QSpinBox::*)(int)&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            &amp;SidePanelWidget::toolSizeChanged);\n    connect(m_toolSizeSlider,\n            &amp;QSlider::valueChanged,\n            this,\n            &amp;SidePanelWidget::toolSizeChanged);\n    connect(this,\n            &amp;SidePanelWidget::toolSizeChanged,\n            this,\n            &amp;SidePanelWidget::onToolSizeChanged);\n    // color hex editor sigslots\n    connect(m_colorHex, &amp;QLineEdit::editingFinished, this, [=]() {\n        if (!QColor::isValidColor(m_colorHex-&gt;text())) {\n            m_colorHex-&gt;setText(m_color.name(QColor::HexRgb));\n        } else {\n            emit colorChanged(m_colorHex-&gt;text());\n        }\n    });\n    // color grab button sigslots\n    connect(m_colorGrabButton,\n            &amp;QPushButton::pressed,\n            this,\n            &amp;SidePanelWidget::startColorGrab);\n    // color wheel sigslots\n    //   re-emit ColorWheel::colorSelected as SidePanelWidget::colorChanged\n    connect(m_colorWheel,\n            &amp;color_widgets::ColorWheel::colorSelected,\n            this,\n            &amp;SidePanelWidget::colorChanged);\n    // Grid feature\n    connect(m_gridCheck, &amp;QCheckBox::clicked, this, [=](bool b) {\n        this-&gt;m_gridSizeSpin-&gt;setEnabled(b);\n        emit this-&gt;displayGridChanged(b);\n    });\n    connect(m_gridSizeSpin,\n            qOverload&lt;int&gt;(&amp;QSpinBox::valueChanged),\n            this,\n            &amp;SidePanelWidget::gridSizeChanged);\n}\n\nvoid SidePanelWidget::onColorChanged(const QColor&amp; color)\n{\n    m_color = color;\n    updateColorNoWheel(color);\n    m_colorWheel-&gt;setColor(color);\n}\n\nvoid SidePanelWidget::onToolSizeChanged(int t)\n{\n    m_toolSize = qBound(0, t, maxToolSize);\n    m_toolSizeSlider-&gt;setValue(m_toolSize);\n    m_toolSizeSpin-&gt;setValue(m_toolSize);\n}\n\nvoid SidePanelWidget::startColorGrab()\n{\n    m_revertColor = m_color;\n    m_colorGrabber = new ColorGrabWidget(m_pixmap);\n    connect(m_colorGrabber,\n            &amp;ColorGrabWidget::colorUpdated,\n            this,\n            &amp;SidePanelWidget::onTemporaryColorUpdated);\n    connect(m_colorGrabber,\n            &amp;ColorGrabWidget::colorGrabbed,\n            this,\n            &amp;SidePanelWidget::onColorGrabFinished);\n    connect(m_colorGrabber,\n            &amp;ColorGrabWidget::grabAborted,\n            this,\n            &amp;SidePanelWidget::onColorGrabAborted);\n\n    emit togglePanel();\n    m_colorGrabber-&gt;startGrabbing();\n}\n\nvoid SidePanelWidget::onColorGrabFinished()\n{\n    finalizeGrab();\n    m_color = m_colorGrabber-&gt;color();\n    emit colorChanged(m_color);\n}\n\nvoid SidePanelWidget::onColorGrabAborted()\n{\n    finalizeGrab();\n    // Restore color that was selected before we started grabbing\n    onColorChanged(m_revertColor);\n}\n\nvoid SidePanelWidget::onTemporaryColorUpdated(const QColor&amp; color)\n{\n    updateColorNoWheel(color);\n}\n\nvoid SidePanelWidget::finalizeGrab()\n{\n    emit togglePanel();\n}\n\nvoid SidePanelWidget::updateColorNoWheel(const QColor&amp; c)\n{\n    m_colorLabel-&gt;setStyleSheet(\n      QStringLiteral(\"QLabel { background-color : %1; }\").arg(c.name()));\n    m_colorHex-&gt;setText(c.name(QColor::HexRgb));\n}\n\nbool SidePanelWidget::eventFilter(QObject* obj, QEvent* event)\n{\n    if (event-&gt;type() == QEvent::ShortcutOverride) {\n        // Override Escape shortcut from CaptureWidget\n        auto* e = static_cast&lt;QKeyEvent*&gt;(event);\n        if (e-&gt;key() == Qt::Key_Escape &amp;&amp; m_colorHex-&gt;hasFocus()) {\n            m_colorHex-&gt;clearFocus();\n            e-&gt;accept();\n            return true;\n        }\n    } else if (event-&gt;type() == QEvent::MouseButtonPress) {\n        // Clicks outside of the Color Hex editor\n        m_colorHex-&gt;clearFocus();\n    }\n    return QWidget::eventFilter(obj, event);\n}\n\nvoid SidePanelWidget::hideEvent(QHideEvent* event)\n{\n    QWidget::hideEvent(event);\n    m_colorHex-&gt;clearFocus();\n}\n\n</code></pre>"},{"location":"flameshot/sidepanelwidget_8h/","title":"File sidepanelwidget.h","text":"<p>FileList &gt; panel &gt; sidepanelwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"QtColorWidgets/color_wheel.hpp\"</code></li> <li><code>#include &lt;QSpinBox&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/sidepanelwidget_8h/#classes","title":"Classes","text":"Type Name class SidePanelWidget"},{"location":"flameshot/sidepanelwidget_8h/#public-attributes","title":"Public Attributes","text":"Type Name constexpr int maxToolSize   = = 50 constexpr int minSliderWidth   = = 100"},{"location":"flameshot/sidepanelwidget_8h/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"flameshot/sidepanelwidget_8h/#variable-maxtoolsize","title":"variable maxToolSize","text":"<pre><code>constexpr int maxToolSize;\n</code></pre>"},{"location":"flameshot/sidepanelwidget_8h/#variable-minsliderwidth","title":"variable minSliderWidth","text":"<pre><code>constexpr int minSliderWidth;\n</code></pre>"},{"location":"flameshot/sidepanelwidget_8h_source/","title":"File sidepanelwidget.h","text":"<p>File List &gt; panel &gt; sidepanelwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"QtColorWidgets/color_wheel.hpp\"\n#include &lt;QSpinBox&gt;\n#include &lt;QWidget&gt;\n\nclass QVBoxLayout;\nclass QPushButton;\nclass QLabel;\nclass QLineEdit;\nclass ColorGrabWidget;\nclass QColorPickingEventFilter;\nclass QSlider;\nclass QCheckBox;\n\nconstexpr int maxToolSize = 50;\nconstexpr int minSliderWidth = 100;\n\nclass SidePanelWidget : public QWidget\n{\n    Q_OBJECT\n\n    friend class QColorPickingEventFilter;\n\npublic:\n    explicit SidePanelWidget(QPixmap* p, QWidget* parent = nullptr);\n\nsignals:\n    void colorChanged(const QColor&amp; color);\n    void toolSizeChanged(int size);\n    void togglePanel();\n    void displayGridChanged(bool display);\n    void gridSizeChanged(int size);\n\npublic slots:\n    void onToolSizeChanged(int tool);\n    void onColorChanged(const QColor&amp; color);\n\nprivate slots:\n    void startColorGrab();\n    void onColorGrabFinished();\n    void onColorGrabAborted();\n    void onTemporaryColorUpdated(const QColor&amp; color);\n\nprivate:\n    void finalizeGrab();\n    void updateColorNoWheel(const QColor&amp; color);\n\n    bool eventFilter(QObject* obj, QEvent* event) override;\n    void hideEvent(QHideEvent* event) override;\n\n    QVBoxLayout* m_layout;\n    QPushButton* m_colorGrabButton;\n    ColorGrabWidget* m_colorGrabber{};\n    color_widgets::ColorWheel* m_colorWheel;\n    QLabel* m_colorLabel;\n    QLineEdit* m_colorHex;\n    QPixmap* m_pixmap;\n    QColor m_color;\n    QColor m_revertColor;\n    QSpinBox* m_toolSizeSpin;\n    QSlider* m_toolSizeSlider;\n    int m_toolSize{};\n    QCheckBox* m_gridCheck{ nullptr };\n    QSpinBox* m_gridSizeSpin{ nullptr };\n};\n\n</code></pre>"},{"location":"flameshot/utilitypanel_8cpp/","title":"File utilitypanel.cpp","text":"<p>FileList &gt; panel &gt; utilitypanel.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"utilitypanel.h\"</code></li> <li><code>#include \"capturewidget.h\"</code></li> <li><code>#include &lt;QHBoxLayout&gt;</code></li> <li><code>#include &lt;QListWidget&gt;</code></li> <li><code>#include &lt;QPropertyAnimation&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QScrollArea&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> </ul>"},{"location":"flameshot/utilitypanel_8cpp_source/","title":"File utilitypanel.cpp","text":"<p>File List &gt; panel &gt; utilitypanel.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#include \"utilitypanel.h\"\n#include \"capturewidget.h\"\n#include &lt;QHBoxLayout&gt;\n#include &lt;QListWidget&gt;\n#include &lt;QPropertyAnimation&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QScrollArea&gt;\n#include &lt;QTimer&gt;\n\nUtilityPanel::UtilityPanel(CaptureWidget* captureWidget)\n  : QWidget(captureWidget)\n  , m_captureWidget(captureWidget)\n  , m_internalPanel(nullptr)\n  , m_upLayout(nullptr)\n  , m_bottomLayout(nullptr)\n  , m_layout(nullptr)\n  , m_showAnimation(nullptr)\n  , m_hideAnimation(nullptr)\n  , m_layersLayout(nullptr)\n  , m_captureTools(nullptr)\n  , m_buttonDelete(nullptr)\n  , m_buttonMoveUp(nullptr)\n  , m_buttonMoveDown(nullptr)\n{\n    initInternalPanel();\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    setCursor(Qt::ArrowCursor);\n\n    m_showAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this);\n    m_showAnimation-&gt;setEasingCurve(QEasingCurve::InOutQuad);\n    m_showAnimation-&gt;setDuration(300);\n\n    m_hideAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this);\n    m_hideAnimation-&gt;setEasingCurve(QEasingCurve::InOutQuad);\n    m_hideAnimation-&gt;setDuration(300);\n\n    connect(m_hideAnimation,\n            &amp;QPropertyAnimation::finished,\n            m_internalPanel,\n            &amp;QWidget::hide);\n\n#if (defined(Q_OS_WIN) || defined(Q_OS_MACOS))\n    move(0, 0);\n#endif\n    hide();\n}\n\nQWidget* UtilityPanel::toolWidget() const\n{\n    return m_toolWidget;\n}\n\nvoid UtilityPanel::setToolWidget(QWidget* widget)\n{\n    if (m_toolWidget != nullptr) {\n        m_toolWidget-&gt;hide();\n        m_toolWidget-&gt;setParent(this);\n        m_toolWidget-&gt;deleteLater();\n    }\n    if (widget != nullptr) {\n        m_toolWidget = widget;\n        m_toolWidget-&gt;setSizePolicy(QSizePolicy::Ignored,\n                                    QSizePolicy::Preferred);\n        m_upLayout-&gt;addWidget(widget);\n    }\n}\n\nvoid UtilityPanel::clearToolWidget()\n{\n    if (m_toolWidget != nullptr) {\n        m_toolWidget-&gt;deleteLater();\n    }\n}\n\nvoid UtilityPanel::pushWidget(QWidget* widget)\n{\n    m_layout-&gt;insertWidget(m_layout-&gt;count() - 1, widget);\n}\n\nvoid UtilityPanel::show()\n{\n    setAttribute(Qt::WA_TransparentForMouseEvents, false);\n    m_showAnimation-&gt;setStartValue(QRect(-width(), 0, 0, height()));\n    m_showAnimation-&gt;setEndValue(QRect(0, 0, width(), height()));\n    m_internalPanel-&gt;show();\n    m_showAnimation-&gt;start();\n#if (defined(Q_OS_WIN) || defined(Q_OS_MACOS))\n    move(0, 0);\n#endif\n    QWidget::show();\n}\n\nvoid UtilityPanel::hide()\n{\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    m_hideAnimation-&gt;setStartValue(QRect(0, 0, width(), height()));\n    m_hideAnimation-&gt;setEndValue(QRect(-width(), 0, 0, height()));\n    m_hideAnimation-&gt;start();\n    m_internalPanel-&gt;hide();\n    QWidget::hide();\n}\n\nvoid UtilityPanel::toggle()\n{\n    if (m_internalPanel-&gt;isHidden()) {\n        show();\n    } else {\n        hide();\n    }\n}\n\nvoid UtilityPanel::initInternalPanel()\n{\n    m_internalPanel = new QScrollArea(this);\n    m_internalPanel-&gt;setAttribute(Qt::WA_NoMousePropagation);\n    auto* widget = new QWidget();\n    m_internalPanel-&gt;setWidget(widget);\n    m_internalPanel-&gt;setWidgetResizable(true);\n\n    m_layout = new QVBoxLayout();\n    m_upLayout = new QVBoxLayout();\n    m_bottomLayout = new QVBoxLayout();\n    m_layersLayout = new QVBoxLayout();\n    m_layout-&gt;addLayout(m_upLayout);\n    m_layout-&gt;addLayout(m_bottomLayout);\n    m_bottomLayout-&gt;addLayout(m_layersLayout);\n    widget-&gt;setLayout(m_layout);\n\n    QColor bgColor = palette().window().color();\n    bgColor.setAlphaF(0.0);\n    m_internalPanel-&gt;setStyleSheet(\n      QStringLiteral(\"QScrollArea {background-color: %1}\").arg(bgColor.name()));\n    m_internalPanel-&gt;hide();\n\n    m_captureTools = new QListWidget(this);\n    connect(m_captureTools,\n            &amp;QListWidget::currentRowChanged,\n            this,\n            &amp;UtilityPanel::onCurrentRowChanged);\n\n    auto* layersButtons = new QHBoxLayout();\n    m_layersLayout-&gt;addLayout(layersButtons);\n\n    m_layersLayout-&gt;addWidget(m_captureTools);\n\n    bool isDark = ColorUtils::colorIsDark(bgColor);\n    QString coloredIconPath =\n      isDark ? PathInfo::whiteIconPath() : PathInfo::blackIconPath();\n\n    m_buttonDelete = new QPushButton(this);\n    m_buttonDelete-&gt;setIcon(QIcon(coloredIconPath + \"delete.svg\"));\n    m_buttonDelete-&gt;setMinimumWidth(m_buttonDelete-&gt;height());\n    m_buttonDelete-&gt;setDisabled(true);\n\n    m_buttonMoveUp = new QPushButton(this);\n    m_buttonMoveUp-&gt;setIcon(QIcon(coloredIconPath + \"move_up.svg\"));\n    m_buttonMoveUp-&gt;setMinimumWidth(m_buttonMoveUp-&gt;height());\n    m_buttonMoveUp-&gt;setDisabled(true);\n\n    m_buttonMoveDown = new QPushButton(this);\n    m_buttonMoveDown-&gt;setIcon(QIcon(coloredIconPath + \"move_down.svg\"));\n    m_buttonMoveDown-&gt;setMinimumWidth(m_buttonMoveDown-&gt;height());\n    m_buttonMoveDown-&gt;setDisabled(true);\n\n    layersButtons-&gt;addWidget(m_buttonDelete);\n    layersButtons-&gt;addWidget(m_buttonMoveUp);\n    layersButtons-&gt;addWidget(m_buttonMoveDown);\n    layersButtons-&gt;addStretch();\n\n    connect(m_buttonDelete,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;UtilityPanel::slotButtonDelete);\n\n    connect(m_buttonMoveUp,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;UtilityPanel::slotUpClicked);\n\n    connect(m_buttonMoveDown,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;UtilityPanel::slotDownClicked);\n\n    // Bottom\n    auto* closeButton = new QPushButton(this);\n    closeButton-&gt;setText(tr(\"Close\"));\n    connect(closeButton, &amp;QPushButton::clicked, this, &amp;UtilityPanel::toggle);\n    m_bottomLayout-&gt;addWidget(closeButton);\n}\n\nvoid UtilityPanel::fillCaptureTools(\n  const QList&lt;QPointer&lt;CaptureTool&gt;&gt;&amp; captureToolObjects)\n{\n    int currentSelection = m_captureTools-&gt;currentRow();\n    m_captureTools-&gt;clear();\n    m_captureTools-&gt;addItem(tr(\"&lt;Empty&gt;\"));\n\n    for (auto toolItem : captureToolObjects) {\n        auto* item = new QListWidgetItem(\n          toolItem-&gt;icon(QColor(Qt::white), false), toolItem-&gt;info());\n        m_captureTools-&gt;addItem(item);\n    }\n    if (currentSelection &gt;= 0 &amp;&amp; currentSelection &lt; m_captureTools-&gt;count()) {\n        m_captureTools-&gt;setCurrentRow(currentSelection);\n    }\n}\n\nvoid UtilityPanel::setActiveLayer(int index)\n{\n    Q_ASSERT(index &gt;= -1);\n    m_captureTools-&gt;setCurrentRow(index + 1);\n}\n\nint UtilityPanel::activeLayerIndex()\n{\n    return m_captureTools-&gt;currentRow() &gt;= 0 ? m_captureTools-&gt;currentRow() - 1\n                                             : -1;\n}\n\nvoid UtilityPanel::onCurrentRowChanged(int currentRow)\n{\n    m_buttonDelete-&gt;setDisabled(currentRow &lt;= 0);\n    m_buttonMoveDown-&gt;setDisabled(currentRow == 0 ||\n                                  currentRow + 1 == m_captureTools-&gt;count());\n    m_buttonMoveUp-&gt;setDisabled(currentRow &lt;= 1);\n\n    emit layerChanged(activeLayerIndex());\n}\n\nvoid UtilityPanel::slotUpClicked(bool clicked)\n{\n    Q_UNUSED(clicked);\n    // subtract 1 because there's &lt;empty&gt; in m_captureTools as [0] element\n    int toolRow = m_captureTools-&gt;currentRow() - 1;\n    m_captureTools-&gt;setCurrentRow(toolRow);\n    emit moveUpClicked(toolRow);\n}\n\nvoid UtilityPanel::slotDownClicked(bool clicked)\n{\n    Q_UNUSED(clicked);\n    // subtract 1 because there's &lt;empty&gt; in m_captureTools as [0] element\n    int toolRow = m_captureTools-&gt;currentRow() - 1;\n    m_captureTools-&gt;setCurrentRow(toolRow + 2);\n    emit moveDownClicked(toolRow);\n}\n\nvoid UtilityPanel::slotButtonDelete(bool clicked)\n{\n    Q_UNUSED(clicked)\n    int currentRow = m_captureTools-&gt;currentRow();\n    if (currentRow &gt; 0) {\n        m_captureWidget-&gt;removeToolObject(currentRow);\n        if (currentRow &gt;= m_captureTools-&gt;count()) {\n            currentRow = m_captureTools-&gt;count() - 1;\n        }\n    } else {\n        currentRow = 0;\n    }\n    m_captureTools-&gt;setCurrentRow(currentRow);\n}\n\nbool UtilityPanel::isVisible() const\n{\n    return !m_internalPanel-&gt;isHidden();\n}\n\n</code></pre>"},{"location":"flameshot/utilitypanel_8h/","title":"File utilitypanel.h","text":"<p>FileList &gt; panel &gt; utilitypanel.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"src/tools/capturetool.h\"</code></li> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/utilitypanel_8h/#classes","title":"Classes","text":"Type Name class UtilityPanel"},{"location":"flameshot/utilitypanel_8h_source/","title":"File utilitypanel.h","text":"<p>File List &gt; panel &gt; utilitypanel.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n// SPDX-License-Identifier: GPL-3.0-or-later\n// SPDX-FileCopyrightText: 2017-2019 Alejandro Sirgo Rica &amp; Contributors\n\n#pragma once\n\n#include \"src/tools/capturetool.h\"\n#include &lt;QPointer&gt;\n#include &lt;QWidget&gt;\n\nclass QVBoxLayout;\nclass QPropertyAnimation;\nclass QScrollArea;\nclass QPushButton;\nclass QListWidget;\nclass QPushButton;\nclass CaptureWidget;\n\nclass UtilityPanel : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit UtilityPanel(CaptureWidget* captureWidget);\n\n    [[nodiscard]] QWidget* toolWidget() const;\n    void setToolWidget(QWidget* weight);\n    void clearToolWidget();\n    void pushWidget(QWidget* widget);\n    void hide();\n    void show();\n    void fillCaptureTools(\n      const QList&lt;QPointer&lt;CaptureTool&gt;&gt;&amp; captureToolObjectsHistory);\n    void setActiveLayer(int index);\n    int activeLayerIndex();\n    bool isVisible() const;\n\nsignals:\n    void layerChanged(int layer);\n    void moveUpClicked(int currentRow);\n    void moveDownClicked(int currentRow);\n\npublic slots:\n    void toggle();\n    void slotButtonDelete(bool clicked);\n    void onCurrentRowChanged(int currentRow);\n\nprivate slots:\n    void slotUpClicked(bool clicked);\n    void slotDownClicked(bool clicked);\n\nprivate:\n    void initInternalPanel();\n\n    QPointer&lt;QWidget&gt; m_toolWidget;\n    QScrollArea* m_internalPanel;\n    QVBoxLayout* m_upLayout;\n    QVBoxLayout* m_bottomLayout;\n    QVBoxLayout* m_layout;\n    QPropertyAnimation* m_showAnimation;\n    QPropertyAnimation* m_hideAnimation;\n    QVBoxLayout* m_layersLayout;\n    QListWidget* m_captureTools;\n    QPushButton* m_buttonDelete;\n    QPushButton* m_buttonMoveUp;\n    QPushButton* m_buttonMoveDown;\n    CaptureWidget* m_captureWidget;\n};\n\n</code></pre>"},{"location":"flameshot/trayicon_8cpp/","title":"File trayicon.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; trayicon.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"trayicon.h\"</code></li> <li><code>#include \"src/core/flameshot.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> <li><code>#include \"src/utils/globalvalues.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QApplication&gt;</code></li> <li><code>#include &lt;QMenu&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;QVersionNumber&gt;</code></li> </ul>"},{"location":"flameshot/trayicon_8cpp_source/","title":"File trayicon.cpp","text":"<p>File List &gt; src &gt; widgets &gt; trayicon.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"trayicon.h\"\n\n#include \"src/core/flameshot.h\"\n#include \"src/core/flameshotdaemon.h\"\n#include \"src/utils/globalvalues.h\"\n\n#include \"src/utils/confighandler.h\"\n#include &lt;QApplication&gt;\n#include &lt;QMenu&gt;\n#include &lt;QTimer&gt;\n#include &lt;QUrl&gt;\n#include &lt;QVersionNumber&gt;\n\n#if defined(Q_OS_MACOS)\n#include &lt;QOperatingSystemVersion&gt;\n#endif\n\nTrayIcon::TrayIcon(QObject* parent)\n  : QSystemTrayIcon(parent)\n{\n    initMenu();\n\n    setToolTip(QStringLiteral(\"Flameshot\"));\n#if defined(Q_OS_MACOS)\n    // Because of the following issues on MacOS \"Catalina\":\n    // https://bugreports.qt.io/browse/QTBUG-86393\n    // https://developer.apple.com/forums/thread/126072\n    auto currentMacOsVersion = QOperatingSystemVersion::current();\n    if (currentMacOsVersion &gt;= currentMacOsVersion.MacOSBigSur) {\n        setContextMenu(m_menu);\n    }\n#else\n    setContextMenu(m_menu);\n#endif\n    QIcon icon =\n      QIcon::fromTheme(\"flameshot-tray\", QIcon(GlobalValues::iconPathPNG()));\n    setIcon(icon);\n\n#if defined(Q_OS_MACOS)\n    if (currentMacOsVersion &lt; currentMacOsVersion.MacOSBigSur) {\n        // Because of the following issues on MacOS \"Catalina\":\n        // https://bugreports.qt.io/browse/QTBUG-86393\n        // https://developer.apple.com/forums/thread/126072\n        auto trayIconActivated = [this](QSystemTrayIcon::ActivationReason r) {\n            if (m_menu-&gt;isVisible()) {\n                m_menu-&gt;hide();\n            } else {\n                m_menu-&gt;popup(QCursor::pos());\n            }\n        };\n        connect(this, &amp;QSystemTrayIcon::activated, this, trayIconActivated);\n    }\n#else\n    connect(this, &amp;TrayIcon::activated, this, [this](ActivationReason r) {\n        if (r == Trigger) {\n            startGuiCapture();\n        }\n    });\n#endif\n\n#ifdef Q_OS_WIN\n    // Ensure proper removal of tray icon when program quits on Windows.\n    connect(qApp, &amp;QCoreApplication::aboutToQuit, this, &amp;TrayIcon::hide);\n#endif\n\n    show(); // TODO needed?\n\n    if (ConfigHandler().showStartupLaunchMessage()) {\n        showMessage(\n          \"Flameshot\",\n          QObject::tr(\n            \"Hello, I'm here! Click icon in the tray to take a screenshot or \"\n            \"click with a right button to see more options.\"),\n          icon,\n          3000);\n    }\n\n    connect(ConfigHandler::getInstance(),\n            &amp;ConfigHandler::fileChanged,\n            this,\n            [this]() {});\n}\n\nTrayIcon::~TrayIcon()\n{\n    delete m_menu;\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nQAction* TrayIcon::appUpdates()\n{\n    return m_appUpdates;\n}\n#endif\n\nvoid TrayIcon::initMenu()\n{\n    m_menu = new QMenu();\n\n    auto* captureAction = new QAction(tr(\"&amp;Take Screenshot\"), this);\n    connect(captureAction, &amp;QAction::triggered, this, [this]() {\n#if defined(Q_OS_MACOS)\n        auto currentMacOsVersion = QOperatingSystemVersion::current();\n        if (currentMacOsVersion &gt;= currentMacOsVersion.MacOSBigSur) {\n            startGuiCapture();\n        } else {\n            // It seems it is not relevant for MacOS BigSur (Wait 400 ms to hide\n            // the QMenu)\n            QTimer::singleShot(400, this, [this]() { startGuiCapture(); });\n        }\n#else\n    // Wait 400 ms to hide the QMenu\n    QTimer::singleShot(400, this, [this]() {\n        startGuiCapture();\n    });\n#endif\n    });\n    auto* launcherAction = new QAction(tr(\"&amp;Open Launcher\"), this);\n    connect(launcherAction,\n            &amp;QAction::triggered,\n            Flameshot::instance(),\n            &amp;Flameshot::launcher);\n    auto* configAction = new QAction(tr(\"&amp;Configuration\"), this);\n    connect(configAction,\n            &amp;QAction::triggered,\n            Flameshot::instance(),\n            &amp;Flameshot::config);\n    auto* infoAction = new QAction(tr(\"&amp;About\"), this);\n    connect(\n      infoAction, &amp;QAction::triggered, Flameshot::instance(), &amp;Flameshot::info);\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n    m_appUpdates = new QAction(tr(\"Check for updates\"), this);\n    connect(m_appUpdates,\n            &amp;QAction::triggered,\n            FlameshotDaemon::instance(),\n            &amp;FlameshotDaemon::checkForUpdates);\n\n    connect(FlameshotDaemon::instance(),\n            &amp;FlameshotDaemon::newVersionAvailable,\n            this,\n            [this](const QVersionNumber&amp; version) {\n                QString newVersion =\n                  tr(\"New version %1 is available\").arg(version.toString());\n                m_appUpdates-&gt;setText(newVersion);\n            });\n#endif\n\n    QAction* quitAction = new QAction(tr(\"&amp;Quit\"), this);\n    connect(quitAction, &amp;QAction::triggered, qApp, &amp;QCoreApplication::quit);\n\n    // recent screenshots\n    QAction* recentAction = new QAction(tr(\"&amp;Latest Uploads\"), this);\n    connect(recentAction,\n            &amp;QAction::triggered,\n            Flameshot::instance(),\n            &amp;Flameshot::history);\n\n    auto* openSavePathAction = new QAction(tr(\"&amp;Open Save Path\"), this);\n    connect(openSavePathAction,\n            &amp;QAction::triggered,\n            Flameshot::instance(),\n            &amp;Flameshot::openSavePath);\n\n    m_menu-&gt;addAction(captureAction);\n    m_menu-&gt;addAction(launcherAction);\n    m_menu-&gt;addSeparator();\n    m_menu-&gt;addAction(recentAction);\n    m_menu-&gt;addAction(openSavePathAction);\n    m_menu-&gt;addSeparator();\n    m_menu-&gt;addAction(configAction);\n    m_menu-&gt;addSeparator();\n#if !defined(DISABLE_UPDATE_CHECKER)\n    m_menu-&gt;addAction(m_appUpdates);\n#endif\n    m_menu-&gt;addAction(infoAction);\n    m_menu-&gt;addSeparator();\n    m_menu-&gt;addAction(quitAction);\n}\n\n#if !defined(DISABLE_UPDATE_CHECKER)\nvoid TrayIcon::enableCheckUpdatesAction(bool enable)\n{\n    if (m_appUpdates != nullptr) {\n        m_appUpdates-&gt;setVisible(enable);\n        m_appUpdates-&gt;setEnabled(enable);\n    }\n    if (enable) {\n        FlameshotDaemon::instance()-&gt;getLatestAvailableVersion();\n    }\n}\n#endif\n\nvoid TrayIcon::startGuiCapture()\n{\n    auto* widget = Flameshot::instance()-&gt;gui();\n#if !defined(DISABLE_UPDATE_CHECKER)\n    FlameshotDaemon::instance()-&gt;showUpdateNotificationIfAvailable(widget);\n#endif\n}\n\n</code></pre>"},{"location":"flameshot/trayicon_8h/","title":"File trayicon.h","text":"<p>FileList &gt; src &gt; widgets &gt; trayicon.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QSystemTrayIcon&gt;</code></li> </ul>"},{"location":"flameshot/trayicon_8h/#classes","title":"Classes","text":"Type Name class TrayIcon"},{"location":"flameshot/trayicon_8h_source/","title":"File trayicon.h","text":"<p>File List &gt; src &gt; widgets &gt; trayicon.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include &lt;QSystemTrayIcon&gt;\n\n#pragma once\n\nclass QAction;\n\nclass TrayIcon : public QSystemTrayIcon\n{\n    Q_OBJECT\npublic:\n    TrayIcon(QObject* parent = nullptr);\n    virtual ~TrayIcon();\n\n#if !defined(DISABLE_UPDATE_CHECKER)\n    QAction* appUpdates();\n#endif\n\nprivate:\n    void initTrayIcon();\n    void initMenu();\n#if !defined(DISABLE_UPDATE_CHECKER)\n    void enableCheckUpdatesAction(bool enable);\n#endif\n\n    void startGuiCapture();\n\n    QMenu* m_menu;\n#if !defined(DISABLE_UPDATE_CHECKER)\n    QAction* m_appUpdates;\n#endif\n};\n\n</code></pre>"},{"location":"flameshot/updatenotificationwidget_8cpp/","title":"File updatenotificationwidget.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; updatenotificationwidget.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"updatenotificationwidget.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include &lt;QDesktopServices&gt;</code></li> <li><code>#include &lt;QLabel&gt;</code></li> <li><code>#include &lt;QPropertyAnimation&gt;</code></li> <li><code>#include &lt;QPushButton&gt;</code></li> <li><code>#include &lt;QScrollArea&gt;</code></li> <li><code>#include &lt;QTimer&gt;</code></li> <li><code>#include &lt;QVBoxLayout&gt;</code></li> <li><code>#include &lt;QWheelEvent&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"flameshot/updatenotificationwidget_8cpp_source/","title":"File updatenotificationwidget.cpp","text":"<p>File List &gt; src &gt; widgets &gt; updatenotificationwidget.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n//\n// Created by yuriypuchkov on 09.12.2020.\n//\n\n#include \"updatenotificationwidget.h\"\n#include \"src/utils/confighandler.h\"\n#include &lt;QDesktopServices&gt;\n#include &lt;QLabel&gt;\n#include &lt;QPropertyAnimation&gt;\n#include &lt;QPushButton&gt;\n#include &lt;QScrollArea&gt;\n#include &lt;QTimer&gt;\n#include &lt;QVBoxLayout&gt;\n#include &lt;QWheelEvent&gt;\n#include &lt;utility&gt;\n\nUpdateNotificationWidget::UpdateNotificationWidget(\n  QWidget* parent,\n  const QString&amp; appLatestVersion,\n  QString appLatestUrl)\n  : QWidget(parent)\n  , m_appLatestVersion(appLatestVersion)\n  , m_appLatestUrl(std::move(appLatestUrl))\n  , m_layout(nullptr)\n{\n    setMinimumSize(400, 100);\n    initInternalPanel();\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    setCursor(Qt::ArrowCursor);\n\n    m_showAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this);\n    m_showAnimation-&gt;setEasingCurve(QEasingCurve::InOutQuad);\n    m_showAnimation-&gt;setDuration(300);\n\n    m_hideAnimation = new QPropertyAnimation(m_internalPanel, \"geometry\", this);\n    m_hideAnimation-&gt;setEasingCurve(QEasingCurve::InOutQuad);\n    m_hideAnimation-&gt;setDuration(300);\n\n    connect(m_hideAnimation,\n            &amp;QPropertyAnimation::finished,\n            m_internalPanel,\n            &amp;QWidget::hide);\n    setAppLatestVersion(appLatestVersion);\n}\n\nvoid UpdateNotificationWidget::show()\n{\n    setAttribute(Qt::WA_TransparentForMouseEvents, false);\n    m_showAnimation-&gt;setStartValue(QRect(0, -height(), width(), height()));\n    m_showAnimation-&gt;setEndValue(QRect(0, 0, width(), height()));\n    m_internalPanel-&gt;show();\n    m_showAnimation-&gt;start();\n    QWidget::show();\n}\n\nvoid UpdateNotificationWidget::hide()\n{\n    setAttribute(Qt::WA_TransparentForMouseEvents);\n    m_hideAnimation-&gt;setStartValue(QRect(0, 0, width(), height()));\n    m_hideAnimation-&gt;setEndValue(QRect(0, -height(), 0, height()));\n    m_hideAnimation-&gt;start();\n    m_internalPanel-&gt;hide();\n    QWidget::hide();\n}\n\nvoid UpdateNotificationWidget::setAppLatestVersion(const QString&amp; latestVersion)\n{\n    m_appLatestVersion = latestVersion;\n    QString newVersion =\n      tr(\"New Flameshot version %1 is available\").arg(latestVersion);\n    m_notification-&gt;setText(newVersion);\n}\n\nvoid UpdateNotificationWidget::laterButton()\n{\n    hide();\n}\n\nvoid UpdateNotificationWidget::ignoreButton()\n{\n    ConfigHandler().setIgnoreUpdateToVersion(m_appLatestVersion);\n    hide();\n}\n\nvoid UpdateNotificationWidget::updateButton()\n{\n    QDesktopServices::openUrl(m_appLatestUrl);\n    hide();\n    if (parentWidget()) {\n        parentWidget()-&gt;close();\n    }\n}\n\nvoid UpdateNotificationWidget::initInternalPanel()\n{\n    m_internalPanel = new QScrollArea(this);\n    m_internalPanel-&gt;setAttribute(Qt::WA_NoMousePropagation);\n    auto* widget = new QWidget();\n    m_internalPanel-&gt;setWidget(widget);\n    m_internalPanel-&gt;setWidgetResizable(true);\n\n    QColor bgColor = palette().window().color();\n    bgColor.setAlphaF(0.0);\n    m_internalPanel-&gt;setStyleSheet(\n      QStringLiteral(\"QScrollArea {background-color: %1}\").arg(bgColor.name()));\n    m_internalPanel-&gt;hide();\n\n    //\n    m_layout = new QVBoxLayout();\n    widget-&gt;setLayout(m_layout);\n\n    // caption\n    m_notification = new QLabel(m_appLatestVersion, this);\n    m_layout-&gt;addWidget(m_notification);\n\n    // buttons layout\n    auto* buttonsLayout = new QHBoxLayout();\n    auto* bottonsSpacer = new QSpacerItem(1, 1, QSizePolicy::Expanding);\n    buttonsLayout-&gt;addSpacerItem(bottonsSpacer);\n    m_layout-&gt;addLayout(buttonsLayout);\n\n    // ignore\n    auto* ignoreBtn = new QPushButton(tr(\"Ignore\"), this);\n    buttonsLayout-&gt;addWidget(ignoreBtn);\n    connect(ignoreBtn,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;UpdateNotificationWidget::ignoreButton);\n\n    // later\n    auto* laterBtn = new QPushButton(tr(\"Later\"), this);\n    buttonsLayout-&gt;addWidget(laterBtn);\n    connect(laterBtn,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;UpdateNotificationWidget::laterButton);\n\n    // update\n    auto* updateBtn = new QPushButton(tr(\"Update\"), this);\n    buttonsLayout-&gt;addWidget(updateBtn);\n    connect(updateBtn,\n            &amp;QPushButton::clicked,\n            this,\n            &amp;UpdateNotificationWidget::updateButton);\n}\n\n</code></pre>"},{"location":"flameshot/updatenotificationwidget_8h/","title":"File updatenotificationwidget.h","text":"<p>FileList &gt; src &gt; widgets &gt; updatenotificationwidget.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QPointer&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/updatenotificationwidget_8h/#classes","title":"Classes","text":"Type Name class UpdateNotificationWidget"},{"location":"flameshot/updatenotificationwidget_8h_source/","title":"File updatenotificationwidget.h","text":"<p>File List &gt; src &gt; widgets &gt; updatenotificationwidget.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n//\n// Created by yuriypuchkov on 09.12.2020.\n//\n\n#ifndef FLAMESHOT_UPDATENOTIFICATIONWIDGET_H\n#define FLAMESHOT_UPDATENOTIFICATIONWIDGET_H\n\n#include &lt;QPointer&gt;\n#include &lt;QWidget&gt;\n\nclass QVBoxLayout;\nclass QPropertyAnimation;\nclass QScrollArea;\nclass QPushButton;\nclass QLabel;\n\nclass UpdateNotificationWidget : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit UpdateNotificationWidget(QWidget* parent,\n                                      const QString&amp; appLatestVersion,\n                                      QString appLatestUrl);\n    void setAppLatestVersion(const QString&amp; latestVersion);\n\n    void hide();\n    void show();\n\npublic slots:\n    void ignoreButton();\n    void laterButton();\n    void updateButton();\n\nprivate:\n    void initInternalPanel();\n\n    // class members\n    QString m_appLatestVersion;\n    QString m_appLatestUrl;\n    QVBoxLayout* m_layout;\n    QLabel* m_notification;\n    QScrollArea* m_internalPanel;\n    QPropertyAnimation* m_showAnimation;\n    QPropertyAnimation* m_hideAnimation;\n};\n\n#endif // FLAMESHOT_UPDATENOTIFICATIONWIDGET_H\n\n</code></pre>"},{"location":"flameshot/uploadhistory_8cpp/","title":"File uploadhistory.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; uploadhistory.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"uploadhistory.h\"</code></li> <li><code>#include \"./ui_uploadhistory.h\"</code></li> <li><code>#include \"src/tools/imgupload/imguploadermanager.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/history.h\"</code></li> <li><code>#include \"uploadlineitem.h\"</code></li> <li><code>#include &lt;QDateTime&gt;</code></li> <li><code>#include &lt;QDesktopWidget&gt;</code></li> <li><code>#include &lt;QFileInfo&gt;</code></li> <li><code>#include &lt;QPixmap&gt;</code></li> </ul>"},{"location":"flameshot/uploadhistory_8cpp/#public-functions","title":"Public Functions","text":"Type Name void clearHistoryLayout (QLayout * layout)  void scaleThumbnail (QPixmap &amp; pixmap)"},{"location":"flameshot/uploadhistory_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/uploadhistory_8cpp/#function-clearhistorylayout","title":"function clearHistoryLayout","text":"<pre><code>void clearHistoryLayout (\n    QLayout * layout\n) \n</code></pre>"},{"location":"flameshot/uploadhistory_8cpp/#function-scalethumbnail","title":"function scaleThumbnail","text":"<pre><code>void scaleThumbnail (\n    QPixmap &amp; pixmap\n) \n</code></pre>"},{"location":"flameshot/uploadhistory_8cpp_source/","title":"File uploadhistory.cpp","text":"<p>File List &gt; src &gt; widgets &gt; uploadhistory.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"uploadhistory.h\"\n#include \"./ui_uploadhistory.h\"\n#include \"src/tools/imgupload/imguploadermanager.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/history.h\"\n#include \"uploadlineitem.h\"\n\n#include &lt;QDateTime&gt;\n#include &lt;QDesktopWidget&gt;\n#include &lt;QFileInfo&gt;\n#include &lt;QPixmap&gt;\n\nvoid scaleThumbnail(QPixmap&amp; pixmap)\n{\n    if (pixmap.height() / HISTORYPIXMAP_MAX_PREVIEW_HEIGHT &gt;=\n        pixmap.width() / HISTORYPIXMAP_MAX_PREVIEW_WIDTH) {\n        pixmap = pixmap.scaledToHeight(HISTORYPIXMAP_MAX_PREVIEW_HEIGHT,\n                                       Qt::SmoothTransformation);\n    } else {\n        pixmap = pixmap.scaledToWidth(HISTORYPIXMAP_MAX_PREVIEW_WIDTH,\n                                      Qt::SmoothTransformation);\n    }\n}\n\nvoid clearHistoryLayout(QLayout* layout)\n{\n    while (layout-&gt;count() != 0) {\n        delete layout-&gt;takeAt(0);\n    }\n}\n\nUploadHistory::UploadHistory(QWidget* parent)\n  : QWidget(parent)\n  , ui(new Ui::UploadHistory)\n{\n    ui-&gt;setupUi(this);\n    setAttribute(Qt::WA_DeleteOnClose);\n\n    setWindowFlags(windowFlags() &amp; ~Qt::WindowContextHelpButtonHint);\n    resize(QDesktopWidget().availableGeometry(this).size() * 0.5);\n}\n\nvoid UploadHistory::loadHistory()\n{\n    clearHistoryLayout(ui-&gt;historyContainer);\n\n    History history = History();\n    QList&lt;QString&gt; historyFiles = history.history();\n\n    if (historyFiles.isEmpty()) {\n        setEmptyMessage();\n    } else {\n        foreach (QString fileName, historyFiles) {\n            addLine(history.path(), fileName);\n        }\n    }\n}\n\nvoid UploadHistory::setEmptyMessage()\n{\n    auto* buttonEmpty = new QPushButton;\n    buttonEmpty-&gt;setText(tr(\"Screenshots history is empty\"));\n    buttonEmpty-&gt;setMinimumSize(1, HISTORYPIXMAP_MAX_PREVIEW_HEIGHT);\n    connect(buttonEmpty, &amp;QPushButton::clicked, this, [=]() { this-&gt;close(); });\n    ui-&gt;historyContainer-&gt;addWidget(buttonEmpty);\n}\n\nvoid UploadHistory::addLine(const QString&amp; path, const QString&amp; fileName)\n{\n    QString fullFileName = path + fileName;\n\n    History history;\n    HistoryFileName unpackFileName = history.unpackFileName(fileName);\n\n    QString url = ImgUploaderManager(this).url() + unpackFileName.file;\n\n    // load pixmap\n    QPixmap pixmap;\n    pixmap.load(fullFileName, \"png\");\n    scaleThumbnail(pixmap);\n\n    // get file info\n    auto fileInfo = QFileInfo(fullFileName);\n    QString lastModified =\n      fileInfo.lastModified().toString(\"yyyy-MM-dd\\nhh:mm:ss\");\n\n    auto* line = new UploadLineItem(\n      this, pixmap, lastModified, url, fullFileName, unpackFileName);\n\n    connect(line, &amp;UploadLineItem::requestedDeletion, this, [=]() {\n        if (ui-&gt;historyContainer-&gt;count() &lt;= 1) {\n            setEmptyMessage();\n        }\n        delete line;\n    });\n\n    ui-&gt;historyContainer-&gt;addWidget(line);\n}\n\nUploadHistory::~UploadHistory()\n{\n    delete ui;\n}\n\n</code></pre>"},{"location":"flameshot/uploadhistory_8h/","title":"File uploadhistory.h","text":"<p>FileList &gt; src &gt; widgets &gt; uploadhistory.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/uploadhistory_8h/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"flameshot/uploadhistory_8h/#classes","title":"Classes","text":"Type Name class UploadHistory"},{"location":"flameshot/uploadhistory_8h/#public-functions","title":"Public Functions","text":"Type Name QT_END_NAMESPACE void clearHistoryLayout (QLayout * layout)  void scaleThumbnail (QPixmap &amp; input)"},{"location":"flameshot/uploadhistory_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/uploadhistory_8h/#function-clearhistorylayout","title":"function clearHistoryLayout","text":"<pre><code>QT_END_NAMESPACE void clearHistoryLayout (\n    QLayout * layout\n) \n</code></pre>"},{"location":"flameshot/uploadhistory_8h/#function-scalethumbnail","title":"function scaleThumbnail","text":"<pre><code>void scaleThumbnail (\n    QPixmap &amp; input\n) \n</code></pre>"},{"location":"flameshot/uploadhistory_8h_source/","title":"File uploadhistory.h","text":"<p>File List &gt; src &gt; widgets &gt; uploadhistory.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#ifndef UPLOADHISTORY_H\n#define UPLOADHISTORY_H\n\n#include &lt;QWidget&gt;\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass UploadHistory;\n}\nQT_END_NAMESPACE\n\nvoid clearHistoryLayout(QLayout* layout);\nvoid scaleThumbnail(QPixmap&amp; input);\n\nclass UploadHistory : public QWidget\n{\n    Q_OBJECT\npublic:\n    explicit UploadHistory(QWidget* parent = nullptr);\n    ~UploadHistory();\n\n    void loadHistory();\n\npublic slots:\n\nprivate:\n    void setEmptyMessage();\n    void addLine(QString const&amp;, QString const&amp;);\n\n    Ui::UploadHistory* ui;\n};\n#endif // UPLOADHISTORY_H\n\n</code></pre>"},{"location":"flameshot/uploadlineitem_8cpp/","title":"File uploadlineitem.cpp","text":"<p>FileList &gt; src &gt; widgets &gt; uploadlineitem.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"uploadlineitem.h\"</code></li> <li><code>#include \"./ui_uploadlineitem.h\"</code></li> <li><code>#include \"src/core/flameshotdaemon.h\"</code></li> <li><code>#include \"src/tools/imgupload/imguploadermanager.h\"</code></li> <li><code>#include \"src/utils/confighandler.h\"</code></li> <li><code>#include \"src/utils/history.h\"</code></li> <li><code>#include \"src/widgets/notificationwidget.h\"</code></li> <li><code>#include &lt;QDesktopServices&gt;</code></li> <li><code>#include &lt;QFileInfo&gt;</code></li> <li><code>#include &lt;QMessageBox&gt;</code></li> <li><code>#include &lt;QUrl&gt;</code></li> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/uploadlineitem_8cpp/#public-functions","title":"Public Functions","text":"Type Name void removeCacheFile (QString const &amp; fullFileName)"},{"location":"flameshot/uploadlineitem_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/uploadlineitem_8cpp/#function-removecachefile","title":"function removeCacheFile","text":"<pre><code>void removeCacheFile (\n    QString const &amp; fullFileName\n) \n</code></pre>"},{"location":"flameshot/uploadlineitem_8cpp_source/","title":"File uploadlineitem.cpp","text":"<p>File List &gt; src &gt; widgets &gt; uploadlineitem.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>\n#include \"uploadlineitem.h\"\n#include \"./ui_uploadlineitem.h\"\n#include \"src/core/flameshotdaemon.h\"\n#include \"src/tools/imgupload/imguploadermanager.h\"\n#include \"src/utils/confighandler.h\"\n#include \"src/utils/history.h\"\n#include \"src/widgets/notificationwidget.h\"\n\n#include &lt;QDesktopServices&gt;\n#include &lt;QFileInfo&gt;\n#include &lt;QMessageBox&gt;\n#include &lt;QUrl&gt;\n#include &lt;QWidget&gt;\n\nvoid removeCacheFile(QString const&amp; fullFileName)\n{\n    QFile file(fullFileName);\n    if (file.exists()) {\n        file.remove();\n    }\n}\n\nUploadLineItem::UploadLineItem(QWidget* parent,\n                               QPixmap const&amp; preview,\n                               QString const&amp; timestamp,\n                               QString const&amp; url,\n                               QString const&amp; fullFileName,\n                               HistoryFileName const&amp; unpackFileName)\n  : QWidget(parent)\n  , ui(new Ui::UploadLineItem)\n{\n    ui-&gt;setupUi(this);\n    setAttribute(Qt::WA_DeleteOnClose);\n    ui-&gt;imagePreview-&gt;setPixmap(preview);\n    ui-&gt;uploadTimestamp-&gt;setText(timestamp);\n\n    connect(ui-&gt;copyUrl, &amp;QPushButton::clicked, this, [=]() {\n        FlameshotDaemon::copyToClipboard(url);\n    });\n\n    connect(ui-&gt;openBrowser, &amp;QPushButton::clicked, this, [=]() {\n        QDesktopServices::openUrl(QUrl(url));\n    });\n\n    connect(ui-&gt;deleteImage, &amp;QPushButton::clicked, this, [=]() {\n        if (ConfigHandler().historyConfirmationToDelete() &amp;&amp;\n            QMessageBox::No ==\n              QMessageBox::question(\n                this,\n                tr(\"Confirm to delete\"),\n                tr(\"Are you sure you want to delete a screenshot from the \"\n                   \"latest uploads and server?\"),\n                QMessageBox::Yes | QMessageBox::No)) {\n            return;\n        }\n\n        ImgUploaderBase* imgUploaderBase =\n          ImgUploaderManager(this).uploader(unpackFileName.type);\n        imgUploaderBase-&gt;deleteImage(unpackFileName.file, unpackFileName.token);\n\n        removeCacheFile(fullFileName);\n        emit requestedDeletion();\n    });\n}\n\nUploadLineItem::~UploadLineItem()\n{\n    delete ui;\n}\n\n</code></pre>"},{"location":"flameshot/uploadlineitem_8h/","title":"File uploadlineitem.h","text":"<p>FileList &gt; src &gt; widgets &gt; uploadlineitem.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;QWidget&gt;</code></li> </ul>"},{"location":"flameshot/uploadlineitem_8h/#namespaces","title":"Namespaces","text":"Type Name namespace Ui"},{"location":"flameshot/uploadlineitem_8h/#classes","title":"Classes","text":"Type Name class UploadLineItem"},{"location":"flameshot/uploadlineitem_8h/#public-functions","title":"Public Functions","text":"Type Name QT_END_NAMESPACE void removeCacheFile (QString const &amp; fullFileName)"},{"location":"flameshot/uploadlineitem_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"flameshot/uploadlineitem_8h/#function-removecachefile","title":"function removeCacheFile","text":"<pre><code>QT_END_NAMESPACE void removeCacheFile (\n    QString const &amp; fullFileName\n) \n</code></pre>"},{"location":"flameshot/uploadlineitem_8h_source/","title":"File uploadlineitem.h","text":"<p>File List &gt; src &gt; widgets &gt; uploadlineitem.h</p> <p>Go to the documentation of this file. </p> <pre><code>\n#ifndef UPLOADLINEITEM_H\n#define UPLOADLINEITEM_H\n\n#include &lt;QWidget&gt;\n\nstruct HistoryFileName;\n\nQT_BEGIN_NAMESPACE\nnamespace Ui {\nclass UploadLineItem;\n}\nQT_END_NAMESPACE\n\nvoid removeCacheFile(QString const&amp; fullFileName);\n\nclass UploadLineItem : public QWidget\n{\n    Q_OBJECT\npublic:\n    UploadLineItem(QWidget* parent,\n                   QPixmap const&amp; preview,\n                   QString const&amp; timestamp,\n                   QString const&amp; url,\n                   QString const&amp; fullFileName,\n                   HistoryFileName const&amp; unpackFileName);\n    ~UploadLineItem();\n\nsignals:\n    void requestedDeletion();\n\nprivate:\n    Ui::UploadLineItem* ui;\n};\n#endif // UPLOADLINEITEM_H\n\n</code></pre>"},{"location":"flameshot/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace @103 </li> <li>namespace @2 </li> <li>namespace @57 </li> <li>namespace @61 </li> <li>namespace @67 </li> <li>namespace @85 </li> <li>namespace @91 </li> <li>namespace ColorUtils </li> <li>namespace GlobalValues </li> <li>namespace PathInfo </li> <li>namespace Ui </li> <li>namespace org </li> <li>namespace freedesktop <ul> <li>namespace portal </li> </ul> </li> <li>namespace strfparse </li> </ul>"},{"location":"flameshot/classes/","title":"Class Index","text":""},{"location":"flameshot/classes/#a","title":"a","text":"<ul> <li>AbstractActionTool</li> <li>AbstractLogger</li> <li>AbstractPathTool</li> <li>AbstractTwoPointTool</li> <li>AcceptTool</li> <li>AppLauncher</li> <li>AppLauncherWidget</li> <li>ArrowTool</li> </ul>"},{"location":"flameshot/classes/#b","title":"b","text":"<ul> <li>Bool</li> <li>BoundedInt</li> <li>ButtonHandler</li> <li>ButtonList</li> <li>ButtonListView</li> </ul>"},{"location":"flameshot/classes/#c","title":"c","text":"<ul> <li>CaptureButton</li> <li>CaptureLauncher</li> <li>CaptureRequest</li> <li>CaptureToolButton</li> <li>CaptureToolObjects</li> <li>CaptureWidget</li> <li>CircleCountTool</li> <li>CircleTool</li> <li>ClickableLabel</li> <li>Color</li> <li>ColorGrabWidget</li> <li>ColorPicker</li> <li>ColorPickerEditMode</li> <li>ColorPickerEditor</li> <li>ColorPickerWidget</li> <li>CommandArgument</li> <li>CommandLineParser</li> <li>CommandOption</li> <li>ConfigErrorDetails</li> <li>ConfigHandler</li> <li>ConfigResolver</li> <li>ConfigWindow</li> <li>CopyTool</li> <li>CaptureContext</li> <li>CompareAppByName</li> </ul>"},{"location":"flameshot/classes/#d","title":"d","text":"<ul> <li>DesktopInfo</li> <li>DraggableWidgetMaker</li> <li>DesktopAppData</li> <li>DesktopFileParser</li> </ul>"},{"location":"flameshot/classes/#e","title":"e","text":"<ul> <li>ExistingDir</li> <li>ExitTool</li> <li>ExtendedSlider</li> </ul>"},{"location":"flameshot/classes/#f","title":"f","text":"<ul> <li>FileNameEditor</li> <li>FileNameHandler</li> <li>FilenamePattern</li> <li>Flameshot</li> <li>FlameshotDBusAdapter</li> <li>FlameshotDaemon</li> </ul>"},{"location":"flameshot/classes/#g","title":"g","text":"<ul> <li>GeneralConf</li> <li>GlobalShortcutFilter</li> </ul>"},{"location":"flameshot/classes/#h","title":"h","text":"<ul> <li>History</li> <li>HoverEventFilter</li> <li>HistoryFileName</li> </ul>"},{"location":"flameshot/classes/#i","title":"i","text":"<ul> <li>ImageLabel</li> <li>ImgUploadDialog</li> <li>ImgUploaderBase</li> <li>ImgUploaderManager</li> <li>ImgUploaderTool</li> <li>ImgurUploader</li> <li>InfoWindow</li> <li>InvertTool</li> </ul>"},{"location":"flameshot/classes/#k","title":"k","text":"<ul> <li>KeySequence</li> </ul>"},{"location":"flameshot/classes/#l","title":"l","text":"<ul> <li>LauncherItemDelegate</li> <li>LineTool</li> <li>LoadSpinner</li> <li>LowerBoundedInt</li> </ul>"},{"location":"flameshot/classes/#m","title":"m","text":"<ul> <li>MagnifierWidget</li> <li>MarkerTool</li> <li>ModificationCommand</li> <li>MoveTool</li> </ul>"},{"location":"flameshot/classes/#n","title":"n","text":"<ul> <li>NotificationWidget</li> <li>NotifierBox</li> <li>Node</li> </ul>"},{"location":"flameshot/classes/#o","title":"o","text":"<ul> <li>OrgFreedesktopPortalRequestInterface</li> <li>OrientablePushButton</li> <li>OverlayMessage</li> </ul>"},{"location":"flameshot/classes/#p","title":"p","text":"<ul> <li>PencilTool</li> <li>PinTool</li> <li>PinWidget</li> <li>PixelateTool</li> </ul>"},{"location":"flameshot/classes/#q","title":"q","text":"<ul> <li>QGuiAppCurrentScreen</li> <li>QSharedPointer</li> </ul>"},{"location":"flameshot/classes/#r","title":"r","text":"<ul> <li>RectangleTool</li> <li>RedoTool</li> <li>Region</li> </ul>"},{"location":"flameshot/classes/#s","title":"s","text":"<ul> <li>SaveFileExtension</li> <li>SaveTool</li> <li>ScreenGrabber</li> <li>SelectionTool</li> <li>SelectionWidget</li> <li>SetShortcutDialog</li> <li>ShortcutsWidget</li> <li>SidePanelWidget</li> <li>SizeDecreaseTool</li> <li>SizeIncreaseTool</li> <li>StrftimeChooserWidget</li> <li>String</li> <li>StyleOverride</li> <li>SystemNotification</li> </ul>"},{"location":"flameshot/classes/#t","title":"t","text":"<ul> <li>TerminalLauncher</li> <li>TextConfig</li> <li>TextTool</li> <li>TextWidget</li> <li>ToolFactory</li> <li>TrayIcon</li> <li>TerminalApp</li> </ul>"},{"location":"flameshot/classes/#u","title":"u","text":"<ul> <li>UIcolorEditor</li> <li>UndoTool</li> <li>UpdateNotificationWidget</li> <li>UploadHistory</li> <li>UploadLineItem</li> <li>UserColors</li> <li>UtilityPanel</li> </ul>"},{"location":"flameshot/classes/#v","title":"v","text":"<ul> <li>ValueHandler</li> <li>VisualsEditor</li> </ul>"},{"location":"flameshot/classes/#w","title":"w","text":"<ul> <li>WaylandUtils</li> <li>WinLnkFileParser</li> </ul>"},{"location":"flameshot/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AbstractLogger A class that allows you to log events to where they need to go. </li> <li>class ValueHandler Handles the value of a configuration option (abstract class). </li> <li>class Bool </li> <li>class BoundedInt </li> <li>class ButtonList </li> <li>class Color </li> <li>class ExistingDir </li> <li>class FilenamePattern </li> <li>class KeySequence </li> <li>class LowerBoundedInt </li> <li>class Region </li> <li>class SaveFileExtension </li> <li>class String </li> <li>class UserColors </li> <li>class CaptureRequest </li> <li>class CommandArgument </li> <li>class CommandLineParser </li> <li>class CommandOption </li> <li>class DesktopInfo </li> <li>class History </li> <li>class QGuiAppCurrentScreen </li> <li>class QSharedPointer </li> <li>class WaylandUtils </li> <li>struct CaptureContext </li> <li>struct CommandLineParser::Node </li> <li>struct CompareAppByName </li> <li>struct DesktopAppData </li> <li>struct DesktopFileParser </li> <li>struct HistoryFileName </li> <li>struct TerminalApp </li> <li>struct WinLnkFileParser </li> <li>class CaptureTool </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractPathTool <ul> <li>class PencilTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractPathTool <ul> <li>class PencilTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractTwoPointTool <ul> <li>class ArrowTool </li> <li>class CircleCountTool </li> <li>class CircleTool </li> <li>class InvertTool </li> <li>class LineTool </li> <li>class MarkerTool </li> <li>class PixelateTool </li> <li>class RectangleTool </li> <li>class SelectionTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class TextTool </li> <li>class AbstractActionTool <ul> <li>class AcceptTool </li> <li>class AppLauncher </li> <li>class CopyTool </li> <li>class ExitTool </li> <li>class ImgUploaderTool </li> <li>class MoveTool </li> <li>class PinTool </li> <li>class RedoTool </li> <li>class SaveTool </li> <li>class SizeDecreaseTool </li> <li>class SizeIncreaseTool </li> <li>class UndoTool </li> </ul> </li> <li>class QWidget </li> <li>class AppLauncherWidget </li> <li>class CaptureWidget </li> <li>class ColorGrabWidget </li> <li>class ColorPickerWidget <ul> <li>class ColorPicker </li> <li>class ColorPickerEditMode </li> </ul> </li> <li>class ColorPickerWidget <ul> <li>class ColorPicker </li> <li>class ColorPickerEditMode </li> </ul> </li> <li>class ColorPickerEditor </li> <li>class ColorPickerWidget <ul> <li>class ColorPicker </li> <li>class ColorPickerEditMode </li> </ul> </li> <li>class ConfigWindow </li> <li>class FileNameEditor </li> <li>class GeneralConf </li> <li>class ImgUploaderBase <ul> <li>class ImgurUploader </li> </ul> </li> <li>class ImgUploaderBase <ul> <li>class ImgurUploader </li> </ul> </li> <li>class InfoWindow </li> <li>class LoadSpinner </li> <li>class MagnifierWidget </li> <li>class NotificationWidget </li> <li>class NotifierBox </li> <li>class PinWidget </li> <li>class SelectionWidget </li> <li>class ShortcutsWidget </li> <li>class SidePanelWidget </li> <li>class StrftimeChooserWidget </li> <li>class TextConfig </li> <li>class UIcolorEditor </li> <li>class UpdateNotificationWidget </li> <li>class UploadHistory </li> <li>class UploadLineItem </li> <li>class UtilityPanel </li> <li>class VisualsEditor </li> <li>class QObject </li> <li>class ButtonHandler </li> <li>class CaptureToolObjects </li> <li>class ConfigHandler </li> <li>class DraggableWidgetMaker </li> <li>class FileNameHandler </li> <li>class Flameshot </li> <li>class FlameshotDaemon </li> <li>class GlobalShortcutFilter </li> <li>class HoverEventFilter </li> <li>class ImgUploaderManager </li> <li>class ScreenGrabber </li> <li>class SystemNotification </li> <li>class TerminalLauncher </li> <li>class ToolFactory </li> <li>class QListWidget </li> <li>class ButtonListView </li> <li>class QPushButton </li> <li>class CaptureButton <ul> <li>class CaptureToolButton </li> <li>class OrientablePushButton </li> </ul> </li> <li>class CaptureButton <ul> <li>class CaptureToolButton </li> <li>class OrientablePushButton </li> </ul> </li> <li>class CaptureButton <ul> <li>class CaptureToolButton </li> <li>class OrientablePushButton </li> </ul> </li> <li>class QDialog </li> <li>class CaptureLauncher </li> <li>class ConfigErrorDetails </li> <li>class ConfigResolver </li> <li>class ImgUploadDialog </li> <li>class SetShortcutDialog </li> <li>class QLabel </li> <li>class ClickableLabel </li> <li>class ImageLabel </li> <li>class OverlayMessage Overlay a message in capture mode. </li> <li>class QSlider </li> <li>class ExtendedSlider </li> <li>class QDBusAbstractAdaptor </li> <li>class FlameshotDBusAdapter </li> <li>class QAbstractNativeEventFilter </li> <li>class GlobalShortcutFilter </li> <li>class QStyledItemDelegate </li> <li>class LauncherItemDelegate </li> <li>class QUndoCommand </li> <li>class ModificationCommand </li> <li>class QDBusAbstractInterface </li> <li>class OrgFreedesktopPortalRequestInterface </li> <li>class QProxyStyle </li> <li>class StyleOverride </li> <li>class QTextEdit </li> <li>class TextWidget </li> <li>class QSystemTrayIcon </li> <li>class TrayIcon </li> </ul>"},{"location":"flameshot/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p>"},{"location":"flameshot/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"flameshot/class_members/","title":"Class Members","text":""},{"location":"flameshot/class_members/#a","title":"a","text":"<ul> <li>AbstractActionTool (AbstractActionTool)</li> <li>AbstractLogger (AbstractLogger)</li> <li>addOutputString (AbstractLogger)</li> <li>attachNotificationPath (AbstractLogger)</li> <li>AbstractPathTool (AbstractPathTool)</li> <li>addPoint (AbstractPathTool)</li> <li>AbstractTwoPointTool (AbstractTwoPointTool)</li> <li>adjustedVector (AbstractTwoPointTool)</li> <li>AcceptTool (AcceptTool)</li> <li>AppLauncher (AppLauncher)</li> <li>AppLauncherWidget (AppLauncherWidget)</li> <li>addAppsToListWidget (AppLauncherWidget)</li> <li>ArrowTool (ArrowTool)</li> <li>adjustHorizontalCenter (ButtonHandler)</li> <li>addPinTask (CaptureRequest)</li> <li>addSaveTask (CaptureRequest)</li> <li>addTask (CaptureRequest)</li> <li>animatedShow (CaptureToolButton, NotificationWidget)</li> <li>append (CaptureToolObjects)</li> <li>at (CaptureToolObjects)</li> <li>activeButtonTool (CaptureWidget)</li> <li>activeButtonToolType (CaptureWidget)</li> <li>activeToolObject (CaptureWidget)</li> <li>addPreset (ColorPickerEditor)</li> <li>AddArgument (CommandLineParser)</li> <li>AddOption (CommandLineParser)</li> <li>AddOptions (CommandLineParser)</li> <li>addHelpOption (CommandLineParser)</li> <li>addVersionOption (CommandLineParser)</li> <li>argument (CommandLineParser::Node)</li> <li>addChecker (CommandOption)</li> <li>assertKeyRecognized (ConfigHandler)</li> <li>autoNumerateDuplicate (FileNameHandler)</li> <li>attachPin (FlameshotDaemon)</li> <li>attachScreenshotToClipboard (FlameshotDaemon)</li> <li>attachTextToClipboard (FlameshotDaemon)</li> <li>animatedHide (NotificationWidget)</li> <li>appendShortcut (ShortcutsWidget)</li> <li>arg (TerminalApp)</li> <li>adjustSize (TextWidget)</li> <li>appUpdates (TrayIcon)</li> <li>addLine (UploadHistory)</li> <li>activeLayerIndex (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#b","title":"b","text":"<ul> <li>boundingRect (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, ArrowTool, CircleCountTool, InvertTool, OverlayMessage, PixelateTool, TextTool)</li> <li>Bool (Bool)</li> <li>BoundedInt (BoundedInt)</li> <li>ButtonHandler (ButtonHandler)</li> <li>buttonsAreInside (ButtonHandler)</li> <li>ButtonListView (ButtonListView)</li> <li>baseName (ConfigHandler)</li> <li>buttonBox (ImgUploadDialog)</li> </ul>"},{"location":"flameshot/class_members/#c","title":"c","text":"<ul> <li>Channel (AbstractLogger)</li> <li>closeOnButtonPressed (AbstractPathTool, AbstractTwoPointTool, AcceptTool, AppLauncher, CopyTool, ExitTool, ImgUploaderTool, MoveTool, PinTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>copyParams (AbstractPathTool, AbstractTwoPointTool, ArrowTool, CircleCountTool, TextTool)</li> <li>color (AbstractTwoPointTool, CaptureContext, ColorGrabWidget)</li> <li>copy (AcceptTool, AppLauncher, ArrowTool, CircleCountTool, CircleTool, CopyTool, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>capture (AppLauncher, ImgUploaderTool)</li> <li>configureListView (AppLauncherWidget)</li> <li>check (Bool, BoundedInt, ButtonList, Color, ExistingDir, FilenamePattern, KeySequence, LowerBoundedInt, Region, SaveFileExtension, String, UserColors, ValueHandler)</li> <li>calculateShift (ButtonHandler)</li> <li>contains (ButtonHandler)</li> <li>CaptureButton (CaptureButton)</li> <li>circleCount (CaptureContext)</li> <li>CaptureLauncher (CaptureLauncher)</li> <li>connectCaptureSlots (CaptureLauncher)</li> <li>CaptureMode (CaptureRequest)</li> <li>CaptureRequest (CaptureRequest)</li> <li>captureMode (CaptureRequest)</li> <li>CaptureToolButton (CaptureToolButton)</li> <li>CaptureToolObjects (CaptureToolObjects)</li> <li>captureToolObjects (CaptureToolObjects)</li> <li>clear (CaptureToolObjects)</li> <li>CaptureWidget (CaptureWidget)</li> <li>changeEvent (CaptureWidget)</li> <li>CircleCountTool (CircleCountTool)</li> <li>CircleTool (CircleTool)</li> <li>ClickableLabel (ClickableLabel)</li> <li>Color (Color)</li> <li>ColorGrabWidget (ColorGrabWidget)</li> <li>cursorPos (ColorGrabWidget)</li> <li>ColorPicker (ColorPicker)</li> <li>ColorPickerEditMode (ColorPickerEditMode)</li> <li>ColorPickerEditor (ColorPickerEditor)</li> <li>ColorPickerWidget (ColorPickerWidget)</li> <li>CommandArgument (CommandArgument)</li> <li>CommandLineParser (CommandLineParser)</li> <li>CommandOption (CommandOption)</li> <li>checkValue (CommandOption)</li> <li>ConfigErrorDetails (ConfigErrorDetails)</li> <li>CONFIG_GETTER_SETTER (ConfigHandler)</li> <li>ConfigHandler (ConfigHandler)</li> <li>checkAndHandleError (ConfigHandler)</li> <li>checkForErrors (ConfigHandler)</li> <li>checkSemantics (ConfigHandler)</li> <li>checkShortcutConflicts (ConfigHandler)</li> <li>checkUnrecognizedSettings (ConfigHandler)</li> <li>cleanUnusedKeys (ConfigHandler)</li> <li>configFilePath (ConfigHandler)</li> <li>ConfigResolver (ConfigResolver)</li> <li>ConfigWindow (ConfigWindow)</li> <li>CopyTool (CopyTool)</li> <li>categories (DesktopAppData)</li> <li>call (FlameshotDaemon)</li> <li>checkDBusConnection (FlameshotDaemon)</li> <li>copyToClipboard (FlameshotDaemon)</li> <li>createMethodCall (FlameshotDaemon)</li> <li>createPin (FlameshotDaemon)</li> <li>chooseFolder (GeneralConf)</li> <li>compileFromKeyMap (OverlayMessage)</li> <li>closePin (PinWidget)</li> <li>currentScreen (QGuiAppCurrentScreen)</li> <li>closeEditor (TextTool)</li> <li>configurationWidget (TextTool)</li> <li>CreateTool (ToolFactory)</li> <li>clearToolWidget (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#d","title":"d","text":"<ul> <li>description (AcceptTool, AppLauncher, ArrowTool, CaptureToolButton, CircleCountTool, CircleTool, CommandArgument, CommandOption, CopyTool, DesktopAppData, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>disconnectCaptureSlots (CaptureLauncher)</li> <li>data (CaptureRequest)</li> <li>delay (CaptureRequest)</li> <li>drawErrorMessage (CaptureWidget)</li> <li>drawInactiveRegion (CaptureWidget)</li> <li>drawObjectSelection (CaptureWidget, TextTool)</li> <li>drawToolsData (CaptureWidget)</li> <li>deletePreset (ColorPickerEditor)</li> <li>defaultLargeColorPalette (ColorPickerWidget)</li> <li>defaultSmallColorPalette (ColorPickerWidget)</li> <li>dashedNames (CommandOption)</li> <li>DesktopAppData (DesktopAppData)</li> <li>DesktopFileParser (DesktopFileParser)</li> <li>DESKTOP_SESSION (DesktopInfo)</li> <li>DesktopInfo (DesktopInfo)</li> <li>DraggableWidgetMaker (DraggableWidgetMaker)</li> <li>deleteImage (ImgUploaderBase, ImgurUploader)</li> <li>drawSearchArea (InvertTool, PixelateTool)</li> <li>drawMagnifier (MagnifierWidget)</li> <li>drawMagnifierCircle (MagnifierWidget)</li> <li>decreaseOpacity (PinWidget)</li> <li>desktopGeometry (ScreenGrabber)</li> </ul>"},{"location":"flameshot/class_members/#e","title":"e","text":"<ul> <li>enableMessageHeader (AbstractLogger)</li> <li>error (AbstractLogger)</li> <li>expected (Bool, BoundedInt, ButtonList, Color, ExistingDir, FilenamePattern, KeySequence, LowerBoundedInt, SaveFileExtension, String, UserColors, ValueHandler)</li> <li>ensureSelectionMinimunSize (ButtonHandler)</li> <li>expandSelection (ButtonHandler)</li> <li>ExportTask (CaptureRequest)</li> <li>extendedRect (CaptureWidget)</li> <li>extendedSelection (CaptureWidget)</li> <li>eventFilter (ColorGrabWidget, ColorPickerEditMode, DraggableWidgetMaker, HoverEventFilter, SelectionWidget, SidePanelWidget)</li> <li>errorMsg (CommandOption)</li> <li>ensureFileWatched (ConfigHandler)</li> <li>errorMessage (ConfigHandler)</li> <li>exec (DesktopAppData)</li> <li>ExitTool (ExitTool)</li> <li>ExtendedSlider (ExtendedSlider)</li> <li>enableTrayIcon (FlameshotDaemon)</li> <li>enterEvent (NotifierBox, PinWidget)</li> <li>event (PinWidget)</li> <li>enableCheckUpdatesAction (TrayIcon)</li> </ul>"},{"location":"flameshot/class_members/#f","title":"f","text":"<ul> <li>fallback (Bool, BoundedInt, ButtonList, Color, ExistingDir, FilenamePattern, KeySequence, LowerBoundedInt, String, UserColors, ValueHandler)</li> <li>fromIntList (ButtonList)</li> <li>fullscreen (CaptureContext)</li> <li>find (CaptureToolObjects)</li> <li>findWithRadius (CaptureToolObjects)</li> <li>finalize (ColorGrabWidget)</li> <li>findParent (CommandLineParser)</li> <li>filenamePatternDefault (ConfigHandler)</li> <li>FileNameEditor (FileNameEditor)</li> <li>FileNameHandler (FileNameHandler)</li> <li>Flameshot (Flameshot)</li> <li>FlameshotDBusAdapter (FlameshotDBusAdapter)</li> <li>FlameshotDaemon (FlameshotDaemon)</li> <li>file (HistoryFileName)</li> <li>freeDesktopPortal (ScreenGrabber)</li> <li>fullGeometry (SelectionWidget)</li> <li>finalizeGrab (SidePanelWidget)</li> <li>fillCaptureTools (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#g","title":"g","text":"<ul> <li>globalStyleSheet (CaptureButton)</li> <li>getIterableButtonTypes (CaptureToolButton)</li> <li>getPriorityByButton (CaptureToolButton)</li> <li>getColorAtPoint (ColorGrabWidget)</li> <li>getDefaultLargeColorPalette (ColorPickerWidget)</li> <li>getDefaultSmallColorPalette (ColorPickerWidget)</li> <li>getInstance (ConfigHandler)</li> <li>getAppsByCategory (DesktopFileParser, WinLnkFileParser)</li> <li>GDMSESSION (DesktopInfo)</li> <li>GNOME_DESKTOP_SESSION_ID (DesktopInfo)</li> <li>GeneralConf (GeneralConf)</li> <li>GlobalShortcutFilter (GlobalShortcutFilter)</li> <li>getNativeModifier (GlobalShortcutFilter)</li> <li>gestureEvent (PinWidget)</li> <li>generalGrimScreenshot (ScreenGrabber)</li> <li>grabEntireDesktop (ScreenGrabber)</li> <li>grabScreen (ScreenGrabber)</li> <li>geometry (SelectionWidget)</li> <li>getMouseSide (SelectionWidget)</li> <li>getPreferedTerminal (TerminalLauncher)</li> <li>getAllUsersStartMenuPath (WinLnkFileParser)</li> <li>getImageFileExtAssociates (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_members/#h","title":"h","text":"<ul> <li>hideSectionUnderMouse (ButtonHandler)</li> <li>horizontalPoints (ButtonHandler)</li> <li>hideEvent (ColorPicker, NotifierBox, SelectionWidget, SidePanelWidget)</li> <li>hasError (ConfigHandler)</li> <li>haveExternalWidget (Flameshot)</li> <li>History (History)</li> <li>history (History)</li> <li>HoverEventFilter (HoverEventFilter)</li> <li>handlerAreas (SelectionWidget)</li> <li>hide (UpdateNotificationWidget, UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#i","title":"i","text":"<ul> <li>isSelectable (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, MoveTool, TextTool)</li> <li>isValid (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, CircleCountTool, TextTool)</li> <li>info (AbstractLogger, CircleCountTool, TextTool)</li> <li>icon (AcceptTool, AppLauncher, ArrowTool, CaptureToolButton, CircleCountTool, CircleTool, CopyTool, DesktopAppData, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>initAppMap (AppLauncherWidget)</li> <li>initListWidget (AppLauncherWidget)</li> <li>init (ButtonHandler, CaptureButton, ImgUploaderManager, OverlayMessage)</li> <li>intersectWithAreas (ButtonHandler)</li> <li>isVisible (ButtonHandler, UtilityPanel)</li> <li>initButtonList (ButtonListView)</li> <li>id (CaptureRequest)</li> <li>initialSelection (CaptureRequest)</li> <li>initButton (CaptureToolButton)</li> <li>iterableButtonTypes (CaptureToolButton)</li> <li>insert (CaptureToolObjects)</li> <li>initButtons (CaptureWidget, UIcolorEditor)</li> <li>initContext (CaptureWidget)</li> <li>initHelpMessage (CaptureWidget)</li> <li>initPanel (CaptureWidget)</li> <li>initSelection (CaptureWidget)</li> <li>initShortcuts (CaptureWidget)</li> <li>initColorPicker (ColorPickerWidget)</li> <li>isRoot (CommandArgument)</li> <li>isSet (CommandLineParser)</li> <li>isShortcut (ConfigHandler)</li> <li>initErrorIndicator (ConfigWindow)</li> <li>initLayout (FileNameEditor)</li> <li>initWidgets (FileNameEditor, VisualsEditor)</li> <li>instance (Flameshot, FlameshotDaemon, OverlayMessage)</li> <li>initTrayIcon (FlameshotDaemon, TrayIcon)</li> <li>isThisInstanceHostingWidgets (FlameshotDaemon)</li> <li>initAllowMultipleGuiInstances (GeneralConf)</li> <li>initAntialiasingPinZoom (GeneralConf)</li> <li>initAutoCloseIdleDaemon (GeneralConf)</li> <li>initAutostart (GeneralConf)</li> <li>initCheckForUpdates (GeneralConf)</li> <li>initConfigButtons (GeneralConf)</li> <li>initCopyAndCloseAfterUpload (GeneralConf)</li> <li>initCopyOnDoubleClick (GeneralConf)</li> <li>initCopyPathAfterSave (GeneralConf)</li> <li>initHistoryConfirmationToDelete (GeneralConf)</li> <li>initJpegQuality (GeneralConf)</li> <li>initPredefinedColorPaletteLarge (GeneralConf)</li> <li>initSaveAfterCopy (GeneralConf)</li> <li>initSaveLastRegion (GeneralConf)</li> <li>initScrollArea (GeneralConf)</li> <li>initShowDesktopNotification (GeneralConf)</li> <li>initShowHelp (GeneralConf)</li> <li>initShowMagnifier (GeneralConf)</li> <li>initShowSelectionGeometry (GeneralConf)</li> <li>initShowSidePanelButton (GeneralConf)</li> <li>initShowStartupLaunchMessage (GeneralConf)</li> <li>initShowTrayIcon (GeneralConf)</li> <li>initSquareMagnifier (GeneralConf)</li> <li>initUndoLimit (GeneralConf)</li> <li>initUploadClientSecret (GeneralConf)</li> <li>initUploadHistoryMax (GeneralConf)</li> <li>initUploadWithoutConfirmation (GeneralConf)</li> <li>initUseJpgForClipboard (GeneralConf)</li> <li>ImageLabel (ImageLabel)</li> <li>ImgUploadDialog (ImgUploadDialog)</li> <li>ImgUploaderBase (ImgUploaderBase)</li> <li>imageURL (ImgUploaderBase)</li> <li>ImgUploaderManager (ImgUploaderManager)</li> <li>ImgUploaderTool (ImgUploaderTool)</li> <li>ImgurUploader (ImgurUploader)</li> <li>InfoWindow (InfoWindow)</li> <li>InvertTool (InvertTool)</li> <li>increaseOpacity (PinWidget)</li> <li>initInfoTable (ShortcutsWidget)</li> <li>isChanged (TextTool)</li> <li>initMenu (TrayIcon)</li> <li>initColorWheel (UIcolorEditor)</li> <li>initInternalPanel (UpdateNotificationWidget, UtilityPanel)</li> <li>initOpacitySlider (VisualsEditor)</li> </ul>"},{"location":"flameshot/class_members/#k","title":"k","text":"<ul> <li>keyPressEvent (AppLauncherWidget, CaptureWidget, ConfigWindow, InfoWindow, PinWidget, SetShortcutDialog)</li> <li>keyReleaseEvent (CaptureWidget, SetShortcutDialog)</li> <li>keysFromGroup (ConfigHandler)</li> <li>KDE_FULL_SESSION (DesktopInfo)</li> <li>KeySequence (KeySequence)</li> </ul>"},{"location":"flameshot/class_members/#l","title":"l","text":"<ul> <li>layout (ConfigResolver, ImgUploadDialog)</li> <li>LauncherItemDelegate (LauncherItemDelegate)</li> <li>LineTool (LineTool)</li> <li>LoadSpinner (LoadSpinner)</li> <li>LowerBoundedInt (LowerBoundedInt)</li> <li>leaveEvent (PinWidget)</li> <li>loadShortcuts (ShortcutsWidget)</li> <li>launchDetached (TerminalLauncher)</li> <li>loadHistory (UploadHistory)</li> </ul>"},{"location":"flameshot/class_members/#m","title":"m","text":"<ul> <li>m_defaultChannel (AbstractLogger)</li> <li>m_enableMessageHeader (AbstractLogger)</li> <li>m_notificationPath (AbstractLogger)</li> <li>m_targets (AbstractLogger)</li> <li>m_textStreams (AbstractLogger)</li> <li>messageHeader (AbstractLogger)</li> <li>m_color (AbstractPathTool, AbstractTwoPointTool, ColorGrabWidget, ColorPickerEditor, LoadSpinner, MagnifierWidget, SelectionWidget, SidePanelWidget, TextTool)</li> <li>m_padding (AbstractPathTool, AbstractTwoPointTool)</li> <li>m_pathArea (AbstractPathTool)</li> <li>m_points (AbstractPathTool, AbstractTwoPointTool)</li> <li>m_pos (AbstractPathTool)</li> <li>m_thickness (AbstractPathTool, AbstractTwoPointTool)</li> <li>mousePreviewRect (AbstractPathTool, AbstractTwoPointTool, CircleCountTool, MarkerTool)</li> <li>move (AbstractPathTool, AbstractTwoPointTool, TextTool)</li> <li>m_supportsDiagonalAdj (AbstractTwoPointTool)</li> <li>m_supportsOrthogonalAdj (AbstractTwoPointTool)</li> <li>m_appsMap (AppLauncherWidget)</li> <li>m_filterList (AppLauncherWidget)</li> <li>m_keepOpen (AppLauncherWidget)</li> <li>m_keepOpenCheckbox (AppLauncherWidget)</li> <li>m_layout (AppLauncherWidget, FileNameEditor, GeneralConf, NotificationWidget, PinWidget, SetShortcutDialog, ShortcutsWidget, SidePanelWidget, TextConfig, UpdateNotificationWidget, UtilityPanel, VisualsEditor)</li> <li>m_lineEdit (AppLauncherWidget)</li> <li>m_parser (AppLauncherWidget)</li> <li>m_pixmap (AppLauncherWidget, ColorGrabWidget, ImageLabel, ImgUploaderBase, PinTool, PinWidget, SidePanelWidget)</li> <li>m_tabWidget (AppLauncherWidget, ConfigWindow, VisualsEditor)</li> <li>m_tempFile (AppLauncherWidget)</li> <li>m_terminalCheckbox (AppLauncherWidget)</li> <li>m_arrowPath (ArrowTool)</li> <li>m_def (Bool, BoundedInt, Color, LowerBoundedInt, String)</li> <li>m_max (BoundedInt, UserColors)</li> <li>m_min (BoundedInt, LowerBoundedInt, UserColors)</li> <li>m_allSidesBlocked (ButtonHandler)</li> <li>m_blockedBotton (ButtonHandler)</li> <li>m_blockedLeft (ButtonHandler)</li> <li>m_blockedRight (ButtonHandler)</li> <li>m_blockedTop (ButtonHandler)</li> <li>m_buttonBaseSize (ButtonHandler)</li> <li>m_buttonExtendedSize (ButtonHandler)</li> <li>m_buttonsAreInside (ButtonHandler)</li> <li>m_horizontalyBlocked (ButtonHandler)</li> <li>m_oneHorizontalBlocked (ButtonHandler)</li> <li>m_screenRegions (ButtonHandler)</li> <li>m_selection (ButtonHandler, CaptureWidget)</li> <li>m_separator (ButtonHandler)</li> <li>m_vectorButtons (ButtonHandler)</li> <li>moveButtonsToPoints (ButtonHandler)</li> <li>m_buttonTypeByName (ButtonListView)</li> <li>m_listButtons (ButtonListView)</li> <li>m_mainColor (CaptureButton, CaptureToolButton)</li> <li>mousePos (CaptureContext)</li> <li>m_data (CaptureRequest)</li> <li>m_delay (CaptureRequest)</li> <li>m_initialSelection (CaptureRequest)</li> <li>m_mode (CaptureRequest)</li> <li>m_path (CaptureRequest)</li> <li>m_pinWindowGeometry (CaptureRequest)</li> <li>m_tasks (CaptureRequest)</li> <li>m_buttonType (CaptureToolButton)</li> <li>m_emergeAnimation (CaptureToolButton)</li> <li>m_tool (CaptureToolButton)</li> <li>mousePressEvent (CaptureToolButton, CaptureWidget, ClickableLabel, ImageLabel, PinWidget)</li> <li>m_captureToolObjects (CaptureToolObjects, CaptureWidget, ModificationCommand)</li> <li>m_imageCache (CaptureToolObjects)</li> <li>m_activeButton (CaptureWidget)</li> <li>m_activeTool (CaptureWidget)</li> <li>m_activeToolIsMoved (CaptureWidget)</li> <li>m_activeToolOffsetToMouseOnStart (CaptureWidget)</li> <li>m_adjustmentButtonPressed (CaptureWidget)</li> <li>m_buttonHandler (CaptureWidget)</li> <li>m_captureDone (CaptureWidget)</li> <li>m_captureToolObjectsBackup (CaptureWidget, ModificationCommand)</li> <li>m_colorPicker (CaptureWidget)</li> <li>m_config (CaptureWidget, ColorPickerEditMode, ColorPickerEditor, ShortcutsWidget)</li> <li>m_configError (CaptureWidget)</li> <li>m_configErrorResolved (CaptureWidget)</li> <li>m_context (CaptureWidget)</li> <li>m_contrastUiColor (CaptureWidget)</li> <li>m_displayGrid (CaptureWidget)</li> <li>m_eventFilter (CaptureWidget)</li> <li>m_existingObjectIsChanged (CaptureWidget)</li> <li>m_gridSize (CaptureWidget)</li> <li>m_helpMessage (CaptureWidget, GeneralConf)</li> <li>m_lastMouseWheel (CaptureWidget)</li> <li>m_magnifier (CaptureWidget)</li> <li>m_mouseIsClicked (CaptureWidget)</li> <li>m_mouseOverHandle (CaptureWidget)</li> <li>m_mousePressedPos (CaptureWidget)</li> <li>m_movingSelection (CaptureWidget)</li> <li>m_newSelection (CaptureWidget)</li> <li>m_notifierBox (CaptureWidget)</li> <li>m_opacity (CaptureWidget, PinWidget)</li> <li>m_panel (CaptureWidget)</li> <li>m_previewEnabled (CaptureWidget)</li> <li>m_sidePanel (CaptureWidget)</li> <li>m_sizeIndButton (CaptureWidget)</li> <li>m_startMove (CaptureWidget)</li> <li>m_startMovePos (CaptureWidget)</li> <li>m_toolSizeByKeyboard (CaptureWidget)</li> <li>m_toolWidget (CaptureWidget, UtilityPanel)</li> <li>m_tools (CaptureWidget)</li> <li>m_uiColor (CaptureWidget, ColorPickerWidget, UIcolorEditor)</li> <li>m_undoStack (CaptureWidget)</li> <li>m_updateNotificationWidget (CaptureWidget)</li> <li>m_xywhDisplay (CaptureWidget)</li> <li>m_xywhTimer (CaptureWidget)</li> <li>makeChild (CaptureWidget)</li> <li>mouseDoubleClickEvent (CaptureWidget, PinWidget)</li> <li>mouseMoveEvent (CaptureWidget, ColorPicker, ImageLabel, PinWidget)</li> <li>mouseReleaseEvent (CaptureWidget, ImageLabel)</li> <li>moveEvent (CaptureWidget, SelectionWidget)</li> <li>m_tempString (CircleCountTool, TextTool)</li> <li>m_valid (CircleCountTool)</li> <li>m_extraZoomActive (ColorGrabWidget)</li> <li>m_magnifierActive (ColorGrabWidget)</li> <li>m_mousePressReceived (ColorGrabWidget)</li> <li>m_previewImage (ColorGrabWidget)</li> <li>m_draggedPresetInitialPos (ColorPickerEditMode)</li> <li>m_isDragging (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_isPressing (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_mouseMovePos (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_mousePressPos (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_addPresetButton (ColorPickerEditor)</li> <li>m_addPresetLabel (ColorPickerEditor)</li> <li>m_colorEdit (ColorPickerEditor)</li> <li>m_colorEditLabel (ColorPickerEditor)</li> <li>m_colorInput (ColorPickerEditor)</li> <li>m_colorList (ColorPickerEditor, ColorPickerWidget)</li> <li>m_colorWheel (ColorPickerEditor, SidePanelWidget, UIcolorEditor)</li> <li>m_colorpicker (ColorPickerEditor)</li> <li>m_deletePresetButton (ColorPickerEditor)</li> <li>m_gLayout (ColorPickerEditor)</li> <li>m_selectedIndex (ColorPickerEditor, ColorPickerWidget)</li> <li>m_updatePresetButton (ColorPickerEditor)</li> <li>m_colorAreaList (ColorPickerWidget)</li> <li>m_colorAreaSize (ColorPickerWidget)</li> <li>m_lastIndex (ColorPickerWidget)</li> <li>m_description (CommandArgument, CommandLineParser, CommandOption)</li> <li>m_name (CommandArgument)</li> <li>m_foundArgs (CommandLineParser)</li> <li>m_foundOptions (CommandLineParser)</li> <li>m_generalErrorMessage (CommandLineParser)</li> <li>m_parseTree (CommandLineParser)</li> <li>m_withHelp (CommandLineParser)</li> <li>m_withVersion (CommandLineParser)</li> <li>m_checker (CommandOption)</li> <li>m_errorMsg (CommandOption)</li> <li>m_names (CommandOption)</li> <li>m_value (CommandOption)</li> <li>m_valueName (CommandOption)</li> <li>m_configWatcher (ConfigHandler)</li> <li>m_errorCheckPending (ConfigHandler)</li> <li>m_hasError (ConfigHandler)</li> <li>m_settings (ConfigHandler)</li> <li>m_skipNextErrorCheck (ConfigHandler)</li> <li>m_filenameEditor (ConfigWindow)</li> <li>m_filenameEditorTab (ConfigWindow)</li> <li>m_generalConfig (ConfigWindow)</li> <li>m_generalConfigTab (ConfigWindow)</li> <li>m_shortcuts (ConfigWindow, ShortcutsWidget)</li> <li>m_shortcutsTab (ConfigWindow)</li> <li>m_visuals (ConfigWindow)</li> <li>m_visualsTab (ConfigWindow)</li> <li>m_appList (DesktopFileParser, WinLnkFileParser)</li> <li>m_defaultIcon (DesktopFileParser)</li> <li>m_localeDescription (DesktopFileParser)</li> <li>m_localeDescriptionShort (DesktopFileParser)</li> <li>m_localeName (DesktopFileParser)</li> <li>m_localeNameShort (DesktopFileParser)</li> <li>makeDraggable (DraggableWidgetMaker)</li> <li>m_timer (ExtendedSlider, LoadSpinner, NotificationWidget, NotifierBox)</li> <li>mappedValue (ExtendedSlider)</li> <li>m_clearButton (FileNameEditor)</li> <li>m_helperButtons (FileNameEditor)</li> <li>m_nameEditor (FileNameEditor)</li> <li>m_nameHandler (FileNameEditor)</li> <li>m_outputLabel (FileNameEditor)</li> <li>m_resetButton (FileNameEditor, GeneralConf)</li> <li>m_saveButton (FileNameEditor)</li> <li>MAX_CHARACTERS (FileNameHandler)</li> <li>m_captureWindow (Flameshot)</li> <li>m_configWindow (Flameshot)</li> <li>m_haveExternalWidget (Flameshot)</li> <li>m_infoWindow (Flameshot)</li> <li>m_launcherWindow (Flameshot)</li> <li>m_origin (Flameshot)</li> <li>m_appLatestUrl (FlameshotDaemon, UpdateNotificationWidget)</li> <li>m_appLatestVersion (FlameshotDaemon, UpdateNotificationWidget)</li> <li>m_clipboardSignalBlocked (FlameshotDaemon)</li> <li>m_hostingClipboard (FlameshotDaemon)</li> <li>m_instance (FlameshotDaemon, OverlayMessage)</li> <li>m_networkCheckUpdates (FlameshotDaemon)</li> <li>m_persist (FlameshotDaemon)</li> <li>m_showCheckAppUpdateStatus (FlameshotDaemon)</li> <li>m_trayIcon (FlameshotDaemon)</li> <li>m_widgets (FlameshotDaemon)</li> <li>m_allowMultipleGuiInstances (GeneralConf)</li> <li>m_antialiasingPinZoom (GeneralConf)</li> <li>m_autoCloseIdleDaemon (GeneralConf)</li> <li>m_autostart (GeneralConf)</li> <li>m_changeSaveButton (GeneralConf)</li> <li>m_checkForUpdates (GeneralConf)</li> <li>m_copyOnDoubleClick (GeneralConf)</li> <li>m_copyPathAfterSave (GeneralConf)</li> <li>m_copyURLAfterUpload (GeneralConf)</li> <li>m_exportButton (GeneralConf)</li> <li>m_historyConfirmationToDelete (GeneralConf)</li> <li>m_importButton (GeneralConf)</li> <li>m_jpegQuality (GeneralConf)</li> <li>m_predefinedColorPaletteLarge (GeneralConf)</li> <li>m_saveAfterCopy (GeneralConf)</li> <li>m_saveLastRegion (GeneralConf)</li> <li>m_savePath (GeneralConf)</li> <li>m_screenshotPathFixedCheck (GeneralConf)</li> <li>m_scrollArea (GeneralConf)</li> <li>m_scrollAreaLayout (GeneralConf)</li> <li>m_selectGeometryLocation (GeneralConf)</li> <li>m_setSaveAsFileExtension (GeneralConf)</li> <li>m_showMagnifier (GeneralConf)</li> <li>m_showSelectionGeometry (GeneralConf)</li> <li>m_showStartupLaunchMessage (GeneralConf)</li> <li>m_showTray (GeneralConf)</li> <li>m_sidePanelButton (GeneralConf)</li> <li>m_squareMagnifier (GeneralConf)</li> <li>m_sysNotifications (GeneralConf)</li> <li>m_undoLimit (GeneralConf)</li> <li>m_uploadClientKey (GeneralConf)</li> <li>m_uploadHistoryMax (GeneralConf)</li> <li>m_uploadWithoutConfirmation (GeneralConf, ImgUploadDialog)</li> <li>m_useJpgForClipboard (GeneralConf)</li> <li>m_xywhTimeout (GeneralConf)</li> <li>m_historyPath (History)</li> <li>m_packedFileName (History)</li> <li>m_thumbs (History)</li> <li>m_unpackedFileName (History)</li> <li>m_DSEffect (ImageLabel)</li> <li>m_dragStartPosition (ImageLabel)</li> <li>m_uploadLabel (ImgUploadDialog)</li> <li>m_copyUrlButton (ImgUploaderBase)</li> <li>m_currentImageName (ImgUploaderBase)</li> <li>m_hLayout (ImgUploaderBase, UIcolorEditor)</li> <li>m_imageURL (ImgUploaderBase)</li> <li>m_infoLabel (ImgUploaderBase)</li> <li>m_notification (ImgUploaderBase, UpdateNotificationWidget)</li> <li>m_openDeleteUrlButton (ImgUploaderBase)</li> <li>m_openUrlButton (ImgUploaderBase)</li> <li>m_saveToFilesystemButton (ImgUploaderBase)</li> <li>m_spinner (ImgUploaderBase)</li> <li>m_toClipboardButton (ImgUploaderBase)</li> <li>m_vLayout (ImgUploaderBase, UIcolorEditor)</li> <li>m_imgUploaderBase (ImgUploaderManager)</li> <li>m_imgUploaderPlugin (ImgUploaderManager)</li> <li>m_urlString (ImgUploaderManager)</li> <li>m_NetworkAM (ImgurUploader)</li> <li>m_fallback (KeySequence)</li> <li>m_frame (LoadSpinner)</li> <li>m_growing (LoadSpinner)</li> <li>m_span (LoadSpinner)</li> <li>m_startAngle (LoadSpinner)</li> <li>MagnifierWidget (MagnifierWidget)</li> <li>m_borderColor (MagnifierWidget)</li> <li>m_devicePixelRatio (MagnifierWidget)</li> <li>m_magOffset (MagnifierWidget)</li> <li>m_magPixels (MagnifierWidget)</li> <li>m_paddedScreenshot (MagnifierWidget)</li> <li>m_pixels (MagnifierWidget)</li> <li>m_screenshot (MagnifierWidget)</li> <li>m_square (MagnifierWidget)</li> <li>magZoom (MagnifierWidget)</li> <li>MarkerTool (MarkerTool)</li> <li>ModificationCommand (ModificationCommand)</li> <li>m_captureWidget (ModificationCommand, UtilityPanel)</li> <li>MoveTool (MoveTool)</li> <li>m_content (NotificationWidget)</li> <li>m_hideAnimation (NotificationWidget, UpdateNotificationWidget, UtilityPanel)</li> <li>m_label (NotificationWidget, PinWidget)</li> <li>m_showAnimation (NotificationWidget, UpdateNotificationWidget, UtilityPanel)</li> <li>m_bgColor (NotifierBox)</li> <li>m_foregroundColor (NotifierBox)</li> <li>m_message (NotifierBox)</li> <li>m_orientation (OrientablePushButton)</li> <li>m_fillColor (OverlayMessage)</li> <li>m_messageStack (OverlayMessage)</li> <li>m_targetArea (OverlayMessage)</li> <li>m_textColor (OverlayMessage)</li> <li>m_geometry (PinTool)</li> <li>m_baseColor (PinWidget)</li> <li>m_currentStepScaleFactor (PinWidget)</li> <li>m_dragStart (PinWidget)</li> <li>m_expanding (PinWidget)</li> <li>m_hoverColor (PinWidget)</li> <li>m_offsetX (PinWidget)</li> <li>m_offsetY (PinWidget)</li> <li>m_rotateFactor (PinWidget)</li> <li>m_scaleFactor (PinWidget)</li> <li>m_shadowEffect (PinWidget)</li> <li>m_sizeChanged (PinWidget)</li> <li>m_currentScreen (QGuiAppCurrentScreen)</li> <li>m_info (ScreenGrabber)</li> <li>m_BArea (SelectionWidget)</li> <li>m_BHandle (SelectionWidget)</li> <li>m_BLArea (SelectionWidget)</li> <li>m_BLHandle (SelectionWidget)</li> <li>m_BRArea (SelectionWidget)</li> <li>m_BRHandle (SelectionWidget)</li> <li>m_LArea (SelectionWidget)</li> <li>m_LHandle (SelectionWidget)</li> <li>m_RArea (SelectionWidget)</li> <li>m_RHandle (SelectionWidget)</li> <li>m_TArea (SelectionWidget)</li> <li>m_THandle (SelectionWidget)</li> <li>m_TLArea (SelectionWidget)</li> <li>m_TLHandle (SelectionWidget)</li> <li>m_TRArea (SelectionWidget)</li> <li>m_TRHandle (SelectionWidget)</li> <li>m_activeSide (SelectionWidget)</li> <li>m_animation (SelectionWidget)</li> <li>m_areaOffset (SelectionWidget)</li> <li>m_dragStartPos (SelectionWidget)</li> <li>m_handleOffset (SelectionWidget)</li> <li>m_idleCentralCursor (SelectionWidget)</li> <li>m_ignoreMouse (SelectionWidget)</li> <li>m_mouseStartMove (SelectionWidget)</li> <li>m_ks (SetShortcutDialog)</li> <li>m_modifier (SetShortcutDialog)</li> <li>m_table (ShortcutsWidget)</li> <li>m_colorGrabButton (SidePanelWidget)</li> <li>m_colorGrabber (SidePanelWidget)</li> <li>m_colorHex (SidePanelWidget)</li> <li>m_colorLabel (SidePanelWidget)</li> <li>m_gridCheck (SidePanelWidget)</li> <li>m_gridSizeSpin (SidePanelWidget)</li> <li>m_revertColor (SidePanelWidget)</li> <li>m_toolSize (SidePanelWidget)</li> <li>m_toolSizeSlider (SidePanelWidget)</li> <li>m_toolSizeSpin (SidePanelWidget)</li> <li>m_buttonData (StrftimeChooserWidget)</li> <li>m_interface (SystemNotification)</li> <li>m_centerAlignButton (TextConfig)</li> <li>m_fontsCB (TextConfig)</li> <li>m_italicButton (TextConfig)</li> <li>m_leftAlignButton (TextConfig)</li> <li>m_rightAlignButton (TextConfig)</li> <li>m_strikeOutButton (TextConfig)</li> <li>m_underlineButton (TextConfig)</li> <li>m_weightButton (TextConfig)</li> <li>m_alignment (TextTool)</li> <li>m_confW (TextTool)</li> <li>m_currentPos (TextTool)</li> <li>m_font (TextTool)</li> <li>m_size (TextTool)</li> <li>m_text (TextTool)</li> <li>m_textArea (TextTool)</li> <li>m_textOld (TextTool)</li> <li>m_widget (TextTool)</li> <li>m_baseSize (TextWidget)</li> <li>m_minSize (TextWidget)</li> <li>m_appUpdates (TrayIcon)</li> <li>m_menu (TrayIcon)</li> <li>m_buttonContrast (UIcolorEditor)</li> <li>m_buttonIconType (UIcolorEditor)</li> <li>m_buttonMainColor (UIcolorEditor)</li> <li>m_contrastColor (UIcolorEditor)</li> <li>m_labelContrast (UIcolorEditor)</li> <li>m_labelMain (UIcolorEditor)</li> <li>m_lastButtonPressed (UIcolorEditor)</li> <li>m_internalPanel (UpdateNotificationWidget, UtilityPanel)</li> <li>m_bottomLayout (UtilityPanel)</li> <li>m_buttonDelete (UtilityPanel)</li> <li>m_buttonMoveDown (UtilityPanel)</li> <li>m_buttonMoveUp (UtilityPanel)</li> <li>m_captureTools (UtilityPanel)</li> <li>m_layersLayout (UtilityPanel)</li> <li>m_upLayout (UtilityPanel)</li> <li>m_buttonList (VisualsEditor)</li> <li>m_colorEditor (VisualsEditor)</li> <li>m_colorEditorTab (VisualsEditor)</li> <li>m_colorpickerEditor (VisualsEditor)</li> <li>m_colorpickerEditorTab (VisualsEditor)</li> <li>m_opacitySlider (VisualsEditor)</li> <li>m_GraphicAppsList (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_members/#n","title":"n","text":"<ul> <li>name (AcceptTool, AppLauncher, ArrowTool, CaptureToolButton, CircleCountTool, CircleTool, CommandArgument, CopyTool, DesktopAppData, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TerminalApp, TextTool, UndoTool)</li> <li>normalizeButtons (ButtonList)</li> <li>newShortcut (CaptureWidget)</li> <li>Node (CommandLineParser::Node)</li> <li>names (CommandOption)</li> <li>nativeEventFilter (GlobalShortcutFilter)</li> <li>nativeKeycode (GlobalShortcutFilter)</li> <li>notification (ImgUploaderBase)</li> <li>NotificationWidget (NotificationWidget)</li> <li>NotifierBox (NotifierBox)</li> </ul>"},{"location":"flameshot/class_members/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (AbstractLogger)</li> <li>origScreenshot (CaptureContext)</li> <li>operator= (CaptureToolObjects, ToolFactory)</li> <li>operator== (CommandArgument, CommandLineParser::Node, CommandOption, DesktopAppData)</li> <li>options (CommandLineParser::Node)</li> <li>operator() (CompareAppByName)</li> <li>Origin (Flameshot)</li> <li>origin (Flameshot)</li> <li>OrgFreedesktopPortalRequestInterface (OrgFreedesktopPortalRequestInterface)</li> <li>OrientablePushButton (OrientablePushButton)</li> <li>Orientation (OrientablePushButton)</li> <li>orientation (OrientablePushButton)</li> <li>OverlayMessage (OverlayMessage)</li> </ul>"},{"location":"flameshot/class_members/#p","title":"p","text":"<ul> <li>paintMousePreview (AbstractActionTool, AbstractTwoPointTool, CircleCountTool, InvertTool, MarkerTool, PencilTool, PixelateTool, TextTool)</li> <li>process (AbstractActionTool, ArrowTool, ButtonList, CircleCountTool, CircleTool, Color, FilenamePattern, InvertTool, KeySequence, LineTool, MarkerTool, PencilTool, PixelateTool, RectangleTool, Region, SaveFileExtension, SelectionTool, TextTool, UserColors, ValueHandler)</li> <li>pos (AbstractPathTool, AbstractTwoPointTool, TextTool)</li> <li>points (AbstractTwoPointTool)</li> <li>positionButtonsInside (ButtonHandler)</li> <li>path (CaptureRequest, History)</li> <li>paddedUpdateRect (CaptureWidget)</li> <li>paintEvent (CaptureWidget, ColorGrabWidget, ColorPickerWidget, LoadSpinner, MagnifierWidget, NotifierBox, OrientablePushButton, OverlayMessage, PinWidget, SelectionWidget)</li> <li>pixmap (CaptureWidget, ImgUploaderBase)</li> <li>processPixmapWithTool (CaptureWidget)</li> <li>pushObjectsStateToUndoStack (CaptureWidget)</li> <li>pushToolToStack (CaptureWidget)</li> <li>parse (CommandLineParser)</li> <li>printHelp (CommandLineParser)</li> <li>printVersion (CommandLineParser)</li> <li>processArgs (CommandLineParser)</li> <li>processIfOptionIsHelp (CommandLineParser)</li> <li>processOptions (CommandLineParser)</li> <li>populate (ConfigResolver)</li> <li>parseDesktopFile (DesktopFileParser)</li> <li>processDirectory (DesktopFileParser, WinLnkFileParser)</li> <li>parseFilename (FileNameHandler)</li> <li>parsedPattern (FileNameHandler)</li> <li>properScreenshotPath (FileNameHandler)</li> <li>packFileName (History)</li> <li>paint (LauncherItemDelegate)</li> <li>pop (OverlayMessage)</li> <li>push (OverlayMessage)</li> <li>pushKeyMap (OverlayMessage)</li> <li>PencilTool (PencilTool)</li> <li>PinTool (PinTool)</li> <li>PinWidget (PinWidget)</li> <li>pinchTriggered (PinWidget)</li> <li>PixelateTool (PixelateTool)</li> <li>parentMouseMoveEvent (SelectionWidget)</li> <li>parentMousePressEvent (SelectionWidget)</li> <li>parentMouseReleaseEvent (SelectionWidget)</li> <li>pushWidget (UtilityPanel)</li> <li>parseLnkFile (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_members/#q","title":"q","text":"<ul> <li>quitIfIdle (FlameshotDaemon)</li> <li>QGuiAppCurrentScreen (QGuiAppCurrentScreen)</li> </ul>"},{"location":"flameshot/class_members/#r","title":"r","text":"<ul> <li>resetRegionTrack (ButtonHandler)</li> <li>representation (ButtonList, Color, KeySequence, UserColors, ValueHandler)</li> <li>request (CaptureContext)</li> <li>removeTask (CaptureRequest)</li> <li>removeAt (CaptureToolObjects)</li> <li>releaseActiveTool (CaptureWidget)</li> <li>removeToolObject (CaptureWidget)</li> <li>resizeEvent (CaptureWidget, ImageLabel, SelectionWidget, TextWidget)</li> <li>restoreCircleCountState (CaptureWidget)</li> <li>repaint (ColorPickerWidget)</li> <li>recursiveParentSearch (CommandLineParser)</li> <li>rootArgument (CommandLineParser)</li> <li>recognizedGeneralOptions (ConfigHandler)</li> <li>recognizedShortcutNames (ConfigHandler)</li> <li>remove (ConfigHandler)</li> <li>resetValue (ConfigHandler)</li> <li>resetLayout (ConfigResolver)</li> <li>resolveAnyConfigErrors (Flameshot)</li> <li>registerShortcut (GlobalShortcutFilter)</li> <li>redo (ModificationCommand)</li> <li>rotateLeft (PinWidget)</li> <li>rotateRight (PinWidget)</li> <li>RectangleTool (RectangleTool)</li> <li>RedoTool (RedoTool)</li> <li>rect (SelectionWidget)</li> </ul>"},{"location":"flameshot/class_members/#s","title":"s","text":"<ul> <li>showMousePreview (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, TextTool)</li> <li>sendMessage (AbstractLogger, SystemNotification)</li> <li>size (AbstractPathTool, AbstractTwoPointTool, ButtonHandler, CaptureToolObjects)</li> <li>setPadding (AbstractTwoPointTool)</li> <li>setButtons (ButtonHandler)</li> <li>setColor (CaptureButton, CaptureToolButton, LoadSpinner)</li> <li>styleSheet (CaptureButton)</li> <li>savePath (CaptureContext)</li> <li>screenshot (CaptureContext)</li> <li>selectedScreenshotArea (CaptureContext)</li> <li>selection (CaptureContext)</li> <li>setInitialSelection (CaptureRequest)</li> <li>setStaticID (CaptureRequest)</li> <li>selectToolItemAtPos (CaptureWidget)</li> <li>setCaptureToolObjects (CaptureWidget)</li> <li>setToolSize (CaptureWidget, ConfigHandler)</li> <li>showAppUpdateNotification (CaptureWidget)</li> <li>showColorPicker (CaptureWidget)</li> <li>showxywh (CaptureWidget)</li> <li>snapToGrid (CaptureWidget)</li> <li>startDrawObjectTool (CaptureWidget)</li> <li>setExtraZoomActive (ColorGrabWidget)</li> <li>setMagnifierActive (ColorGrabWidget)</li> <li>showEvent (ColorGrabWidget, ColorPicker, SelectionWidget, TextWidget)</li> <li>startGrabbing (ColorGrabWidget)</li> <li>setDescription (CommandArgument, CommandLineParser, CommandOption)</li> <li>setName (CommandArgument, CommandOption)</li> <li>setGeneralErrorMessage (CommandLineParser)</li> <li>subNodes (CommandLineParser::Node)</li> <li>setNames (CommandOption)</li> <li>setValue (CommandOption, ConfigHandler)</li> <li>setValueName (CommandOption)</li> <li>setAllTheButtons (ConfigHandler)</li> <li>setDefaultSettings (ConfigHandler)</li> <li>setErrorState (ConfigHandler)</li> <li>setShortcut (ConfigHandler)</li> <li>setShowDesktopNotification (ConfigHandler)</li> <li>setShowStartupLaunchMessage (ConfigHandler)</li> <li>setStartupLaunch (ConfigHandler)</li> <li>setUploadWithoutConfirmation (ConfigHandler)</li> <li>shortcut (ConfigHandler, SetShortcutDialog)</li> <li>showSelectionGeometryHideTime (ConfigHandler)</li> <li>startupLaunch (ConfigHandler)</li> <li>showInTerminal (DesktopAppData)</li> <li>setMapedValue (ExtendedSlider)</li> <li>setExternalWidget (Flameshot)</li> <li>setOrigin (Flameshot)</li> <li>sendTrayNotification (FlameshotDaemon)</li> <li>showUpdateNotificationIfAvailable (FlameshotDaemon)</li> <li>start (FlameshotDaemon, LoadSpinner)</li> <li>save (History)</li> <li>setScaledPixmap (ImageLabel)</li> <li>setScreenshot (ImageLabel)</li> <li>setImageURL (ImgUploaderBase)</li> <li>setInfoLabelText (ImgUploaderBase)</li> <li>setPixmap (ImgUploaderBase)</li> <li>spinner (ImgUploaderBase)</li> <li>sizeHint (LauncherItemDelegate, OrientablePushButton)</li> <li>setHeight (LoadSpinner)</li> <li>setWidth (LoadSpinner)</li> <li>stop (LoadSpinner)</li> <li>showMessage (NotificationWidget)</li> <li>staticInterfaceName (OrgFreedesktopPortalRequestInterface)</li> <li>setOrientation (OrientablePushButton)</li> <li>setVisibility (OverlayMessage)</li> <li>scrollEvent (PinWidget)</li> <li>screenAt (QGuiAppCurrentScreen)</li> <li>SaveTool (SaveTool)</li> <li>ScreenGrabber (ScreenGrabber)</li> <li>screenGeometry (ScreenGrabber)</li> <li>SelectionTool (SelectionTool)</li> <li>SelectionWidget (SelectionWidget)</li> <li>SideType (SelectionWidget)</li> <li>setGeometry (SelectionWidget)</li> <li>setGeometryAnimated (SelectionWidget)</li> <li>setGeometryByKeyboard (SelectionWidget)</li> <li>setIdleCentralCursor (SelectionWidget)</li> <li>setIgnoreMouse (SelectionWidget)</li> <li>SetShortcutDialog (SetShortcutDialog)</li> <li>ShortcutsWidget (ShortcutsWidget)</li> <li>SidePanelWidget (SidePanelWidget)</li> <li>SizeDecreaseTool (SizeDecreaseTool)</li> <li>SizeIncreaseTool (SizeIncreaseTool)</li> <li>StrftimeChooserWidget (StrftimeChooserWidget)</li> <li>String (String)</li> <li>styleHint (StyleOverride)</li> <li>SystemNotification (SystemNotification)</li> <li>setFontFamily (TextConfig)</li> <li>setItalic (TextConfig)</li> <li>setStrikeOut (TextConfig)</li> <li>setTextAlignment (TextConfig)</li> <li>setUnderline (TextConfig)</li> <li>setWeight (TextConfig)</li> <li>setEditMode (TextTool)</li> <li>setFont (TextWidget)</li> <li>startGuiCapture (TrayIcon)</li> <li>setAppLatestVersion (UpdateNotificationWidget)</li> <li>show (UpdateNotificationWidget, UtilityPanel)</li> <li>setEmptyMessage (UploadHistory)</li> <li>setActiveLayer (UtilityPanel)</li> <li>setToolWidget (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#t","title":"t","text":"<ul> <li>Target (AbstractLogger)</li> <li>type (AcceptTool, AppLauncher, ArrowTool, CircleCountTool, CircleTool, CopyTool, ExitTool, HistoryFileName, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>toIntList (ButtonList)</li> <li>toolSize (CaptureContext, ConfigHandler)</li> <li>tasks (CaptureRequest)</li> <li>tool (CaptureToolButton)</li> <li>token (HistoryFileName)</li> <li>TerminalLauncher (TerminalLauncher)</li> <li>TextConfig (TextConfig)</li> <li>TextTool (TextTool)</li> <li>TextWidget (TextWidget)</li> <li>ToolFactory (ToolFactory)</li> <li>TrayIcon (TrayIcon)</li> <li>toolWidget (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#u","title":"u","text":"<ul> <li>updateBlockedSides (ButtonHandler)</li> <li>updateScreenRegions (ButtonHandler)</li> <li>updateActiveButtons (ButtonListView)</li> <li>ui (CaptureLauncher, InfoWindow, UploadHistory, UploadLineItem)</li> <li>updateIcon (CaptureToolButton)</li> <li>uncheckActiveTool (CaptureWidget)</li> <li>updateCursor (CaptureWidget, SelectionWidget)</li> <li>updateLayersPanel (CaptureWidget)</li> <li>updateSelectionState (CaptureWidget)</li> <li>updateSizeIndicator (CaptureWidget)</li> <li>updateTool (CaptureWidget)</li> <li>updateWidget (ColorGrabWidget, ColorPickerWidget)</li> <li>updatePreset (ColorPickerEditor)</li> <li>updateSelection (ColorPickerWidget)</li> <li>unregisterShortcut (GlobalShortcutFilter)</li> <li>unpackFileName (History)</li> <li>upload (ImgUploaderBase, ImgurUploader)</li> <li>uploader (ImgUploaderManager)</li> <li>uploaderPlugin (ImgUploaderManager)</li> <li>url (ImgUploaderManager)</li> <li>updateFrame (LoadSpinner)</li> <li>undo (ModificationCommand)</li> <li>updateGeometry (OverlayMessage)</li> <li>updateAreas (SelectionWidget)</li> <li>updateColorNoWheel (SidePanelWidget)</li> <li>UIcolorEditor (UIcolorEditor)</li> <li>UndoTool (UndoTool)</li> <li>UpdateNotificationWidget (UpdateNotificationWidget)</li> <li>UploadHistory (UploadHistory)</li> <li>UploadLineItem (UploadLineItem)</li> <li>UserColors (UserColors)</li> <li>UtilityPanel (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_members/#v","title":"v","text":"<ul> <li>verticalPoints (ButtonHandler)</li> <li>value (CommandLineParser, CommandOption, ConfigHandler, ValueHandler)</li> <li>valueName (CommandOption)</li> <li>valueHandler (ConfigHandler)</li> <li>VisualsEditor (VisualsEditor)</li> </ul>"},{"location":"flameshot/class_members/#w","title":"w","text":"<ul> <li>warning (AbstractLogger)</li> <li>widget (AppLauncher, TextTool)</li> <li>widgetOffset (CaptureContext)</li> <li>wheelEvent (CaptureWidget)</li> <li>WAYLAND_DISPLAY (DesktopInfo)</li> <li>WM (DesktopInfo)</li> <li>waylandDetected (DesktopInfo, WaylandUtils)</li> <li>windowManager (DesktopInfo)</li> <li>WaylandUtils (WaylandUtils)</li> <li>WinLnkFileParser (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_members/#x","title":"x","text":"<ul> <li>XDG_CURRENT_DESKTOP (DesktopInfo)</li> <li>XDG_SESSION_TYPE (DesktopInfo)</li> <li>xywh_position (GeneralConf)</li> </ul>"},{"location":"flameshot/class_members/#_1","title":"~","text":"<ul> <li>~AbstractLogger (AbstractLogger)</li> <li>~CaptureLauncher (CaptureLauncher)</li> <li>~CaptureToolButton (CaptureToolButton)</li> <li>~CaptureWidget (CaptureWidget)</li> <li>~FlameshotDBusAdapter (FlameshotDBusAdapter)</li> <li>~InfoWindow (InfoWindow)</li> <li>~OrgFreedesktopPortalRequestInterface (OrgFreedesktopPortalRequestInterface)</li> <li>~TextTool (TextTool)</li> <li>~TrayIcon (TrayIcon)</li> <li>~UploadHistory (UploadHistory)</li> <li>~UploadLineItem (UploadLineItem)</li> </ul>"},{"location":"flameshot/class_members/#_","title":"_","text":"<ul> <li>_updateComponents (GeneralConf)</li> </ul>"},{"location":"flameshot/class_member_functions/","title":"Class Member Functions","text":""},{"location":"flameshot/class_member_functions/#a","title":"a","text":"<ul> <li>AbstractActionTool (AbstractActionTool)</li> <li>AbstractLogger (AbstractLogger)</li> <li>addOutputString (AbstractLogger)</li> <li>attachNotificationPath (AbstractLogger)</li> <li>AbstractPathTool (AbstractPathTool)</li> <li>addPoint (AbstractPathTool)</li> <li>AbstractTwoPointTool (AbstractTwoPointTool)</li> <li>adjustedVector (AbstractTwoPointTool)</li> <li>AcceptTool (AcceptTool)</li> <li>AppLauncher (AppLauncher)</li> <li>AppLauncherWidget (AppLauncherWidget)</li> <li>addAppsToListWidget (AppLauncherWidget)</li> <li>ArrowTool (ArrowTool)</li> <li>adjustHorizontalCenter (ButtonHandler)</li> <li>addPinTask (CaptureRequest)</li> <li>addSaveTask (CaptureRequest)</li> <li>addTask (CaptureRequest)</li> <li>animatedShow (CaptureToolButton, NotificationWidget)</li> <li>append (CaptureToolObjects)</li> <li>at (CaptureToolObjects)</li> <li>activeButtonTool (CaptureWidget)</li> <li>activeButtonToolType (CaptureWidget)</li> <li>activeToolObject (CaptureWidget)</li> <li>addPreset (ColorPickerEditor)</li> <li>AddArgument (CommandLineParser)</li> <li>AddOption (CommandLineParser)</li> <li>AddOptions (CommandLineParser)</li> <li>addHelpOption (CommandLineParser)</li> <li>addVersionOption (CommandLineParser)</li> <li>addChecker (CommandOption)</li> <li>assertKeyRecognized (ConfigHandler)</li> <li>autoNumerateDuplicate (FileNameHandler)</li> <li>attachPin (FlameshotDaemon)</li> <li>attachScreenshotToClipboard (FlameshotDaemon)</li> <li>attachTextToClipboard (FlameshotDaemon)</li> <li>animatedHide (NotificationWidget)</li> <li>appendShortcut (ShortcutsWidget)</li> <li>adjustSize (TextWidget)</li> <li>appUpdates (TrayIcon)</li> <li>addLine (UploadHistory)</li> <li>activeLayerIndex (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#b","title":"b","text":"<ul> <li>boundingRect (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, ArrowTool, CircleCountTool, InvertTool, OverlayMessage, PixelateTool, TextTool)</li> <li>Bool (Bool)</li> <li>BoundedInt (BoundedInt)</li> <li>ButtonHandler (ButtonHandler)</li> <li>buttonsAreInside (ButtonHandler)</li> <li>ButtonListView (ButtonListView)</li> <li>baseName (ConfigHandler)</li> </ul>"},{"location":"flameshot/class_member_functions/#c","title":"c","text":"<ul> <li>closeOnButtonPressed (AbstractPathTool, AbstractTwoPointTool, AcceptTool, AppLauncher, CopyTool, ExitTool, ImgUploaderTool, MoveTool, PinTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>copyParams (AbstractPathTool, AbstractTwoPointTool, ArrowTool, CircleCountTool, TextTool)</li> <li>color (AbstractTwoPointTool, ColorGrabWidget)</li> <li>copy (AcceptTool, AppLauncher, ArrowTool, CircleCountTool, CircleTool, CopyTool, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>configureListView (AppLauncherWidget)</li> <li>check (Bool, BoundedInt, ButtonList, Color, ExistingDir, FilenamePattern, KeySequence, LowerBoundedInt, Region, SaveFileExtension, String, UserColors, ValueHandler)</li> <li>calculateShift (ButtonHandler)</li> <li>contains (ButtonHandler)</li> <li>CaptureButton (CaptureButton)</li> <li>CaptureLauncher (CaptureLauncher)</li> <li>connectCaptureSlots (CaptureLauncher)</li> <li>CaptureRequest (CaptureRequest)</li> <li>captureMode (CaptureRequest)</li> <li>CaptureToolButton (CaptureToolButton)</li> <li>CaptureToolObjects (CaptureToolObjects)</li> <li>captureToolObjects (CaptureToolObjects)</li> <li>clear (CaptureToolObjects)</li> <li>CaptureWidget (CaptureWidget)</li> <li>changeEvent (CaptureWidget)</li> <li>CircleCountTool (CircleCountTool)</li> <li>CircleTool (CircleTool)</li> <li>ClickableLabel (ClickableLabel)</li> <li>Color (Color)</li> <li>ColorGrabWidget (ColorGrabWidget)</li> <li>cursorPos (ColorGrabWidget)</li> <li>ColorPicker (ColorPicker)</li> <li>ColorPickerEditMode (ColorPickerEditMode)</li> <li>ColorPickerEditor (ColorPickerEditor)</li> <li>ColorPickerWidget (ColorPickerWidget)</li> <li>CommandArgument (CommandArgument)</li> <li>CommandLineParser (CommandLineParser)</li> <li>CommandOption (CommandOption)</li> <li>checkValue (CommandOption)</li> <li>ConfigErrorDetails (ConfigErrorDetails)</li> <li>CONFIG_GETTER_SETTER (ConfigHandler)</li> <li>ConfigHandler (ConfigHandler)</li> <li>checkAndHandleError (ConfigHandler)</li> <li>checkForErrors (ConfigHandler)</li> <li>checkSemantics (ConfigHandler)</li> <li>checkShortcutConflicts (ConfigHandler)</li> <li>checkUnrecognizedSettings (ConfigHandler)</li> <li>cleanUnusedKeys (ConfigHandler)</li> <li>configFilePath (ConfigHandler)</li> <li>ConfigResolver (ConfigResolver)</li> <li>ConfigWindow (ConfigWindow)</li> <li>CopyTool (CopyTool)</li> <li>call (FlameshotDaemon)</li> <li>checkDBusConnection (FlameshotDaemon)</li> <li>copyToClipboard (FlameshotDaemon)</li> <li>createMethodCall (FlameshotDaemon)</li> <li>createPin (FlameshotDaemon)</li> <li>chooseFolder (GeneralConf)</li> <li>compileFromKeyMap (OverlayMessage)</li> <li>closePin (PinWidget)</li> <li>currentScreen (QGuiAppCurrentScreen)</li> <li>closeEditor (TextTool)</li> <li>configurationWidget (TextTool)</li> <li>CreateTool (ToolFactory)</li> <li>clearToolWidget (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#d","title":"d","text":"<ul> <li>description (AcceptTool, AppLauncher, ArrowTool, CaptureToolButton, CircleCountTool, CircleTool, CommandArgument, CommandOption, CopyTool, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>disconnectCaptureSlots (CaptureLauncher)</li> <li>data (CaptureRequest)</li> <li>delay (CaptureRequest)</li> <li>drawErrorMessage (CaptureWidget)</li> <li>drawInactiveRegion (CaptureWidget)</li> <li>drawObjectSelection (CaptureWidget, TextTool)</li> <li>drawToolsData (CaptureWidget)</li> <li>deletePreset (ColorPickerEditor)</li> <li>dashedNames (CommandOption)</li> <li>DesktopAppData (DesktopAppData)</li> <li>DesktopFileParser (DesktopFileParser)</li> <li>DesktopInfo (DesktopInfo)</li> <li>DraggableWidgetMaker (DraggableWidgetMaker)</li> <li>deleteImage (ImgUploaderBase, ImgurUploader)</li> <li>drawSearchArea (InvertTool, PixelateTool)</li> <li>drawMagnifier (MagnifierWidget)</li> <li>drawMagnifierCircle (MagnifierWidget)</li> <li>decreaseOpacity (PinWidget)</li> <li>desktopGeometry (ScreenGrabber)</li> </ul>"},{"location":"flameshot/class_member_functions/#e","title":"e","text":"<ul> <li>enableMessageHeader (AbstractLogger)</li> <li>error (AbstractLogger)</li> <li>expected (Bool, BoundedInt, ButtonList, Color, ExistingDir, FilenamePattern, KeySequence, LowerBoundedInt, SaveFileExtension, String, UserColors, ValueHandler)</li> <li>ensureSelectionMinimunSize (ButtonHandler)</li> <li>expandSelection (ButtonHandler)</li> <li>extendedRect (CaptureWidget)</li> <li>extendedSelection (CaptureWidget)</li> <li>eventFilter (ColorGrabWidget, ColorPickerEditMode, DraggableWidgetMaker, HoverEventFilter, SelectionWidget, SidePanelWidget)</li> <li>errorMsg (CommandOption)</li> <li>ensureFileWatched (ConfigHandler)</li> <li>errorMessage (ConfigHandler)</li> <li>ExitTool (ExitTool)</li> <li>ExtendedSlider (ExtendedSlider)</li> <li>enableTrayIcon (FlameshotDaemon)</li> <li>enterEvent (NotifierBox, PinWidget)</li> <li>event (PinWidget)</li> <li>enableCheckUpdatesAction (TrayIcon)</li> </ul>"},{"location":"flameshot/class_member_functions/#f","title":"f","text":"<ul> <li>fallback (Bool, BoundedInt, ButtonList, Color, ExistingDir, FilenamePattern, KeySequence, LowerBoundedInt, String, UserColors, ValueHandler)</li> <li>fromIntList (ButtonList)</li> <li>find (CaptureToolObjects)</li> <li>findWithRadius (CaptureToolObjects)</li> <li>finalize (ColorGrabWidget)</li> <li>findParent (CommandLineParser)</li> <li>filenamePatternDefault (ConfigHandler)</li> <li>FileNameEditor (FileNameEditor)</li> <li>FileNameHandler (FileNameHandler)</li> <li>Flameshot (Flameshot)</li> <li>FlameshotDBusAdapter (FlameshotDBusAdapter)</li> <li>FlameshotDaemon (FlameshotDaemon)</li> <li>freeDesktopPortal (ScreenGrabber)</li> <li>fullGeometry (SelectionWidget)</li> <li>finalizeGrab (SidePanelWidget)</li> <li>fillCaptureTools (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#g","title":"g","text":"<ul> <li>globalStyleSheet (CaptureButton)</li> <li>getIterableButtonTypes (CaptureToolButton)</li> <li>getPriorityByButton (CaptureToolButton)</li> <li>getColorAtPoint (ColorGrabWidget)</li> <li>getDefaultLargeColorPalette (ColorPickerWidget)</li> <li>getDefaultSmallColorPalette (ColorPickerWidget)</li> <li>getInstance (ConfigHandler)</li> <li>getAppsByCategory (DesktopFileParser, WinLnkFileParser)</li> <li>GeneralConf (GeneralConf)</li> <li>GlobalShortcutFilter (GlobalShortcutFilter)</li> <li>getNativeModifier (GlobalShortcutFilter)</li> <li>gestureEvent (PinWidget)</li> <li>generalGrimScreenshot (ScreenGrabber)</li> <li>grabEntireDesktop (ScreenGrabber)</li> <li>grabScreen (ScreenGrabber)</li> <li>geometry (SelectionWidget)</li> <li>getMouseSide (SelectionWidget)</li> <li>getPreferedTerminal (TerminalLauncher)</li> <li>getAllUsersStartMenuPath (WinLnkFileParser)</li> <li>getImageFileExtAssociates (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_member_functions/#h","title":"h","text":"<ul> <li>hideSectionUnderMouse (ButtonHandler)</li> <li>horizontalPoints (ButtonHandler)</li> <li>hideEvent (ColorPicker, NotifierBox, SelectionWidget, SidePanelWidget)</li> <li>hasError (ConfigHandler)</li> <li>haveExternalWidget (Flameshot)</li> <li>History (History)</li> <li>history (History)</li> <li>HoverEventFilter (HoverEventFilter)</li> <li>handlerAreas (SelectionWidget)</li> <li>hide (UpdateNotificationWidget, UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#i","title":"i","text":"<ul> <li>isSelectable (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, MoveTool, TextTool)</li> <li>isValid (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, CircleCountTool, TextTool)</li> <li>info (AbstractLogger, CircleCountTool, TextTool)</li> <li>icon (AcceptTool, AppLauncher, ArrowTool, CaptureToolButton, CircleCountTool, CircleTool, CopyTool, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>initAppMap (AppLauncherWidget)</li> <li>initListWidget (AppLauncherWidget)</li> <li>init (ButtonHandler, CaptureButton, ImgUploaderManager, OverlayMessage)</li> <li>intersectWithAreas (ButtonHandler)</li> <li>isVisible (ButtonHandler, UtilityPanel)</li> <li>initButtonList (ButtonListView)</li> <li>id (CaptureRequest)</li> <li>initialSelection (CaptureRequest)</li> <li>initButton (CaptureToolButton)</li> <li>insert (CaptureToolObjects)</li> <li>initButtons (CaptureWidget, UIcolorEditor)</li> <li>initContext (CaptureWidget)</li> <li>initHelpMessage (CaptureWidget)</li> <li>initPanel (CaptureWidget)</li> <li>initSelection (CaptureWidget)</li> <li>initShortcuts (CaptureWidget)</li> <li>initColorPicker (ColorPickerWidget)</li> <li>isRoot (CommandArgument)</li> <li>isSet (CommandLineParser)</li> <li>isShortcut (ConfigHandler)</li> <li>initErrorIndicator (ConfigWindow)</li> <li>initLayout (FileNameEditor)</li> <li>initWidgets (FileNameEditor, VisualsEditor)</li> <li>instance (Flameshot, FlameshotDaemon, OverlayMessage)</li> <li>initTrayIcon (FlameshotDaemon, TrayIcon)</li> <li>isThisInstanceHostingWidgets (FlameshotDaemon)</li> <li>initAllowMultipleGuiInstances (GeneralConf)</li> <li>initAntialiasingPinZoom (GeneralConf)</li> <li>initAutoCloseIdleDaemon (GeneralConf)</li> <li>initAutostart (GeneralConf)</li> <li>initCheckForUpdates (GeneralConf)</li> <li>initConfigButtons (GeneralConf)</li> <li>initCopyAndCloseAfterUpload (GeneralConf)</li> <li>initCopyOnDoubleClick (GeneralConf)</li> <li>initCopyPathAfterSave (GeneralConf)</li> <li>initHistoryConfirmationToDelete (GeneralConf)</li> <li>initJpegQuality (GeneralConf)</li> <li>initPredefinedColorPaletteLarge (GeneralConf)</li> <li>initSaveAfterCopy (GeneralConf)</li> <li>initSaveLastRegion (GeneralConf)</li> <li>initScrollArea (GeneralConf)</li> <li>initShowDesktopNotification (GeneralConf)</li> <li>initShowHelp (GeneralConf)</li> <li>initShowMagnifier (GeneralConf)</li> <li>initShowSelectionGeometry (GeneralConf)</li> <li>initShowSidePanelButton (GeneralConf)</li> <li>initShowStartupLaunchMessage (GeneralConf)</li> <li>initShowTrayIcon (GeneralConf)</li> <li>initSquareMagnifier (GeneralConf)</li> <li>initUndoLimit (GeneralConf)</li> <li>initUploadClientSecret (GeneralConf)</li> <li>initUploadHistoryMax (GeneralConf)</li> <li>initUploadWithoutConfirmation (GeneralConf)</li> <li>initUseJpgForClipboard (GeneralConf)</li> <li>ImageLabel (ImageLabel)</li> <li>ImgUploadDialog (ImgUploadDialog)</li> <li>ImgUploaderBase (ImgUploaderBase)</li> <li>imageURL (ImgUploaderBase)</li> <li>ImgUploaderManager (ImgUploaderManager)</li> <li>ImgUploaderTool (ImgUploaderTool)</li> <li>ImgurUploader (ImgurUploader)</li> <li>InfoWindow (InfoWindow)</li> <li>InvertTool (InvertTool)</li> <li>increaseOpacity (PinWidget)</li> <li>initInfoTable (ShortcutsWidget)</li> <li>isChanged (TextTool)</li> <li>initMenu (TrayIcon)</li> <li>initColorWheel (UIcolorEditor)</li> <li>initInternalPanel (UpdateNotificationWidget, UtilityPanel)</li> <li>initOpacitySlider (VisualsEditor)</li> </ul>"},{"location":"flameshot/class_member_functions/#k","title":"k","text":"<ul> <li>keyPressEvent (AppLauncherWidget, CaptureWidget, ConfigWindow, InfoWindow, PinWidget, SetShortcutDialog)</li> <li>keyReleaseEvent (CaptureWidget, SetShortcutDialog)</li> <li>keysFromGroup (ConfigHandler)</li> <li>KeySequence (KeySequence)</li> </ul>"},{"location":"flameshot/class_member_functions/#l","title":"l","text":"<ul> <li>layout (ConfigResolver)</li> <li>LauncherItemDelegate (LauncherItemDelegate)</li> <li>LineTool (LineTool)</li> <li>LoadSpinner (LoadSpinner)</li> <li>LowerBoundedInt (LowerBoundedInt)</li> <li>leaveEvent (PinWidget)</li> <li>loadShortcuts (ShortcutsWidget)</li> <li>launchDetached (TerminalLauncher)</li> <li>loadHistory (UploadHistory)</li> </ul>"},{"location":"flameshot/class_member_functions/#m","title":"m","text":"<ul> <li>messageHeader (AbstractLogger)</li> <li>mousePreviewRect (AbstractPathTool, AbstractTwoPointTool, CircleCountTool, MarkerTool)</li> <li>move (AbstractPathTool, AbstractTwoPointTool, TextTool)</li> <li>moveButtonsToPoints (ButtonHandler)</li> <li>mousePressEvent (CaptureToolButton, CaptureWidget, ClickableLabel, ImageLabel, PinWidget)</li> <li>makeChild (CaptureWidget)</li> <li>mouseDoubleClickEvent (CaptureWidget, PinWidget)</li> <li>mouseMoveEvent (CaptureWidget, ColorPicker, ImageLabel, PinWidget)</li> <li>mouseReleaseEvent (CaptureWidget, ImageLabel)</li> <li>moveEvent (CaptureWidget, SelectionWidget)</li> <li>makeDraggable (DraggableWidgetMaker)</li> <li>mappedValue (ExtendedSlider)</li> <li>MagnifierWidget (MagnifierWidget)</li> <li>MarkerTool (MarkerTool)</li> <li>ModificationCommand (ModificationCommand)</li> <li>MoveTool (MoveTool)</li> </ul>"},{"location":"flameshot/class_member_functions/#n","title":"n","text":"<ul> <li>name (AcceptTool, AppLauncher, ArrowTool, CaptureToolButton, CircleCountTool, CircleTool, CommandArgument, CopyTool, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>normalizeButtons (ButtonList)</li> <li>newShortcut (CaptureWidget)</li> <li>Node (CommandLineParser::Node)</li> <li>names (CommandOption)</li> <li>nativeEventFilter (GlobalShortcutFilter)</li> <li>nativeKeycode (GlobalShortcutFilter)</li> <li>notification (ImgUploaderBase)</li> <li>NotificationWidget (NotificationWidget)</li> <li>NotifierBox (NotifierBox)</li> </ul>"},{"location":"flameshot/class_member_functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (AbstractLogger)</li> <li>operator= (CaptureToolObjects, ToolFactory)</li> <li>operator== (CommandArgument, CommandLineParser::Node, CommandOption, DesktopAppData)</li> <li>operator() (CompareAppByName)</li> <li>origin (Flameshot)</li> <li>OrgFreedesktopPortalRequestInterface (OrgFreedesktopPortalRequestInterface)</li> <li>OrientablePushButton (OrientablePushButton)</li> <li>orientation (OrientablePushButton)</li> <li>OverlayMessage (OverlayMessage)</li> </ul>"},{"location":"flameshot/class_member_functions/#p","title":"p","text":"<ul> <li>paintMousePreview (AbstractActionTool, AbstractTwoPointTool, CircleCountTool, InvertTool, MarkerTool, PencilTool, PixelateTool, TextTool)</li> <li>process (AbstractActionTool, ArrowTool, ButtonList, CircleCountTool, CircleTool, Color, FilenamePattern, InvertTool, KeySequence, LineTool, MarkerTool, PencilTool, PixelateTool, RectangleTool, Region, SaveFileExtension, SelectionTool, TextTool, UserColors, ValueHandler)</li> <li>pos (AbstractPathTool, AbstractTwoPointTool, TextTool)</li> <li>points (AbstractTwoPointTool)</li> <li>positionButtonsInside (ButtonHandler)</li> <li>path (CaptureRequest, History)</li> <li>paddedUpdateRect (CaptureWidget)</li> <li>paintEvent (CaptureWidget, ColorGrabWidget, ColorPickerWidget, LoadSpinner, MagnifierWidget, NotifierBox, OrientablePushButton, OverlayMessage, PinWidget, SelectionWidget)</li> <li>pixmap (CaptureWidget, ImgUploaderBase)</li> <li>processPixmapWithTool (CaptureWidget)</li> <li>pushObjectsStateToUndoStack (CaptureWidget)</li> <li>pushToolToStack (CaptureWidget)</li> <li>parse (CommandLineParser)</li> <li>printHelp (CommandLineParser)</li> <li>printVersion (CommandLineParser)</li> <li>processArgs (CommandLineParser)</li> <li>processIfOptionIsHelp (CommandLineParser)</li> <li>processOptions (CommandLineParser)</li> <li>populate (ConfigResolver)</li> <li>parseDesktopFile (DesktopFileParser)</li> <li>processDirectory (DesktopFileParser, WinLnkFileParser)</li> <li>parseFilename (FileNameHandler)</li> <li>parsedPattern (FileNameHandler)</li> <li>properScreenshotPath (FileNameHandler)</li> <li>packFileName (History)</li> <li>paint (LauncherItemDelegate)</li> <li>pop (OverlayMessage)</li> <li>push (OverlayMessage)</li> <li>pushKeyMap (OverlayMessage)</li> <li>PencilTool (PencilTool)</li> <li>PinTool (PinTool)</li> <li>PinWidget (PinWidget)</li> <li>pinchTriggered (PinWidget)</li> <li>PixelateTool (PixelateTool)</li> <li>parentMouseMoveEvent (SelectionWidget)</li> <li>parentMousePressEvent (SelectionWidget)</li> <li>parentMouseReleaseEvent (SelectionWidget)</li> <li>pushWidget (UtilityPanel)</li> <li>parseLnkFile (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_member_functions/#q","title":"q","text":"<ul> <li>quitIfIdle (FlameshotDaemon)</li> <li>QGuiAppCurrentScreen (QGuiAppCurrentScreen)</li> </ul>"},{"location":"flameshot/class_member_functions/#r","title":"r","text":"<ul> <li>resetRegionTrack (ButtonHandler)</li> <li>representation (ButtonList, Color, KeySequence, UserColors, ValueHandler)</li> <li>removeTask (CaptureRequest)</li> <li>removeAt (CaptureToolObjects)</li> <li>releaseActiveTool (CaptureWidget)</li> <li>removeToolObject (CaptureWidget)</li> <li>resizeEvent (CaptureWidget, ImageLabel, SelectionWidget, TextWidget)</li> <li>restoreCircleCountState (CaptureWidget)</li> <li>repaint (ColorPickerWidget)</li> <li>recursiveParentSearch (CommandLineParser)</li> <li>rootArgument (CommandLineParser)</li> <li>recognizedGeneralOptions (ConfigHandler)</li> <li>recognizedShortcutNames (ConfigHandler)</li> <li>remove (ConfigHandler)</li> <li>resetValue (ConfigHandler)</li> <li>resetLayout (ConfigResolver)</li> <li>resolveAnyConfigErrors (Flameshot)</li> <li>registerShortcut (GlobalShortcutFilter)</li> <li>redo (ModificationCommand)</li> <li>rotateLeft (PinWidget)</li> <li>rotateRight (PinWidget)</li> <li>RectangleTool (RectangleTool)</li> <li>RedoTool (RedoTool)</li> <li>rect (SelectionWidget)</li> </ul>"},{"location":"flameshot/class_member_functions/#s","title":"s","text":"<ul> <li>showMousePreview (AbstractActionTool, AbstractPathTool, AbstractTwoPointTool, TextTool)</li> <li>sendMessage (AbstractLogger, SystemNotification)</li> <li>size (AbstractPathTool, AbstractTwoPointTool, ButtonHandler, CaptureToolObjects)</li> <li>setPadding (AbstractTwoPointTool)</li> <li>setButtons (ButtonHandler)</li> <li>setColor (CaptureButton, CaptureToolButton, LoadSpinner)</li> <li>styleSheet (CaptureButton)</li> <li>selectedScreenshotArea (CaptureContext)</li> <li>setInitialSelection (CaptureRequest)</li> <li>setStaticID (CaptureRequest)</li> <li>selectToolItemAtPos (CaptureWidget)</li> <li>setCaptureToolObjects (CaptureWidget)</li> <li>setToolSize (CaptureWidget, ConfigHandler)</li> <li>showAppUpdateNotification (CaptureWidget)</li> <li>showColorPicker (CaptureWidget)</li> <li>showxywh (CaptureWidget)</li> <li>snapToGrid (CaptureWidget)</li> <li>startDrawObjectTool (CaptureWidget)</li> <li>setExtraZoomActive (ColorGrabWidget)</li> <li>setMagnifierActive (ColorGrabWidget)</li> <li>showEvent (ColorGrabWidget, ColorPicker, SelectionWidget, TextWidget)</li> <li>startGrabbing (ColorGrabWidget)</li> <li>setDescription (CommandArgument, CommandLineParser, CommandOption)</li> <li>setName (CommandArgument, CommandOption)</li> <li>setGeneralErrorMessage (CommandLineParser)</li> <li>setNames (CommandOption)</li> <li>setValue (CommandOption, ConfigHandler)</li> <li>setValueName (CommandOption)</li> <li>setAllTheButtons (ConfigHandler)</li> <li>setDefaultSettings (ConfigHandler)</li> <li>setErrorState (ConfigHandler)</li> <li>setShortcut (ConfigHandler)</li> <li>setStartupLaunch (ConfigHandler)</li> <li>shortcut (ConfigHandler, SetShortcutDialog)</li> <li>startupLaunch (ConfigHandler)</li> <li>setMapedValue (ExtendedSlider)</li> <li>setExternalWidget (Flameshot)</li> <li>setOrigin (Flameshot)</li> <li>sendTrayNotification (FlameshotDaemon)</li> <li>showUpdateNotificationIfAvailable (FlameshotDaemon)</li> <li>start (FlameshotDaemon, LoadSpinner)</li> <li>save (History)</li> <li>setScaledPixmap (ImageLabel)</li> <li>setScreenshot (ImageLabel)</li> <li>setImageURL (ImgUploaderBase)</li> <li>setInfoLabelText (ImgUploaderBase)</li> <li>setPixmap (ImgUploaderBase)</li> <li>spinner (ImgUploaderBase)</li> <li>sizeHint (LauncherItemDelegate, OrientablePushButton)</li> <li>setHeight (LoadSpinner)</li> <li>setWidth (LoadSpinner)</li> <li>stop (LoadSpinner)</li> <li>showMessage (NotificationWidget)</li> <li>staticInterfaceName (OrgFreedesktopPortalRequestInterface)</li> <li>setOrientation (OrientablePushButton)</li> <li>setVisibility (OverlayMessage)</li> <li>scrollEvent (PinWidget)</li> <li>screenAt (QGuiAppCurrentScreen)</li> <li>SaveTool (SaveTool)</li> <li>ScreenGrabber (ScreenGrabber)</li> <li>screenGeometry (ScreenGrabber)</li> <li>SelectionTool (SelectionTool)</li> <li>SelectionWidget (SelectionWidget)</li> <li>setGeometry (SelectionWidget)</li> <li>setGeometryAnimated (SelectionWidget)</li> <li>setGeometryByKeyboard (SelectionWidget)</li> <li>setIdleCentralCursor (SelectionWidget)</li> <li>setIgnoreMouse (SelectionWidget)</li> <li>SetShortcutDialog (SetShortcutDialog)</li> <li>ShortcutsWidget (ShortcutsWidget)</li> <li>SidePanelWidget (SidePanelWidget)</li> <li>SizeDecreaseTool (SizeDecreaseTool)</li> <li>SizeIncreaseTool (SizeIncreaseTool)</li> <li>StrftimeChooserWidget (StrftimeChooserWidget)</li> <li>String (String)</li> <li>styleHint (StyleOverride)</li> <li>SystemNotification (SystemNotification)</li> <li>setFontFamily (TextConfig)</li> <li>setItalic (TextConfig)</li> <li>setStrikeOut (TextConfig)</li> <li>setTextAlignment (TextConfig)</li> <li>setUnderline (TextConfig)</li> <li>setWeight (TextConfig)</li> <li>setEditMode (TextTool)</li> <li>setFont (TextWidget)</li> <li>startGuiCapture (TrayIcon)</li> <li>setAppLatestVersion (UpdateNotificationWidget)</li> <li>show (UpdateNotificationWidget, UtilityPanel)</li> <li>setEmptyMessage (UploadHistory)</li> <li>setActiveLayer (UtilityPanel)</li> <li>setToolWidget (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#t","title":"t","text":"<ul> <li>type (AcceptTool, AppLauncher, ArrowTool, CircleCountTool, CircleTool, CopyTool, ExitTool, ImgUploaderTool, InvertTool, LineTool, MarkerTool, MoveTool, PencilTool, PinTool, PixelateTool, RectangleTool, RedoTool, SaveTool, SelectionTool, SizeDecreaseTool, SizeIncreaseTool, TextTool, UndoTool)</li> <li>toIntList (ButtonList)</li> <li>tasks (CaptureRequest)</li> <li>tool (CaptureToolButton)</li> <li>toolSize (ConfigHandler)</li> <li>TerminalLauncher (TerminalLauncher)</li> <li>TextConfig (TextConfig)</li> <li>TextTool (TextTool)</li> <li>TextWidget (TextWidget)</li> <li>ToolFactory (ToolFactory)</li> <li>TrayIcon (TrayIcon)</li> <li>toolWidget (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#u","title":"u","text":"<ul> <li>updateBlockedSides (ButtonHandler)</li> <li>updateScreenRegions (ButtonHandler)</li> <li>updateActiveButtons (ButtonListView)</li> <li>updateIcon (CaptureToolButton)</li> <li>uncheckActiveTool (CaptureWidget)</li> <li>updateCursor (CaptureWidget, SelectionWidget)</li> <li>updateLayersPanel (CaptureWidget)</li> <li>updateSelectionState (CaptureWidget)</li> <li>updateSizeIndicator (CaptureWidget)</li> <li>updateTool (CaptureWidget)</li> <li>updateWidget (ColorGrabWidget, ColorPickerWidget)</li> <li>updatePreset (ColorPickerEditor)</li> <li>updateSelection (ColorPickerWidget)</li> <li>unregisterShortcut (GlobalShortcutFilter)</li> <li>unpackFileName (History)</li> <li>upload (ImgUploaderBase, ImgurUploader)</li> <li>uploader (ImgUploaderManager)</li> <li>uploaderPlugin (ImgUploaderManager)</li> <li>url (ImgUploaderManager)</li> <li>updateFrame (LoadSpinner)</li> <li>undo (ModificationCommand)</li> <li>updateGeometry (OverlayMessage)</li> <li>updateAreas (SelectionWidget)</li> <li>updateColorNoWheel (SidePanelWidget)</li> <li>UIcolorEditor (UIcolorEditor)</li> <li>UndoTool (UndoTool)</li> <li>UpdateNotificationWidget (UpdateNotificationWidget)</li> <li>UploadHistory (UploadHistory)</li> <li>UploadLineItem (UploadLineItem)</li> <li>UserColors (UserColors)</li> <li>UtilityPanel (UtilityPanel)</li> </ul>"},{"location":"flameshot/class_member_functions/#v","title":"v","text":"<ul> <li>verticalPoints (ButtonHandler)</li> <li>value (CommandLineParser, CommandOption, ConfigHandler, ValueHandler)</li> <li>valueName (CommandOption)</li> <li>valueHandler (ConfigHandler)</li> <li>VisualsEditor (VisualsEditor)</li> </ul>"},{"location":"flameshot/class_member_functions/#w","title":"w","text":"<ul> <li>warning (AbstractLogger)</li> <li>widget (AppLauncher, TextTool)</li> <li>wheelEvent (CaptureWidget)</li> <li>waylandDetected (DesktopInfo, WaylandUtils)</li> <li>windowManager (DesktopInfo)</li> <li>WaylandUtils (WaylandUtils)</li> <li>WinLnkFileParser (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_member_functions/#_1","title":"~","text":"<ul> <li>~AbstractLogger (AbstractLogger)</li> <li>~CaptureLauncher (CaptureLauncher)</li> <li>~CaptureToolButton (CaptureToolButton)</li> <li>~CaptureWidget (CaptureWidget)</li> <li>~FlameshotDBusAdapter (FlameshotDBusAdapter)</li> <li>~InfoWindow (InfoWindow)</li> <li>~OrgFreedesktopPortalRequestInterface (OrgFreedesktopPortalRequestInterface)</li> <li>~TextTool (TextTool)</li> <li>~TrayIcon (TrayIcon)</li> <li>~UploadHistory (UploadHistory)</li> <li>~UploadLineItem (UploadLineItem)</li> </ul>"},{"location":"flameshot/class_member_functions/#_","title":"_","text":"<ul> <li>_updateComponents (GeneralConf)</li> </ul>"},{"location":"flameshot/class_member_variables/","title":"Class Member Variables","text":""},{"location":"flameshot/class_member_variables/#a","title":"a","text":"<ul> <li>argument (CommandLineParser::Node)</li> <li>arg (TerminalApp)</li> </ul>"},{"location":"flameshot/class_member_variables/#b","title":"b","text":"<ul> <li>buttonBox (ImgUploadDialog)</li> </ul>"},{"location":"flameshot/class_member_variables/#c","title":"c","text":"<ul> <li>capture (AppLauncher, ImgUploaderTool)</li> <li>circleCount (CaptureContext)</li> <li>color (CaptureContext)</li> <li>categories (DesktopAppData)</li> </ul>"},{"location":"flameshot/class_member_variables/#d","title":"d","text":"<ul> <li>defaultLargeColorPalette (ColorPickerWidget)</li> <li>defaultSmallColorPalette (ColorPickerWidget)</li> <li>description (DesktopAppData)</li> <li>DESKTOP_SESSION (DesktopInfo)</li> </ul>"},{"location":"flameshot/class_member_variables/#e","title":"e","text":"<ul> <li>exec (DesktopAppData)</li> </ul>"},{"location":"flameshot/class_member_variables/#f","title":"f","text":"<ul> <li>fullscreen (CaptureContext)</li> <li>file (HistoryFileName)</li> </ul>"},{"location":"flameshot/class_member_variables/#g","title":"g","text":"<ul> <li>GDMSESSION (DesktopInfo)</li> <li>GNOME_DESKTOP_SESSION_ID (DesktopInfo)</li> </ul>"},{"location":"flameshot/class_member_variables/#i","title":"i","text":"<ul> <li>iterableButtonTypes (CaptureToolButton)</li> <li>icon (DesktopAppData)</li> </ul>"},{"location":"flameshot/class_member_variables/#k","title":"k","text":"<ul> <li>KDE_FULL_SESSION (DesktopInfo)</li> </ul>"},{"location":"flameshot/class_member_variables/#l","title":"l","text":"<ul> <li>layout (ImgUploadDialog)</li> </ul>"},{"location":"flameshot/class_member_variables/#m","title":"m","text":"<ul> <li>m_defaultChannel (AbstractLogger)</li> <li>m_enableMessageHeader (AbstractLogger)</li> <li>m_notificationPath (AbstractLogger)</li> <li>m_targets (AbstractLogger)</li> <li>m_textStreams (AbstractLogger)</li> <li>m_color (AbstractPathTool, AbstractTwoPointTool, ColorGrabWidget, ColorPickerEditor, LoadSpinner, MagnifierWidget, SelectionWidget, SidePanelWidget, TextTool)</li> <li>m_padding (AbstractPathTool, AbstractTwoPointTool)</li> <li>m_pathArea (AbstractPathTool)</li> <li>m_points (AbstractPathTool, AbstractTwoPointTool)</li> <li>m_pos (AbstractPathTool)</li> <li>m_thickness (AbstractPathTool, AbstractTwoPointTool)</li> <li>m_supportsDiagonalAdj (AbstractTwoPointTool)</li> <li>m_supportsOrthogonalAdj (AbstractTwoPointTool)</li> <li>m_appsMap (AppLauncherWidget)</li> <li>m_filterList (AppLauncherWidget)</li> <li>m_keepOpen (AppLauncherWidget)</li> <li>m_keepOpenCheckbox (AppLauncherWidget)</li> <li>m_layout (AppLauncherWidget, FileNameEditor, GeneralConf, NotificationWidget, PinWidget, SetShortcutDialog, ShortcutsWidget, SidePanelWidget, TextConfig, UpdateNotificationWidget, UtilityPanel, VisualsEditor)</li> <li>m_lineEdit (AppLauncherWidget)</li> <li>m_parser (AppLauncherWidget)</li> <li>m_pixmap (AppLauncherWidget, ColorGrabWidget, ImageLabel, ImgUploaderBase, PinTool, PinWidget, SidePanelWidget)</li> <li>m_tabWidget (AppLauncherWidget, ConfigWindow, VisualsEditor)</li> <li>m_tempFile (AppLauncherWidget)</li> <li>m_terminalCheckbox (AppLauncherWidget)</li> <li>m_arrowPath (ArrowTool)</li> <li>m_def (Bool, BoundedInt, Color, LowerBoundedInt, String)</li> <li>m_max (BoundedInt, UserColors)</li> <li>m_min (BoundedInt, LowerBoundedInt, UserColors)</li> <li>m_allSidesBlocked (ButtonHandler)</li> <li>m_blockedBotton (ButtonHandler)</li> <li>m_blockedLeft (ButtonHandler)</li> <li>m_blockedRight (ButtonHandler)</li> <li>m_blockedTop (ButtonHandler)</li> <li>m_buttonBaseSize (ButtonHandler)</li> <li>m_buttonExtendedSize (ButtonHandler)</li> <li>m_buttonsAreInside (ButtonHandler)</li> <li>m_horizontalyBlocked (ButtonHandler)</li> <li>m_oneHorizontalBlocked (ButtonHandler)</li> <li>m_screenRegions (ButtonHandler)</li> <li>m_selection (ButtonHandler, CaptureWidget)</li> <li>m_separator (ButtonHandler)</li> <li>m_vectorButtons (ButtonHandler)</li> <li>m_buttonTypeByName (ButtonListView)</li> <li>m_listButtons (ButtonListView)</li> <li>m_mainColor (CaptureButton, CaptureToolButton)</li> <li>mousePos (CaptureContext)</li> <li>m_data (CaptureRequest)</li> <li>m_delay (CaptureRequest)</li> <li>m_initialSelection (CaptureRequest)</li> <li>m_mode (CaptureRequest)</li> <li>m_path (CaptureRequest)</li> <li>m_pinWindowGeometry (CaptureRequest)</li> <li>m_tasks (CaptureRequest)</li> <li>m_buttonType (CaptureToolButton)</li> <li>m_emergeAnimation (CaptureToolButton)</li> <li>m_tool (CaptureToolButton)</li> <li>m_captureToolObjects (CaptureToolObjects, CaptureWidget, ModificationCommand)</li> <li>m_imageCache (CaptureToolObjects)</li> <li>m_activeButton (CaptureWidget)</li> <li>m_activeTool (CaptureWidget)</li> <li>m_activeToolIsMoved (CaptureWidget)</li> <li>m_activeToolOffsetToMouseOnStart (CaptureWidget)</li> <li>m_adjustmentButtonPressed (CaptureWidget)</li> <li>m_buttonHandler (CaptureWidget)</li> <li>m_captureDone (CaptureWidget)</li> <li>m_captureToolObjectsBackup (CaptureWidget, ModificationCommand)</li> <li>m_colorPicker (CaptureWidget)</li> <li>m_config (CaptureWidget, ColorPickerEditMode, ColorPickerEditor, ShortcutsWidget)</li> <li>m_configError (CaptureWidget)</li> <li>m_configErrorResolved (CaptureWidget)</li> <li>m_context (CaptureWidget)</li> <li>m_contrastUiColor (CaptureWidget)</li> <li>m_displayGrid (CaptureWidget)</li> <li>m_eventFilter (CaptureWidget)</li> <li>m_existingObjectIsChanged (CaptureWidget)</li> <li>m_gridSize (CaptureWidget)</li> <li>m_helpMessage (CaptureWidget, GeneralConf)</li> <li>m_lastMouseWheel (CaptureWidget)</li> <li>m_magnifier (CaptureWidget)</li> <li>m_mouseIsClicked (CaptureWidget)</li> <li>m_mouseOverHandle (CaptureWidget)</li> <li>m_mousePressedPos (CaptureWidget)</li> <li>m_movingSelection (CaptureWidget)</li> <li>m_newSelection (CaptureWidget)</li> <li>m_notifierBox (CaptureWidget)</li> <li>m_opacity (CaptureWidget, PinWidget)</li> <li>m_panel (CaptureWidget)</li> <li>m_previewEnabled (CaptureWidget)</li> <li>m_sidePanel (CaptureWidget)</li> <li>m_sizeIndButton (CaptureWidget)</li> <li>m_startMove (CaptureWidget)</li> <li>m_startMovePos (CaptureWidget)</li> <li>m_toolSizeByKeyboard (CaptureWidget)</li> <li>m_toolWidget (CaptureWidget, UtilityPanel)</li> <li>m_tools (CaptureWidget)</li> <li>m_uiColor (CaptureWidget, ColorPickerWidget, UIcolorEditor)</li> <li>m_undoStack (CaptureWidget)</li> <li>m_updateNotificationWidget (CaptureWidget)</li> <li>m_xywhDisplay (CaptureWidget)</li> <li>m_xywhTimer (CaptureWidget)</li> <li>m_tempString (CircleCountTool, TextTool)</li> <li>m_valid (CircleCountTool)</li> <li>m_extraZoomActive (ColorGrabWidget)</li> <li>m_magnifierActive (ColorGrabWidget)</li> <li>m_mousePressReceived (ColorGrabWidget)</li> <li>m_previewImage (ColorGrabWidget)</li> <li>m_draggedPresetInitialPos (ColorPickerEditMode)</li> <li>m_isDragging (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_isPressing (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_mouseMovePos (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_mousePressPos (ColorPickerEditMode, DraggableWidgetMaker)</li> <li>m_addPresetButton (ColorPickerEditor)</li> <li>m_addPresetLabel (ColorPickerEditor)</li> <li>m_colorEdit (ColorPickerEditor)</li> <li>m_colorEditLabel (ColorPickerEditor)</li> <li>m_colorInput (ColorPickerEditor)</li> <li>m_colorList (ColorPickerEditor, ColorPickerWidget)</li> <li>m_colorWheel (ColorPickerEditor, SidePanelWidget, UIcolorEditor)</li> <li>m_colorpicker (ColorPickerEditor)</li> <li>m_deletePresetButton (ColorPickerEditor)</li> <li>m_gLayout (ColorPickerEditor)</li> <li>m_selectedIndex (ColorPickerEditor, ColorPickerWidget)</li> <li>m_updatePresetButton (ColorPickerEditor)</li> <li>m_colorAreaList (ColorPickerWidget)</li> <li>m_colorAreaSize (ColorPickerWidget)</li> <li>m_lastIndex (ColorPickerWidget)</li> <li>m_description (CommandArgument, CommandLineParser, CommandOption)</li> <li>m_name (CommandArgument)</li> <li>m_foundArgs (CommandLineParser)</li> <li>m_foundOptions (CommandLineParser)</li> <li>m_generalErrorMessage (CommandLineParser)</li> <li>m_parseTree (CommandLineParser)</li> <li>m_withHelp (CommandLineParser)</li> <li>m_withVersion (CommandLineParser)</li> <li>m_checker (CommandOption)</li> <li>m_errorMsg (CommandOption)</li> <li>m_names (CommandOption)</li> <li>m_value (CommandOption)</li> <li>m_valueName (CommandOption)</li> <li>m_configWatcher (ConfigHandler)</li> <li>m_errorCheckPending (ConfigHandler)</li> <li>m_hasError (ConfigHandler)</li> <li>m_settings (ConfigHandler)</li> <li>m_skipNextErrorCheck (ConfigHandler)</li> <li>m_filenameEditor (ConfigWindow)</li> <li>m_filenameEditorTab (ConfigWindow)</li> <li>m_generalConfig (ConfigWindow)</li> <li>m_generalConfigTab (ConfigWindow)</li> <li>m_shortcuts (ConfigWindow, ShortcutsWidget)</li> <li>m_shortcutsTab (ConfigWindow)</li> <li>m_visuals (ConfigWindow)</li> <li>m_visualsTab (ConfigWindow)</li> <li>m_appList (DesktopFileParser, WinLnkFileParser)</li> <li>m_defaultIcon (DesktopFileParser)</li> <li>m_localeDescription (DesktopFileParser)</li> <li>m_localeDescriptionShort (DesktopFileParser)</li> <li>m_localeName (DesktopFileParser)</li> <li>m_localeNameShort (DesktopFileParser)</li> <li>m_timer (ExtendedSlider, LoadSpinner, NotificationWidget, NotifierBox)</li> <li>m_clearButton (FileNameEditor)</li> <li>m_helperButtons (FileNameEditor)</li> <li>m_nameEditor (FileNameEditor)</li> <li>m_nameHandler (FileNameEditor)</li> <li>m_outputLabel (FileNameEditor)</li> <li>m_resetButton (FileNameEditor, GeneralConf)</li> <li>m_saveButton (FileNameEditor)</li> <li>MAX_CHARACTERS (FileNameHandler)</li> <li>m_captureWindow (Flameshot)</li> <li>m_configWindow (Flameshot)</li> <li>m_haveExternalWidget (Flameshot)</li> <li>m_infoWindow (Flameshot)</li> <li>m_launcherWindow (Flameshot)</li> <li>m_origin (Flameshot)</li> <li>m_appLatestUrl (FlameshotDaemon, UpdateNotificationWidget)</li> <li>m_appLatestVersion (FlameshotDaemon, UpdateNotificationWidget)</li> <li>m_clipboardSignalBlocked (FlameshotDaemon)</li> <li>m_hostingClipboard (FlameshotDaemon)</li> <li>m_instance (FlameshotDaemon, OverlayMessage)</li> <li>m_networkCheckUpdates (FlameshotDaemon)</li> <li>m_persist (FlameshotDaemon)</li> <li>m_showCheckAppUpdateStatus (FlameshotDaemon)</li> <li>m_trayIcon (FlameshotDaemon)</li> <li>m_widgets (FlameshotDaemon)</li> <li>m_allowMultipleGuiInstances (GeneralConf)</li> <li>m_antialiasingPinZoom (GeneralConf)</li> <li>m_autoCloseIdleDaemon (GeneralConf)</li> <li>m_autostart (GeneralConf)</li> <li>m_changeSaveButton (GeneralConf)</li> <li>m_checkForUpdates (GeneralConf)</li> <li>m_copyOnDoubleClick (GeneralConf)</li> <li>m_copyPathAfterSave (GeneralConf)</li> <li>m_copyURLAfterUpload (GeneralConf)</li> <li>m_exportButton (GeneralConf)</li> <li>m_historyConfirmationToDelete (GeneralConf)</li> <li>m_importButton (GeneralConf)</li> <li>m_jpegQuality (GeneralConf)</li> <li>m_predefinedColorPaletteLarge (GeneralConf)</li> <li>m_saveAfterCopy (GeneralConf)</li> <li>m_saveLastRegion (GeneralConf)</li> <li>m_savePath (GeneralConf)</li> <li>m_screenshotPathFixedCheck (GeneralConf)</li> <li>m_scrollArea (GeneralConf)</li> <li>m_scrollAreaLayout (GeneralConf)</li> <li>m_selectGeometryLocation (GeneralConf)</li> <li>m_setSaveAsFileExtension (GeneralConf)</li> <li>m_showMagnifier (GeneralConf)</li> <li>m_showSelectionGeometry (GeneralConf)</li> <li>m_showStartupLaunchMessage (GeneralConf)</li> <li>m_showTray (GeneralConf)</li> <li>m_sidePanelButton (GeneralConf)</li> <li>m_squareMagnifier (GeneralConf)</li> <li>m_sysNotifications (GeneralConf)</li> <li>m_undoLimit (GeneralConf)</li> <li>m_uploadClientKey (GeneralConf)</li> <li>m_uploadHistoryMax (GeneralConf)</li> <li>m_uploadWithoutConfirmation (GeneralConf, ImgUploadDialog)</li> <li>m_useJpgForClipboard (GeneralConf)</li> <li>m_xywhTimeout (GeneralConf)</li> <li>m_historyPath (History)</li> <li>m_packedFileName (History)</li> <li>m_thumbs (History)</li> <li>m_unpackedFileName (History)</li> <li>m_DSEffect (ImageLabel)</li> <li>m_dragStartPosition (ImageLabel)</li> <li>m_uploadLabel (ImgUploadDialog)</li> <li>m_copyUrlButton (ImgUploaderBase)</li> <li>m_currentImageName (ImgUploaderBase)</li> <li>m_hLayout (ImgUploaderBase, UIcolorEditor)</li> <li>m_imageURL (ImgUploaderBase)</li> <li>m_infoLabel (ImgUploaderBase)</li> <li>m_notification (ImgUploaderBase, UpdateNotificationWidget)</li> <li>m_openDeleteUrlButton (ImgUploaderBase)</li> <li>m_openUrlButton (ImgUploaderBase)</li> <li>m_saveToFilesystemButton (ImgUploaderBase)</li> <li>m_spinner (ImgUploaderBase)</li> <li>m_toClipboardButton (ImgUploaderBase)</li> <li>m_vLayout (ImgUploaderBase, UIcolorEditor)</li> <li>m_imgUploaderBase (ImgUploaderManager)</li> <li>m_imgUploaderPlugin (ImgUploaderManager)</li> <li>m_urlString (ImgUploaderManager)</li> <li>m_NetworkAM (ImgurUploader)</li> <li>m_fallback (KeySequence)</li> <li>m_frame (LoadSpinner)</li> <li>m_growing (LoadSpinner)</li> <li>m_span (LoadSpinner)</li> <li>m_startAngle (LoadSpinner)</li> <li>m_borderColor (MagnifierWidget)</li> <li>m_devicePixelRatio (MagnifierWidget)</li> <li>m_magOffset (MagnifierWidget)</li> <li>m_magPixels (MagnifierWidget)</li> <li>m_paddedScreenshot (MagnifierWidget)</li> <li>m_pixels (MagnifierWidget)</li> <li>m_screenshot (MagnifierWidget)</li> <li>m_square (MagnifierWidget)</li> <li>magZoom (MagnifierWidget)</li> <li>m_captureWidget (ModificationCommand, UtilityPanel)</li> <li>m_content (NotificationWidget)</li> <li>m_hideAnimation (NotificationWidget, UpdateNotificationWidget, UtilityPanel)</li> <li>m_label (NotificationWidget, PinWidget)</li> <li>m_showAnimation (NotificationWidget, UpdateNotificationWidget, UtilityPanel)</li> <li>m_bgColor (NotifierBox)</li> <li>m_foregroundColor (NotifierBox)</li> <li>m_message (NotifierBox)</li> <li>m_orientation (OrientablePushButton)</li> <li>m_fillColor (OverlayMessage)</li> <li>m_messageStack (OverlayMessage)</li> <li>m_targetArea (OverlayMessage)</li> <li>m_textColor (OverlayMessage)</li> <li>m_geometry (PinTool)</li> <li>m_baseColor (PinWidget)</li> <li>m_currentStepScaleFactor (PinWidget)</li> <li>m_dragStart (PinWidget)</li> <li>m_expanding (PinWidget)</li> <li>m_hoverColor (PinWidget)</li> <li>m_offsetX (PinWidget)</li> <li>m_offsetY (PinWidget)</li> <li>m_rotateFactor (PinWidget)</li> <li>m_scaleFactor (PinWidget)</li> <li>m_shadowEffect (PinWidget)</li> <li>m_sizeChanged (PinWidget)</li> <li>m_currentScreen (QGuiAppCurrentScreen)</li> <li>m_info (ScreenGrabber)</li> <li>m_BArea (SelectionWidget)</li> <li>m_BHandle (SelectionWidget)</li> <li>m_BLArea (SelectionWidget)</li> <li>m_BLHandle (SelectionWidget)</li> <li>m_BRArea (SelectionWidget)</li> <li>m_BRHandle (SelectionWidget)</li> <li>m_LArea (SelectionWidget)</li> <li>m_LHandle (SelectionWidget)</li> <li>m_RArea (SelectionWidget)</li> <li>m_RHandle (SelectionWidget)</li> <li>m_TArea (SelectionWidget)</li> <li>m_THandle (SelectionWidget)</li> <li>m_TLArea (SelectionWidget)</li> <li>m_TLHandle (SelectionWidget)</li> <li>m_TRArea (SelectionWidget)</li> <li>m_TRHandle (SelectionWidget)</li> <li>m_activeSide (SelectionWidget)</li> <li>m_animation (SelectionWidget)</li> <li>m_areaOffset (SelectionWidget)</li> <li>m_dragStartPos (SelectionWidget)</li> <li>m_handleOffset (SelectionWidget)</li> <li>m_idleCentralCursor (SelectionWidget)</li> <li>m_ignoreMouse (SelectionWidget)</li> <li>m_mouseStartMove (SelectionWidget)</li> <li>m_ks (SetShortcutDialog)</li> <li>m_modifier (SetShortcutDialog)</li> <li>m_table (ShortcutsWidget)</li> <li>m_colorGrabButton (SidePanelWidget)</li> <li>m_colorGrabber (SidePanelWidget)</li> <li>m_colorHex (SidePanelWidget)</li> <li>m_colorLabel (SidePanelWidget)</li> <li>m_gridCheck (SidePanelWidget)</li> <li>m_gridSizeSpin (SidePanelWidget)</li> <li>m_revertColor (SidePanelWidget)</li> <li>m_toolSize (SidePanelWidget)</li> <li>m_toolSizeSlider (SidePanelWidget)</li> <li>m_toolSizeSpin (SidePanelWidget)</li> <li>m_buttonData (StrftimeChooserWidget)</li> <li>m_interface (SystemNotification)</li> <li>m_centerAlignButton (TextConfig)</li> <li>m_fontsCB (TextConfig)</li> <li>m_italicButton (TextConfig)</li> <li>m_leftAlignButton (TextConfig)</li> <li>m_rightAlignButton (TextConfig)</li> <li>m_strikeOutButton (TextConfig)</li> <li>m_underlineButton (TextConfig)</li> <li>m_weightButton (TextConfig)</li> <li>m_alignment (TextTool)</li> <li>m_confW (TextTool)</li> <li>m_currentPos (TextTool)</li> <li>m_font (TextTool)</li> <li>m_size (TextTool)</li> <li>m_text (TextTool)</li> <li>m_textArea (TextTool)</li> <li>m_textOld (TextTool)</li> <li>m_widget (TextTool)</li> <li>m_baseSize (TextWidget)</li> <li>m_minSize (TextWidget)</li> <li>m_appUpdates (TrayIcon)</li> <li>m_menu (TrayIcon)</li> <li>m_buttonContrast (UIcolorEditor)</li> <li>m_buttonIconType (UIcolorEditor)</li> <li>m_buttonMainColor (UIcolorEditor)</li> <li>m_contrastColor (UIcolorEditor)</li> <li>m_labelContrast (UIcolorEditor)</li> <li>m_labelMain (UIcolorEditor)</li> <li>m_lastButtonPressed (UIcolorEditor)</li> <li>m_internalPanel (UpdateNotificationWidget, UtilityPanel)</li> <li>m_bottomLayout (UtilityPanel)</li> <li>m_buttonDelete (UtilityPanel)</li> <li>m_buttonMoveDown (UtilityPanel)</li> <li>m_buttonMoveUp (UtilityPanel)</li> <li>m_captureTools (UtilityPanel)</li> <li>m_layersLayout (UtilityPanel)</li> <li>m_upLayout (UtilityPanel)</li> <li>m_buttonList (VisualsEditor)</li> <li>m_colorEditor (VisualsEditor)</li> <li>m_colorEditorTab (VisualsEditor)</li> <li>m_colorpickerEditor (VisualsEditor)</li> <li>m_colorpickerEditorTab (VisualsEditor)</li> <li>m_opacitySlider (VisualsEditor)</li> <li>m_GraphicAppsList (WinLnkFileParser)</li> </ul>"},{"location":"flameshot/class_member_variables/#n","title":"n","text":"<ul> <li>name (DesktopAppData, TerminalApp)</li> </ul>"},{"location":"flameshot/class_member_variables/#o","title":"o","text":"<ul> <li>origScreenshot (CaptureContext)</li> <li>options (CommandLineParser::Node)</li> </ul>"},{"location":"flameshot/class_member_variables/#r","title":"r","text":"<ul> <li>request (CaptureContext)</li> </ul>"},{"location":"flameshot/class_member_variables/#s","title":"s","text":"<ul> <li>savePath (CaptureContext)</li> <li>screenshot (CaptureContext)</li> <li>selection (CaptureContext)</li> <li>subNodes (CommandLineParser::Node)</li> <li>setShowDesktopNotification (ConfigHandler)</li> <li>setShowStartupLaunchMessage (ConfigHandler)</li> <li>setUploadWithoutConfirmation (ConfigHandler)</li> <li>showSelectionGeometryHideTime (ConfigHandler)</li> <li>showInTerminal (DesktopAppData)</li> </ul>"},{"location":"flameshot/class_member_variables/#t","title":"t","text":"<ul> <li>toolSize (CaptureContext)</li> <li>token (HistoryFileName)</li> <li>type (HistoryFileName)</li> </ul>"},{"location":"flameshot/class_member_variables/#u","title":"u","text":"<ul> <li>ui (CaptureLauncher, InfoWindow, UploadHistory, UploadLineItem)</li> </ul>"},{"location":"flameshot/class_member_variables/#w","title":"w","text":"<ul> <li>widgetOffset (CaptureContext)</li> <li>WAYLAND_DISPLAY (DesktopInfo)</li> </ul>"},{"location":"flameshot/class_member_variables/#x","title":"x","text":"<ul> <li>XDG_CURRENT_DESKTOP (DesktopInfo)</li> <li>XDG_SESSION_TYPE (DesktopInfo)</li> </ul>"},{"location":"flameshot/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"flameshot/class_member_enums/","title":"Class Member Enums","text":""},{"location":"flameshot/class_member_enums/#c","title":"c","text":"<ul> <li>Channel (AbstractLogger)</li> <li>CaptureMode (CaptureRequest)</li> </ul>"},{"location":"flameshot/class_member_enums/#e","title":"e","text":"<ul> <li>ExportTask (CaptureRequest)</li> </ul>"},{"location":"flameshot/class_member_enums/#o","title":"o","text":"<ul> <li>Origin (Flameshot)</li> <li>Orientation (OrientablePushButton)</li> </ul>"},{"location":"flameshot/class_member_enums/#s","title":"s","text":"<ul> <li>SideType (SelectionWidget)</li> </ul>"},{"location":"flameshot/class_member_enums/#t","title":"t","text":"<ul> <li>Target (AbstractLogger)</li> </ul>"},{"location":"flameshot/class_member_enums/#w","title":"w","text":"<ul> <li>WM (DesktopInfo)</li> </ul>"},{"location":"flameshot/class_member_enums/#x","title":"x","text":"<ul> <li>xywh_position (GeneralConf)</li> </ul>"},{"location":"flameshot/namespace_members/","title":"Namespace Members","text":""},{"location":"flameshot/namespace_members/#b","title":"b","text":"<ul> <li>buttonBaseSize (GlobalValues)</li> <li>blackIconPath (PathInfo)</li> </ul>"},{"location":"flameshot/namespace_members/#c","title":"c","text":"<ul> <li>colorIsDark (ColorUtils)</li> <li>contrastColor (ColorUtils)</li> <li>create_specifier_list (strfparse)</li> </ul>"},{"location":"flameshot/namespace_members/#d","title":"d","text":"<ul> <li>DIAG_UNIT (@57)</li> </ul>"},{"location":"flameshot/namespace_members/#f","title":"f","text":"<ul> <li>format_time_string (strfparse)</li> </ul>"},{"location":"flameshot/namespace_members/#i","title":"i","text":"<ul> <li>iconPath (GlobalValues)</li> <li>iconPathPNG (GlobalValues)</li> </ul>"},{"location":"flameshot/namespace_members/#m","title":"m","text":"<ul> <li>match_specifiers (strfparse)</li> </ul>"},{"location":"flameshot/namespace_members/#r","title":"r","text":"<ul> <li>Request (org::freedesktop::portal)</li> <li>replace_all (strfparse)</li> </ul>"},{"location":"flameshot/namespace_members/#s","title":"s","text":"<ul> <li>split (strfparse)</li> </ul>"},{"location":"flameshot/namespace_members/#t","title":"t","text":"<ul> <li>translationsPaths (PathInfo)</li> </ul>"},{"location":"flameshot/namespace_members/#u","title":"u","text":"<ul> <li>UNIT (@57)</li> </ul>"},{"location":"flameshot/namespace_members/#v","title":"v","text":"<ul> <li>versionInfo (GlobalValues)</li> </ul>"},{"location":"flameshot/namespace_members/#w","title":"w","text":"<ul> <li>whiteIconPath (PathInfo)</li> </ul>"},{"location":"flameshot/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"flameshot/namespace_member_functions/#b","title":"b","text":"<ul> <li>buttonBaseSize (GlobalValues)</li> <li>blackIconPath (PathInfo)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#c","title":"c","text":"<ul> <li>colorIsDark (ColorUtils)</li> <li>contrastColor (ColorUtils)</li> <li>create_specifier_list (strfparse)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#f","title":"f","text":"<ul> <li>format_time_string (strfparse)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#i","title":"i","text":"<ul> <li>iconPath (GlobalValues)</li> <li>iconPathPNG (GlobalValues)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#m","title":"m","text":"<ul> <li>match_specifiers (strfparse)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#r","title":"r","text":"<ul> <li>replace_all (strfparse)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#s","title":"s","text":"<ul> <li>split (strfparse)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#t","title":"t","text":"<ul> <li>translationsPaths (PathInfo)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#v","title":"v","text":"<ul> <li>versionInfo (GlobalValues)</li> </ul>"},{"location":"flameshot/namespace_member_functions/#w","title":"w","text":"<ul> <li>whiteIconPath (PathInfo)</li> </ul>"},{"location":"flameshot/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"flameshot/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"flameshot/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>Request (org::freedesktop::portal)</li> </ul>"},{"location":"flameshot/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"flameshot/namespace_member_enums/#d","title":"d","text":"<ul> <li>DIAG_UNIT (@57)</li> </ul>"},{"location":"flameshot/namespace_member_enums/#u","title":"u","text":"<ul> <li>UNIT (@57)</li> </ul>"},{"location":"flameshot/functions/","title":"Functions","text":""},{"location":"flameshot/functions/#c","title":"c","text":"<ul> <li>configureApp (main.cpp)</li> <li>clearHistoryLayout (uploadhistory.cpp, uploadhistory.h)</li> </ul>"},{"location":"flameshot/functions/#g","title":"g","text":"<ul> <li>getCachePath (cacheutils.cpp, cacheutils.h)</li> <li>getLastRegion (cacheutils.cpp, cacheutils.h)</li> <li>guiMutexLock (main.cpp)</li> <li>getColorLuma (colorutils.cpp)</li> <li>getProperSide (selectionwidget.cpp)</li> <li>generateKernelString (infowindow.cpp, infowindow.h)</li> </ul>"},{"location":"flameshot/functions/#m","title":"m","text":"<ul> <li>main (main.cpp)</li> </ul>"},{"location":"flameshot/functions/#o","title":"o","text":"<ul> <li>operator&amp; (capturerequest.h)</li> <li>operator| (capturerequest.h)</li> <li>operator|= (capturerequest.h)</li> </ul>"},{"location":"flameshot/functions/#r","title":"r","text":"<ul> <li>reinitializeAsQApplication (main.cpp)</li> <li>requestCaptureAndWait (main.cpp)</li> <li>removeCacheFile (uploadlineitem.cpp, uploadlineitem.h)</li> </ul>"},{"location":"flameshot/functions/#s","title":"s","text":"<ul> <li>setLastRegion (cacheutils.cpp, cacheutils.h)</li> <li>showOpenWithMenu (openwithprogram.cpp, openwithprogram.h)</li> <li>ShowSaveFileDialog (screenshotsaver.cpp, screenshotsaver.h)</li> <li>saveToClipboard (screenshotsaver.cpp, screenshotsaver.h)</li> <li>saveToClipboardMime (screenshotsaver.cpp, screenshotsaver.h)</li> <li>saveToFilesystem (screenshotsaver.cpp, screenshotsaver.h)</li> <li>saveToFilesystemGUI (screenshotsaver.cpp, screenshotsaver.h)</li> <li>sortButtons (valuehandler.cpp)</li> <li>scaleThumbnail (uploadhistory.cpp, uploadhistory.h)</li> </ul>"},{"location":"flameshot/functions/#v","title":"v","text":"<ul> <li>verifyLaunchFile (confighandler.cpp)</li> </ul>"},{"location":"flameshot/macros/","title":"Macros","text":""},{"location":"flameshot/macros/#b","title":"b","text":"<ul> <li>BASE_POINT_SIZE (texttool.cpp)</li> </ul>"},{"location":"flameshot/macros/#c","title":"c","text":"<ul> <li>CONFIG_GETTER (confighandler.h)</li> <li>CONFIG_GETTER_SETTER (confighandler.h)</li> <li>CONFIG_GROUP_GENERAL (confighandler.h)</li> <li>CONFIG_GROUP_SHORTCUTS (confighandler.h)</li> <li>CONFIG_SETTER (confighandler.h)</li> </ul>"},{"location":"flameshot/macros/#f","title":"f","text":"<ul> <li>FLAMESHOT_ICON (systemnotification.cpp)</li> </ul>"},{"location":"flameshot/macros/#h","title":"h","text":"<ul> <li>HISTORYPIXMAP_MAX_PREVIEW_HEIGHT (history.h)</li> <li>HISTORYPIXMAP_MAX_PREVIEW_WIDTH (history.h)</li> </ul>"},{"location":"flameshot/macros/#i","title":"i","text":"<ul> <li>IMG_UPLOADER_STORAGE_DEFAULT (imguploadermanager.h)</li> <li>if_TYPE_return_TOOL (toolfactory.cpp)</li> </ul>"},{"location":"flameshot/macros/#m","title":"m","text":"<ul> <li>MAX_INFO_LENGTH (texttool.cpp)</li> <li>MOUSE_DISTANCE_TO_START_MOVING (capturewidget.cpp)</li> <li>MARGIN (selectionwidget.cpp)</li> </ul>"},{"location":"flameshot/macros/#o","title":"o","text":"<ul> <li>OPTION (confighandler.cpp)</li> <li>OFFSET (loadspinner.cpp)</li> </ul>"},{"location":"flameshot/macros/#p","title":"p","text":"<ul> <li>PADDING_VALUE (circlecounttool.cpp, markertool.cpp)</li> </ul>"},{"location":"flameshot/macros/#s","title":"s","text":"<ul> <li>SHORTCUT (confighandler.cpp)</li> <li>SEARCH_RADIUS_FAR (capturetoolobjects.cpp)</li> <li>SEARCH_RADIUS_NEAR (capturetoolobjects.cpp)</li> <li>SEARCH_RADIUS_TEXT_HANDICAP (capturetoolobjects.cpp)</li> </ul>"},{"location":"flameshot/macros/#t","title":"t","text":"<ul> <li>THICKNESS_OFFSET (circlecounttool.cpp)</li> </ul>"},{"location":"flameshot/macros/#w","title":"w","text":"<ul> <li>WIDTH1 (colorgrabwidget.cpp)</li> <li>WIDTH2 (colorgrabwidget.cpp)</li> </ul>"},{"location":"flameshot/macros/#z","title":"z","text":"<ul> <li>ZOOM1 (colorgrabwidget.cpp)</li> <li>ZOOM2 (colorgrabwidget.cpp)</li> </ul>"},{"location":"flameshot/variables/","title":"Variables","text":""},{"location":"flameshot/variables/#b","title":"b","text":"<ul> <li>BList (valuehandler.cpp)</li> <li>BType (valuehandler.cpp)</li> <li>buttonTypeOrder (capturetoolbutton.cpp)</li> </ul>"},{"location":"flameshot/variables/#e","title":"e","text":"<ul> <li>eTask (capturerequest.h)</li> </ul>"},{"location":"flameshot/variables/#m","title":"m","text":"<ul> <li>maxToolSize (sidepanelwidget.h)</li> <li>minSliderWidth (sidepanelwidget.h)</li> </ul>"},{"location":"flameshot/variables/#q","title":"q","text":"<ul> <li>qtTranslator (main.cpp)</li> </ul>"},{"location":"flameshot/variables/#r","title":"r","text":"<ul> <li>recognizedGeneralOptions (confighandler.cpp)</li> <li>recognizedShortcuts (confighandler.cpp)</li> </ul>"},{"location":"flameshot/variables/#t","title":"t","text":"<ul> <li>translator (main.cpp)</li> </ul>"},{"location":"flameshot/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List<ul> <li>namespace @103</li> <li>namespace @2</li> <li>namespace @57</li> <li>namespace @61</li> <li>namespace @67</li> <li>namespace @85</li> <li>namespace @91</li> <li>class AbstractActionTool</li> <li>class AbstractLogger</li> <li>class AbstractPathTool</li> <li>class AbstractTwoPointTool</li> <li>class AcceptTool</li> <li>class AppLauncher</li> <li>class AppLauncherWidget</li> <li>class ArrowTool</li> <li>class Bool</li> <li>class BoundedInt</li> <li>class ButtonHandler</li> <li>class ButtonList</li> <li>class ButtonListView</li> <li>class CaptureButton</li> <li>struct CaptureContext</li> <li>class CaptureLauncher</li> <li>class CaptureRequest</li> <li>class CaptureToolButton</li> <li>class CaptureToolObjects</li> <li>class CaptureWidget</li> <li>class CircleCountTool</li> <li>class CircleTool</li> <li>class ClickableLabel</li> <li>class Color</li> <li>class ColorGrabWidget</li> <li>class ColorPicker</li> <li>class ColorPickerEditMode</li> <li>class ColorPickerEditor</li> <li>class ColorPickerWidget</li> <li>namespace ColorUtils</li> <li>class CommandArgument</li> <li>class CommandLineParser</li> <li>struct CommandLineParser::Node</li> <li>class CommandOption</li> <li>struct CompareAppByName</li> <li>class ConfigErrorDetails</li> <li>class ConfigHandler</li> <li>class ConfigResolver</li> <li>class ConfigWindow</li> <li>class CopyTool</li> <li>struct DesktopAppData</li> <li>struct DesktopFileParser</li> <li>class DesktopInfo</li> <li>class DraggableWidgetMaker</li> <li>class ExistingDir</li> <li>class ExitTool</li> <li>class ExtendedSlider</li> <li>class FileNameEditor</li> <li>class FileNameHandler</li> <li>class FilenamePattern</li> <li>class Flameshot</li> <li>class FlameshotDBusAdapter</li> <li>class FlameshotDaemon</li> <li>class GeneralConf</li> <li>class GlobalShortcutFilter</li> <li>namespace GlobalValues</li> <li>class History</li> <li>struct HistoryFileName</li> <li>class HoverEventFilter</li> <li>class ImageLabel</li> <li>class ImgUploadDialog</li> <li>class ImgUploaderBase</li> <li>class ImgUploaderManager</li> <li>class ImgUploaderTool</li> <li>class ImgurUploader</li> <li>class InfoWindow</li> <li>class InvertTool</li> <li>class KeySequence</li> <li>class LauncherItemDelegate</li> <li>class LineTool</li> <li>class LoadSpinner</li> <li>class LowerBoundedInt</li> <li>class MagnifierWidget</li> <li>class MarkerTool</li> <li>class ModificationCommand</li> <li>class MoveTool</li> <li>class NotificationWidget</li> <li>class NotifierBox</li> <li>class OrgFreedesktopPortalRequestInterface</li> <li>class OrientablePushButton</li> <li>class OverlayMessage</li> <li>namespace PathInfo</li> <li>class PencilTool</li> <li>class PinTool</li> <li>class PinWidget</li> <li>class PixelateTool</li> <li>class QGuiAppCurrentScreen</li> <li>class QSharedPointer</li> <li>class RectangleTool</li> <li>class RedoTool</li> <li>class Region</li> <li>class SaveFileExtension</li> <li>class SaveTool</li> <li>class ScreenGrabber</li> <li>class SelectionTool</li> <li>class SelectionWidget</li> <li>class SetShortcutDialog</li> <li>class ShortcutsWidget</li> <li>class SidePanelWidget</li> <li>class SizeDecreaseTool</li> <li>class SizeIncreaseTool</li> <li>class StrftimeChooserWidget</li> <li>class String</li> <li>class StyleOverride</li> <li>class SystemNotification</li> <li>struct TerminalApp</li> <li>class TerminalLauncher</li> <li>class TextConfig</li> <li>class TextTool</li> <li>class TextWidget</li> <li>class ToolFactory</li> <li>class TrayIcon</li> <li>class UIcolorEditor</li> <li>namespace Ui</li> <li>class UndoTool</li> <li>class UpdateNotificationWidget</li> <li>class UploadHistory</li> <li>class UploadLineItem</li> <li>class UserColors</li> <li>class UtilityPanel</li> <li>class ValueHandler</li> <li>class VisualsEditor</li> <li>class WaylandUtils</li> <li>struct WinLnkFileParser</li> <li>namespace org</li> <li>namespace org::freedesktop<ul> <li>namespace org::freedesktop::portal</li> </ul> </li> <li>namespace strfparse</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>src</li> <li>cli<ul> <li>commandargument.cpp</li> <li>commandargument.cpp source</li> <li>commandargument.h</li> <li>commandargument.h source</li> <li>commandlineparser.cpp</li> <li>commandlineparser.cpp source</li> <li>commandlineparser.h</li> <li>commandlineparser.h source</li> <li>commandoption.cpp</li> <li>commandoption.cpp source</li> <li>commandoption.h</li> <li>commandoption.h source</li> </ul> </li> <li>config<ul> <li>buttonlistview.cpp</li> <li>buttonlistview.cpp source</li> <li>buttonlistview.h</li> <li>buttonlistview.h source</li> <li>cacheutils.cpp</li> <li>cacheutils.cpp source</li> <li>cacheutils.h</li> <li>cacheutils.h source</li> <li>clickablelabel.cpp</li> <li>clickablelabel.cpp source</li> <li>clickablelabel.h</li> <li>clickablelabel.h source</li> <li>colorpickereditmode.cpp</li> <li>colorpickereditmode.cpp source</li> <li>colorpickereditmode.h</li> <li>colorpickereditmode.h source</li> <li>colorpickereditor.cpp</li> <li>colorpickereditor.cpp source</li> <li>colorpickereditor.h</li> <li>colorpickereditor.h source</li> <li>configerrordetails.cpp</li> <li>configerrordetails.cpp source</li> <li>configerrordetails.h</li> <li>configerrordetails.h source</li> <li>configresolver.cpp</li> <li>configresolver.cpp source</li> <li>configresolver.h</li> <li>configresolver.h source</li> <li>configwindow.cpp</li> <li>configwindow.cpp source</li> <li>configwindow.h</li> <li>configwindow.h source</li> <li>extendedslider.cpp</li> <li>extendedslider.cpp source</li> <li>extendedslider.h</li> <li>extendedslider.h source</li> <li>filenameeditor.cpp</li> <li>filenameeditor.cpp source</li> <li>filenameeditor.h</li> <li>filenameeditor.h source</li> <li>generalconf.cpp</li> <li>generalconf.cpp source</li> <li>generalconf.h</li> <li>generalconf.h source</li> <li>setshortcutwidget.cpp</li> <li>setshortcutwidget.cpp source</li> <li>setshortcutwidget.h</li> <li>setshortcutwidget.h source</li> <li>shortcutswidget.cpp</li> <li>shortcutswidget.cpp source</li> <li>shortcutswidget.h</li> <li>shortcutswidget.h source</li> <li>strftimechooserwidget.cpp</li> <li>strftimechooserwidget.cpp source</li> <li>strftimechooserwidget.h</li> <li>strftimechooserwidget.h source</li> <li>styleoverride.cpp</li> <li>styleoverride.cpp source</li> <li>styleoverride.h</li> <li>styleoverride.h source</li> <li>uicoloreditor.cpp</li> <li>uicoloreditor.cpp source</li> <li>uicoloreditor.h</li> <li>uicoloreditor.h source</li> <li>visualseditor.cpp</li> <li>visualseditor.cpp source</li> <li>visualseditor.h</li> <li>visualseditor.h source</li> </ul> </li> <li>core<ul> <li>capturerequest.cpp</li> <li>capturerequest.cpp source</li> <li>capturerequest.h</li> <li>capturerequest.h source</li> <li>flameshot.cpp</li> <li>flameshot.cpp source</li> <li>flameshot.h</li> <li>flameshot.h source</li> <li>flameshotdaemon.cpp</li> <li>flameshotdaemon.cpp source</li> <li>flameshotdaemon.h</li> <li>flameshotdaemon.h source</li> <li>flameshotdbusadapter.cpp</li> <li>flameshotdbusadapter.cpp source</li> <li>flameshotdbusadapter.h</li> <li>flameshotdbusadapter.h source</li> <li>globalshortcutfilter.cpp</li> <li>globalshortcutfilter.cpp source</li> <li>globalshortcutfilter.h</li> <li>globalshortcutfilter.h source</li> <li>qguiappcurrentscreen.cpp</li> <li>qguiappcurrentscreen.cpp source</li> <li>qguiappcurrentscreen.h</li> <li>qguiappcurrentscreen.h source</li> </ul> </li> <li>main.cpp</li> <li>main.cpp source</li> <li>tools<ul> <li>abstractactiontool.cpp</li> <li>abstractactiontool.cpp source</li> <li>abstractactiontool.h</li> <li>abstractactiontool.h source</li> <li>abstractpathtool.cpp</li> <li>abstractpathtool.cpp source</li> <li>abstractpathtool.h</li> <li>abstractpathtool.h source</li> <li>abstracttwopointtool.cpp</li> <li>abstracttwopointtool.cpp source</li> <li>abstracttwopointtool.h</li> <li>abstracttwopointtool.h source</li> <li>accept</li> <li>accepttool.cpp</li> <li>accepttool.cpp source</li> <li>accepttool.h</li> <li>accepttool.h source</li> <li>arrow</li> <li>arrowtool.cpp</li> <li>arrowtool.cpp source</li> <li>arrowtool.h</li> <li>arrowtool.h source</li> <li>capturecontext.cpp</li> <li>capturecontext.cpp source</li> <li>capturecontext.h</li> <li>capturecontext.h source</li> <li>circle</li> <li>circletool.cpp</li> <li>circletool.cpp source</li> <li>circletool.h</li> <li>circletool.h source</li> <li>circlecount</li> <li>circlecounttool.cpp</li> <li>circlecounttool.cpp source</li> <li>circlecounttool.h</li> <li>circlecounttool.h source</li> <li>copy</li> <li>copytool.cpp</li> <li>copytool.cpp source</li> <li>copytool.h</li> <li>copytool.h source</li> <li>exit</li> <li>exittool.cpp</li> <li>exittool.cpp source</li> <li>exittool.h</li> <li>exittool.h source</li> <li>imgupload</li> <li>imguploadermanager.cpp</li> <li>imguploadermanager.cpp source</li> <li>imguploadermanager.h</li> <li>imguploadermanager.h source</li> <li>imguploadertool.cpp</li> <li>imguploadertool.cpp source</li> <li>imguploadertool.h</li> <li>imguploadertool.h source</li> <li>storages<ul> <li>imguploaderbase.cpp</li> <li>imguploaderbase.cpp source</li> <li>imguploaderbase.h</li> <li>imguploaderbase.h source</li> <li>imgur</li> <li>imguruploader.cpp</li> <li>imguruploader.cpp source</li> <li>imguruploader.h</li> <li>imguruploader.h source</li> </ul> </li> <li>invert</li> <li>inverttool.cpp</li> <li>inverttool.cpp source</li> <li>inverttool.h</li> <li>inverttool.h source</li> <li>launcher</li> <li>applaunchertool.cpp</li> <li>applaunchertool.cpp source</li> <li>applaunchertool.h</li> <li>applaunchertool.h source</li> <li>applauncherwidget.cpp</li> <li>applauncherwidget.cpp source</li> <li>applauncherwidget.h</li> <li>applauncherwidget.h source</li> <li>launcheritemdelegate.cpp</li> <li>launcheritemdelegate.cpp source</li> <li>launcheritemdelegate.h</li> <li>launcheritemdelegate.h source</li> <li>openwithprogram.cpp</li> <li>openwithprogram.cpp source</li> <li>openwithprogram.h</li> <li>openwithprogram.h source</li> <li>terminallauncher.cpp</li> <li>terminallauncher.cpp source</li> <li>terminallauncher.h</li> <li>terminallauncher.h source</li> <li>line</li> <li>linetool.cpp</li> <li>linetool.cpp source</li> <li>linetool.h</li> <li>linetool.h source</li> <li>marker</li> <li>markertool.cpp</li> <li>markertool.cpp source</li> <li>markertool.h</li> <li>markertool.h source</li> <li>move</li> <li>movetool.cpp</li> <li>movetool.cpp source</li> <li>movetool.h</li> <li>movetool.h source</li> <li>pencil</li> <li>penciltool.cpp</li> <li>penciltool.cpp source</li> <li>penciltool.h</li> <li>penciltool.h source</li> <li>pin</li> <li>pintool.cpp</li> <li>pintool.cpp source</li> <li>pintool.h</li> <li>pintool.h source</li> <li>pinwidget.cpp</li> <li>pinwidget.cpp source</li> <li>pinwidget.h</li> <li>pinwidget.h source</li> <li>pixelate</li> <li>pixelatetool.cpp</li> <li>pixelatetool.cpp source</li> <li>pixelatetool.h</li> <li>pixelatetool.h source</li> <li>rectangle</li> <li>rectangletool.cpp</li> <li>rectangletool.cpp source</li> <li>rectangletool.h</li> <li>rectangletool.h source</li> <li>redo</li> <li>redotool.cpp</li> <li>redotool.cpp source</li> <li>redotool.h</li> <li>redotool.h source</li> <li>save</li> <li>savetool.cpp</li> <li>savetool.cpp source</li> <li>savetool.h</li> <li>savetool.h source</li> <li>selection</li> <li>selectiontool.cpp</li> <li>selectiontool.cpp source</li> <li>selectiontool.h</li> <li>selectiontool.h source</li> <li>sizedecrease</li> <li>sizedecreasetool.cpp</li> <li>sizedecreasetool.cpp source</li> <li>sizedecreasetool.h</li> <li>sizedecreasetool.h source</li> <li>sizeincrease</li> <li>sizeincreasetool.cpp</li> <li>sizeincreasetool.cpp source</li> <li>sizeincreasetool.h</li> <li>sizeincreasetool.h source</li> <li>text</li> <li>textconfig.cpp</li> <li>textconfig.cpp source</li> <li>textconfig.h</li> <li>textconfig.h source</li> <li>texttool.cpp</li> <li>texttool.cpp source</li> <li>texttool.h</li> <li>texttool.h source</li> <li>textwidget.cpp</li> <li>textwidget.cpp source</li> <li>textwidget.h</li> <li>textwidget.h source</li> <li>toolfactory.cpp</li> <li>toolfactory.cpp source</li> <li>toolfactory.h</li> <li>toolfactory.h source</li> <li>undo</li> <li>undotool.cpp</li> <li>undotool.cpp source</li> <li>undotool.h</li> <li>undotool.h source</li> </ul> </li> <li>utils<ul> <li>abstractlogger.cpp</li> <li>abstractlogger.cpp source</li> <li>abstractlogger.h</li> <li>abstractlogger.h source</li> <li>colorutils.cpp</li> <li>colorutils.cpp source</li> <li>colorutils.h</li> <li>colorutils.h source</li> <li>confighandler.cpp</li> <li>confighandler.cpp source</li> <li>confighandler.h</li> <li>confighandler.h source</li> <li>desktopfileparse.cpp</li> <li>desktopfileparse.cpp source</li> <li>desktopfileparse.h</li> <li>desktopfileparse.h source</li> <li>desktopinfo.cpp</li> <li>desktopinfo.cpp source</li> <li>desktopinfo.h</li> <li>desktopinfo.h source</li> <li>filenamehandler.cpp</li> <li>filenamehandler.cpp source</li> <li>filenamehandler.h</li> <li>filenamehandler.h source</li> <li>globalvalues.cpp</li> <li>globalvalues.cpp source</li> <li>globalvalues.h</li> <li>globalvalues.h source</li> <li>history.cpp</li> <li>history.cpp source</li> <li>history.h</li> <li>history.h source</li> <li>pathinfo.cpp</li> <li>pathinfo.cpp source</li> <li>pathinfo.h</li> <li>pathinfo.h source</li> <li>request.cpp</li> <li>request.cpp source</li> <li>request.h</li> <li>request.h source</li> <li>screengrabber.cpp</li> <li>screengrabber.cpp source</li> <li>screengrabber.h</li> <li>screengrabber.h source</li> <li>screenshotsaver.cpp</li> <li>screenshotsaver.cpp source</li> <li>screenshotsaver.h</li> <li>screenshotsaver.h source</li> <li>strfparse.cpp</li> <li>strfparse.cpp source</li> <li>strfparse.h</li> <li>strfparse.h source</li> <li>systemnotification.cpp</li> <li>systemnotification.cpp source</li> <li>systemnotification.h</li> <li>systemnotification.h source</li> <li>valuehandler.cpp</li> <li>valuehandler.cpp source</li> <li>valuehandler.h</li> <li>valuehandler.h source</li> <li>waylandutils.cpp</li> <li>waylandutils.cpp source</li> <li>waylandutils.h</li> <li>waylandutils.h source</li> <li>winlnkfileparse.cpp</li> <li>winlnkfileparse.cpp source</li> <li>winlnkfileparse.h</li> <li>winlnkfileparse.h source</li> </ul> </li> <li>widgets<ul> <li>capture</li> <li>buttonhandler.cpp</li> <li>buttonhandler.cpp source</li> <li>buttonhandler.h</li> <li>buttonhandler.h source</li> <li>capturebutton.cpp</li> <li>capturebutton.cpp source</li> <li>capturebutton.h</li> <li>capturebutton.h source</li> <li>capturetoolbutton.cpp</li> <li>capturetoolbutton.cpp source</li> <li>capturetoolbutton.h</li> <li>capturetoolbutton.h source</li> <li>capturetoolobjects.cpp</li> <li>capturetoolobjects.cpp source</li> <li>capturetoolobjects.h</li> <li>capturetoolobjects.h source</li> <li>capturewidget.cpp</li> <li>capturewidget.cpp source</li> <li>capturewidget.h</li> <li>capturewidget.h source</li> <li>colorpicker.cpp</li> <li>colorpicker.cpp source</li> <li>colorpicker.h</li> <li>colorpicker.h source</li> <li>hovereventfilter.cpp</li> <li>hovereventfilter.cpp source</li> <li>hovereventfilter.h</li> <li>hovereventfilter.h source</li> <li>magnifierwidget.cpp</li> <li>magnifierwidget.cpp source</li> <li>magnifierwidget.h</li> <li>magnifierwidget.h source</li> <li>modificationcommand.cpp</li> <li>modificationcommand.cpp source</li> <li>modificationcommand.h</li> <li>modificationcommand.h source</li> <li>notifierbox.cpp</li> <li>notifierbox.cpp source</li> <li>notifierbox.h</li> <li>notifierbox.h source</li> <li>overlaymessage.cpp</li> <li>overlaymessage.cpp source</li> <li>overlaymessage.h</li> <li>overlaymessage.h source</li> <li>selectionwidget.cpp</li> <li>selectionwidget.cpp source</li> <li>selectionwidget.h</li> <li>selectionwidget.h source</li> <li>capturelauncher.cpp</li> <li>capturelauncher.cpp source</li> <li>capturelauncher.h</li> <li>capturelauncher.h source</li> <li>colorpickerwidget.cpp</li> <li>colorpickerwidget.cpp source</li> <li>colorpickerwidget.h</li> <li>colorpickerwidget.h source</li> <li>draggablewidgetmaker.cpp</li> <li>draggablewidgetmaker.cpp source</li> <li>draggablewidgetmaker.h</li> <li>draggablewidgetmaker.h source</li> <li>imagelabel.cpp</li> <li>imagelabel.cpp source</li> <li>imagelabel.h</li> <li>imagelabel.h source</li> <li>imguploaddialog.cpp</li> <li>imguploaddialog.cpp source</li> <li>imguploaddialog.h</li> <li>imguploaddialog.h source</li> <li>infowindow.cpp</li> <li>infowindow.cpp source</li> <li>infowindow.h</li> <li>infowindow.h source</li> <li>loadspinner.cpp</li> <li>loadspinner.cpp source</li> <li>loadspinner.h</li> <li>loadspinner.h source</li> <li>notificationwidget.cpp</li> <li>notificationwidget.cpp source</li> <li>notificationwidget.h</li> <li>notificationwidget.h source</li> <li>orientablepushbutton.cpp</li> <li>orientablepushbutton.cpp source</li> <li>orientablepushbutton.h</li> <li>orientablepushbutton.h source</li> <li>panel</li> <li>colorgrabwidget.cpp</li> <li>colorgrabwidget.cpp source</li> <li>colorgrabwidget.h</li> <li>colorgrabwidget.h source</li> <li>sidepanelwidget.cpp</li> <li>sidepanelwidget.cpp source</li> <li>sidepanelwidget.h</li> <li>sidepanelwidget.h source</li> <li>utilitypanel.cpp</li> <li>utilitypanel.cpp source</li> <li>utilitypanel.h</li> <li>utilitypanel.h source</li> <li>trayicon.cpp</li> <li>trayicon.cpp source</li> <li>trayicon.h</li> <li>trayicon.h source</li> <li>updatenotificationwidget.cpp</li> <li>updatenotificationwidget.cpp source</li> <li>updatenotificationwidget.h</li> <li>updatenotificationwidget.h source</li> <li>uploadhistory.cpp</li> <li>uploadhistory.cpp source</li> <li>uploadhistory.h</li> <li>uploadhistory.h source</li> <li>uploadlineitem.cpp</li> <li>uploadlineitem.cpp source</li> <li>uploadlineitem.h</li> <li>uploadlineitem.h source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}